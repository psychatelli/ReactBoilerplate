{"ast":null,"code":"/*!\r\n * Materialize v0.100.2 (http://materializecss.com)\r\n * Copyright 2014-2017 Materialize\r\n * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)\r\n */\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Check for jQuery.\n\n\nif (typeof jQuery === 'undefined') {\n  // Check if require is a defined function.\n  if (typeof require === 'function') {\n    jQuery = $ = require('jquery'); // Else use the dollar sign alias.\n  } else {\n    jQuery = $;\n  }\n}\n\n;\n/*\r\n* jQuery Easing v1.4.0 - http://gsgd.co.uk/sandbox/jquery/easing/\r\n* Open source under the BSD License.\r\n* Copyright Â© 2008 George McGinley Smith\r\n* All rights reserved.\r\n* https://raw.github.com/gdsmith/jquery-easing/master/LICENSE\r\n*/\n\n(function (factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['jquery'], function ($) {\n      return factory($);\n    });\n  } else if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    exports = factory(require('jquery'));\n  } else {\n    factory(jQuery);\n  }\n})(function ($) {\n  // Preserve the original jQuery \"swing\" easing as \"jswing\"\n  $.easing['jswing'] = $.easing['swing'];\n  var pow = Math.pow,\n      sqrt = Math.sqrt,\n      sin = Math.sin,\n      cos = Math.cos,\n      PI = Math.PI,\n      c1 = 1.70158,\n      c2 = c1 * 1.525,\n      c3 = c1 + 1,\n      c4 = 2 * PI / 3,\n      c5 = 2 * PI / 4.5; // x is the fraction of animation progress, in the range 0..1\n\n  function bounceOut(x) {\n    var n1 = 7.5625,\n        d1 = 2.75;\n\n    if (x < 1 / d1) {\n      return n1 * x * x;\n    } else if (x < 2 / d1) {\n      return n1 * (x -= 1.5 / d1) * x + .75;\n    } else if (x < 2.5 / d1) {\n      return n1 * (x -= 2.25 / d1) * x + .9375;\n    } else {\n      return n1 * (x -= 2.625 / d1) * x + .984375;\n    }\n  }\n\n  $.extend($.easing, {\n    def: 'easeOutQuad',\n    swing: function swing(x) {\n      return $.easing[$.easing.def](x);\n    },\n    easeInQuad: function easeInQuad(x) {\n      return x * x;\n    },\n    easeOutQuad: function easeOutQuad(x) {\n      return 1 - (1 - x) * (1 - x);\n    },\n    easeInOutQuad: function easeInOutQuad(x) {\n      return x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\n    },\n    easeInCubic: function easeInCubic(x) {\n      return x * x * x;\n    },\n    easeOutCubic: function easeOutCubic(x) {\n      return 1 - pow(1 - x, 3);\n    },\n    easeInOutCubic: function easeInOutCubic(x) {\n      return x < 0.5 ? 4 * x * x * x : 1 - pow(-2 * x + 2, 3) / 2;\n    },\n    easeInQuart: function easeInQuart(x) {\n      return x * x * x * x;\n    },\n    easeOutQuart: function easeOutQuart(x) {\n      return 1 - pow(1 - x, 4);\n    },\n    easeInOutQuart: function easeInOutQuart(x) {\n      return x < 0.5 ? 8 * x * x * x * x : 1 - pow(-2 * x + 2, 4) / 2;\n    },\n    easeInQuint: function easeInQuint(x) {\n      return x * x * x * x * x;\n    },\n    easeOutQuint: function easeOutQuint(x) {\n      return 1 - pow(1 - x, 5);\n    },\n    easeInOutQuint: function easeInOutQuint(x) {\n      return x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\n    },\n    easeInSine: function easeInSine(x) {\n      return 1 - cos(x * PI / 2);\n    },\n    easeOutSine: function easeOutSine(x) {\n      return sin(x * PI / 2);\n    },\n    easeInOutSine: function easeInOutSine(x) {\n      return -(cos(PI * x) - 1) / 2;\n    },\n    easeInExpo: function easeInExpo(x) {\n      return x === 0 ? 0 : pow(2, 10 * x - 10);\n    },\n    easeOutExpo: function easeOutExpo(x) {\n      return x === 1 ? 1 : 1 - pow(2, -10 * x);\n    },\n    easeInOutExpo: function easeInOutExpo(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? pow(2, 20 * x - 10) / 2 : (2 - pow(2, -20 * x + 10)) / 2;\n    },\n    easeInCirc: function easeInCirc(x) {\n      return 1 - sqrt(1 - pow(x, 2));\n    },\n    easeOutCirc: function easeOutCirc(x) {\n      return sqrt(1 - pow(x - 1, 2));\n    },\n    easeInOutCirc: function easeInOutCirc(x) {\n      return x < 0.5 ? (1 - sqrt(1 - pow(2 * x, 2))) / 2 : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n    },\n    easeInElastic: function easeInElastic(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4);\n    },\n    easeOutElastic: function easeOutElastic(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1;\n    },\n    easeInOutElastic: function easeInOutElastic(x) {\n      return x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2 : pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5) / 2 + 1;\n    },\n    easeInBack: function easeInBack(x) {\n      return c3 * x * x * x - c1 * x * x;\n    },\n    easeOutBack: function easeOutBack(x) {\n      return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n    },\n    easeInOutBack: function easeInOutBack(x) {\n      return x < 0.5 ? pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n    },\n    easeInBounce: function easeInBounce(x) {\n      return 1 - bounceOut(1 - x);\n    },\n    easeOutBounce: bounceOut,\n    easeInOutBounce: function easeInOutBounce(x) {\n      return x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n    }\n  });\n});\n\n; // Custom Easing\n\njQuery.extend(jQuery.easing, {\n  easeInOutMaterial: function easeInOutMaterial(x, t, b, c, d) {\n    if ((t /= d / 2) < 1) return c / 2 * t * t + b;\n    return c / 4 * ((t -= 2) * t * t + 2) + b;\n  }\n});\n;\n/*! VelocityJS.org (1.2.3). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */\n\n/*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */\n\n/*! Note that this has been modified by Materialize to confirm that Velocity is not already being imported. */\n\njQuery.Velocity ? console.log(\"Velocity is already loaded. You may be needlessly importing Velocity again; note that Materialize includes Velocity.\") : (!function (e) {\n  function t(e) {\n    var t = e.length,\n        a = r.type(e);\n    return \"function\" === a || r.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : \"array\" === a || 0 === t || \"number\" == typeof t && t > 0 && t - 1 in e;\n  }\n\n  if (!e.jQuery) {\n    var r = function r(e, t) {\n      return new r.fn.init(e, t);\n    };\n\n    r.isWindow = function (e) {\n      return null != e && e == e.window;\n    }, r.type = function (e) {\n      return null == e ? e + \"\" : \"object\" == typeof e || \"function\" == typeof e ? n[i.call(e)] || \"object\" : typeof e;\n    }, r.isArray = Array.isArray || function (e) {\n      return \"array\" === r.type(e);\n    }, r.isPlainObject = function (e) {\n      var t;\n      if (!e || \"object\" !== r.type(e) || e.nodeType || r.isWindow(e)) return !1;\n\n      try {\n        if (e.constructor && !o.call(e, \"constructor\") && !o.call(e.constructor.prototype, \"isPrototypeOf\")) return !1;\n      } catch (a) {\n        return !1;\n      }\n\n      for (t in e) {}\n\n      return void 0 === t || o.call(e, t);\n    }, r.each = function (e, r, a) {\n      var n,\n          o = 0,\n          i = e.length,\n          s = t(e);\n\n      if (a) {\n        if (s) for (; i > o && (n = r.apply(e[o], a), n !== !1); o++) {} else for (o in e) {\n          if (n = r.apply(e[o], a), n === !1) break;\n        }\n      } else if (s) for (; i > o && (n = r.call(e[o], o, e[o]), n !== !1); o++) {} else for (o in e) {\n        if (n = r.call(e[o], o, e[o]), n === !1) break;\n      }\n\n      return e;\n    }, r.data = function (e, t, n) {\n      if (void 0 === n) {\n        var o = e[r.expando],\n            i = o && a[o];\n        if (void 0 === t) return i;\n        if (i && t in i) return i[t];\n      } else if (void 0 !== t) {\n        var o = e[r.expando] || (e[r.expando] = ++r.uuid);\n        return a[o] = a[o] || {}, a[o][t] = n, n;\n      }\n    }, r.removeData = function (e, t) {\n      var n = e[r.expando],\n          o = n && a[n];\n      o && r.each(t, function (e, t) {\n        delete o[t];\n      });\n    }, r.extend = function () {\n      var e,\n          t,\n          a,\n          n,\n          o,\n          i,\n          s = arguments[0] || {},\n          l = 1,\n          u = arguments.length,\n          c = !1;\n\n      for (\"boolean\" == typeof s && (c = s, s = arguments[l] || {}, l++), \"object\" != typeof s && \"function\" !== r.type(s) && (s = {}), l === u && (s = this, l--); u > l; l++) {\n        if (null != (o = arguments[l])) for (n in o) {\n          e = s[n], a = o[n], s !== a && (c && a && (r.isPlainObject(a) || (t = r.isArray(a))) ? (t ? (t = !1, i = e && r.isArray(e) ? e : []) : i = e && r.isPlainObject(e) ? e : {}, s[n] = r.extend(c, i, a)) : void 0 !== a && (s[n] = a));\n        }\n      }\n\n      return s;\n    }, r.queue = function (e, a, n) {\n      function o(e, r) {\n        var a = r || [];\n        return null != e && (t(Object(e)) ? !function (e, t) {\n          for (var r = +t.length, a = 0, n = e.length; r > a;) {\n            e[n++] = t[a++];\n          }\n\n          if (r !== r) for (; void 0 !== t[a];) {\n            e[n++] = t[a++];\n          }\n          return e.length = n, e;\n        }(a, \"string\" == typeof e ? [e] : e) : [].push.call(a, e)), a;\n      }\n\n      if (e) {\n        a = (a || \"fx\") + \"queue\";\n        var i = r.data(e, a);\n        return n ? (!i || r.isArray(n) ? i = r.data(e, a, o(n)) : i.push(n), i) : i || [];\n      }\n    }, r.dequeue = function (e, t) {\n      r.each(e.nodeType ? [e] : e, function (e, a) {\n        t = t || \"fx\";\n        var n = r.queue(a, t),\n            o = n.shift();\n        \"inprogress\" === o && (o = n.shift()), o && (\"fx\" === t && n.unshift(\"inprogress\"), o.call(a, function () {\n          r.dequeue(a, t);\n        }));\n      });\n    }, r.fn = r.prototype = {\n      init: function init(e) {\n        if (e.nodeType) return this[0] = e, this;\n        throw new Error(\"Not a DOM node.\");\n      },\n      offset: function offset() {\n        var t = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {\n          top: 0,\n          left: 0\n        };\n        return {\n          top: t.top + (e.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),\n          left: t.left + (e.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)\n        };\n      },\n      position: function position() {\n        function e() {\n          for (var e = this.offsetParent || document; e && \"html\" === !e.nodeType.toLowerCase && \"static\" === e.style.position;) {\n            e = e.offsetParent;\n          }\n\n          return e || document;\n        }\n\n        var t = this[0],\n            e = e.apply(t),\n            a = this.offset(),\n            n = /^(?:body|html)$/i.test(e.nodeName) ? {\n          top: 0,\n          left: 0\n        } : r(e).offset();\n        return a.top -= parseFloat(t.style.marginTop) || 0, a.left -= parseFloat(t.style.marginLeft) || 0, e.style && (n.top += parseFloat(e.style.borderTopWidth) || 0, n.left += parseFloat(e.style.borderLeftWidth) || 0), {\n          top: a.top - n.top,\n          left: a.left - n.left\n        };\n      }\n    };\n    var a = {};\n    r.expando = \"velocity\" + new Date().getTime(), r.uuid = 0;\n\n    for (var n = {}, o = n.hasOwnProperty, i = n.toString, s = \"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), l = 0; l < s.length; l++) {\n      n[\"[object \" + s[l] + \"]\"] = s[l].toLowerCase();\n    }\n\n    r.fn.init.prototype = r.fn, e.Velocity = {\n      Utilities: r\n    };\n  }\n}(window), function (e) {\n  \"object\" == typeof module && \"object\" == typeof module.exports ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : e();\n}(function () {\n  return function (e, t, r, a) {\n    function n(e) {\n      for (var t = -1, r = e ? e.length : 0, a = []; ++t < r;) {\n        var n = e[t];\n        n && a.push(n);\n      }\n\n      return a;\n    }\n\n    function o(e) {\n      return m.isWrapped(e) ? e = [].slice.call(e) : m.isNode(e) && (e = [e]), e;\n    }\n\n    function i(e) {\n      var t = f.data(e, \"velocity\");\n      return null === t ? a : t;\n    }\n\n    function s(e) {\n      return function (t) {\n        return Math.round(t * e) * (1 / e);\n      };\n    }\n\n    function l(e, r, a, n) {\n      function o(e, t) {\n        return 1 - 3 * t + 3 * e;\n      }\n\n      function i(e, t) {\n        return 3 * t - 6 * e;\n      }\n\n      function s(e) {\n        return 3 * e;\n      }\n\n      function l(e, t, r) {\n        return ((o(t, r) * e + i(t, r)) * e + s(t)) * e;\n      }\n\n      function u(e, t, r) {\n        return 3 * o(t, r) * e * e + 2 * i(t, r) * e + s(t);\n      }\n\n      function c(t, r) {\n        for (var n = 0; m > n; ++n) {\n          var o = u(r, e, a);\n          if (0 === o) return r;\n          var i = l(r, e, a) - t;\n          r -= i / o;\n        }\n\n        return r;\n      }\n\n      function p() {\n        for (var t = 0; b > t; ++t) {\n          w[t] = l(t * x, e, a);\n        }\n      }\n\n      function f(t, r, n) {\n        var o,\n            i,\n            s = 0;\n\n        do {\n          i = r + (n - r) / 2, o = l(i, e, a) - t, o > 0 ? n = i : r = i;\n        } while (Math.abs(o) > h && ++s < v);\n\n        return i;\n      }\n\n      function d(t) {\n        for (var r = 0, n = 1, o = b - 1; n != o && w[n] <= t; ++n) {\n          r += x;\n        }\n\n        --n;\n        var i = (t - w[n]) / (w[n + 1] - w[n]),\n            s = r + i * x,\n            l = u(s, e, a);\n        return l >= y ? c(t, s) : 0 == l ? s : f(t, r, r + x);\n      }\n\n      function g() {\n        V = !0, (e != r || a != n) && p();\n      }\n\n      var m = 4,\n          y = .001,\n          h = 1e-7,\n          v = 10,\n          b = 11,\n          x = 1 / (b - 1),\n          S = \"Float32Array\" in t;\n      if (4 !== arguments.length) return !1;\n\n      for (var P = 0; 4 > P; ++P) {\n        if (\"number\" != typeof arguments[P] || isNaN(arguments[P]) || !isFinite(arguments[P])) return !1;\n      }\n\n      e = Math.min(e, 1), a = Math.min(a, 1), e = Math.max(e, 0), a = Math.max(a, 0);\n\n      var w = S ? new Float32Array(b) : new Array(b),\n          V = !1,\n          C = function C(t) {\n        return V || g(), e === r && a === n ? t : 0 === t ? 0 : 1 === t ? 1 : l(d(t), r, n);\n      };\n\n      C.getControlPoints = function () {\n        return [{\n          x: e,\n          y: r\n        }, {\n          x: a,\n          y: n\n        }];\n      };\n\n      var T = \"generateBezier(\" + [e, r, a, n] + \")\";\n      return C.toString = function () {\n        return T;\n      }, C;\n    }\n\n    function u(e, t) {\n      var r = e;\n      return m.isString(e) ? b.Easings[e] || (r = !1) : r = m.isArray(e) && 1 === e.length ? s.apply(null, e) : m.isArray(e) && 2 === e.length ? x.apply(null, e.concat([t])) : m.isArray(e) && 4 === e.length ? l.apply(null, e) : !1, r === !1 && (r = b.Easings[b.defaults.easing] ? b.defaults.easing : v), r;\n    }\n\n    function c(e) {\n      if (e) {\n        var t = new Date().getTime(),\n            r = b.State.calls.length;\n        r > 1e4 && (b.State.calls = n(b.State.calls));\n\n        for (var o = 0; r > o; o++) {\n          if (b.State.calls[o]) {\n            var s = b.State.calls[o],\n                l = s[0],\n                u = s[2],\n                d = s[3],\n                g = !!d,\n                y = null;\n            d || (d = b.State.calls[o][3] = t - 16);\n\n            for (var h = Math.min((t - d) / u.duration, 1), v = 0, x = l.length; x > v; v++) {\n              var P = l[v],\n                  V = P.element;\n\n              if (i(V)) {\n                var C = !1;\n\n                if (u.display !== a && null !== u.display && \"none\" !== u.display) {\n                  if (\"flex\" === u.display) {\n                    var T = [\"-webkit-box\", \"-moz-box\", \"-ms-flexbox\", \"-webkit-flex\"];\n                    f.each(T, function (e, t) {\n                      S.setPropertyValue(V, \"display\", t);\n                    });\n                  }\n\n                  S.setPropertyValue(V, \"display\", u.display);\n                }\n\n                u.visibility !== a && \"hidden\" !== u.visibility && S.setPropertyValue(V, \"visibility\", u.visibility);\n\n                for (var k in P) {\n                  if (\"element\" !== k) {\n                    var A,\n                        F = P[k],\n                        j = m.isString(F.easing) ? b.Easings[F.easing] : F.easing;\n                    if (1 === h) A = F.endValue;else {\n                      var E = F.endValue - F.startValue;\n                      if (A = F.startValue + E * j(h, u, E), !g && A === F.currentValue) continue;\n                    }\n                    if (F.currentValue = A, \"tween\" === k) y = A;else {\n                      if (S.Hooks.registered[k]) {\n                        var H = S.Hooks.getRoot(k),\n                            N = i(V).rootPropertyValueCache[H];\n                        N && (F.rootPropertyValue = N);\n                      }\n\n                      var L = S.setPropertyValue(V, k, F.currentValue + (0 === parseFloat(A) ? \"\" : F.unitType), F.rootPropertyValue, F.scrollData);\n                      S.Hooks.registered[k] && (i(V).rootPropertyValueCache[H] = S.Normalizations.registered[H] ? S.Normalizations.registered[H](\"extract\", null, L[1]) : L[1]), \"transform\" === L[0] && (C = !0);\n                    }\n                  }\n                }\n\n                u.mobileHA && i(V).transformCache.translate3d === a && (i(V).transformCache.translate3d = \"(0px, 0px, 0px)\", C = !0), C && S.flushTransformCache(V);\n              }\n            }\n\n            u.display !== a && \"none\" !== u.display && (b.State.calls[o][2].display = !1), u.visibility !== a && \"hidden\" !== u.visibility && (b.State.calls[o][2].visibility = !1), u.progress && u.progress.call(s[1], s[1], h, Math.max(0, d + u.duration - t), d, y), 1 === h && p(o);\n          }\n        }\n      }\n\n      b.State.isTicking && w(c);\n    }\n\n    function p(e, t) {\n      if (!b.State.calls[e]) return !1;\n\n      for (var r = b.State.calls[e][0], n = b.State.calls[e][1], o = b.State.calls[e][2], s = b.State.calls[e][4], l = !1, u = 0, c = r.length; c > u; u++) {\n        var p = r[u].element;\n\n        if (t || o.loop || (\"none\" === o.display && S.setPropertyValue(p, \"display\", o.display), \"hidden\" === o.visibility && S.setPropertyValue(p, \"visibility\", o.visibility)), o.loop !== !0 && (f.queue(p)[1] === a || !/\\.velocityQueueEntryFlag/i.test(f.queue(p)[1])) && i(p)) {\n          i(p).isAnimating = !1, i(p).rootPropertyValueCache = {};\n          var d = !1;\n          f.each(S.Lists.transforms3D, function (e, t) {\n            var r = /^scale/.test(t) ? 1 : 0,\n                n = i(p).transformCache[t];\n            i(p).transformCache[t] !== a && new RegExp(\"^\\\\(\" + r + \"[^.]\").test(n) && (d = !0, delete i(p).transformCache[t]);\n          }), o.mobileHA && (d = !0, delete i(p).transformCache.translate3d), d && S.flushTransformCache(p), S.Values.removeClass(p, \"velocity-animating\");\n        }\n\n        if (!t && o.complete && !o.loop && u === c - 1) try {\n          o.complete.call(n, n);\n        } catch (g) {\n          setTimeout(function () {\n            throw g;\n          }, 1);\n        }\n        s && o.loop !== !0 && s(n), i(p) && o.loop === !0 && !t && (f.each(i(p).tweensContainer, function (e, t) {\n          /^rotate/.test(e) && 360 === parseFloat(t.endValue) && (t.endValue = 0, t.startValue = 360), /^backgroundPosition/.test(e) && 100 === parseFloat(t.endValue) && \"%\" === t.unitType && (t.endValue = 0, t.startValue = 100);\n        }), b(p, \"reverse\", {\n          loop: !0,\n          delay: o.delay\n        })), o.queue !== !1 && f.dequeue(p, o.queue);\n      }\n\n      b.State.calls[e] = !1;\n\n      for (var m = 0, y = b.State.calls.length; y > m; m++) {\n        if (b.State.calls[m] !== !1) {\n          l = !0;\n          break;\n        }\n      }\n\n      l === !1 && (b.State.isTicking = !1, delete b.State.calls, b.State.calls = []);\n    }\n\n    var f,\n        d = function () {\n      if (r.documentMode) return r.documentMode;\n\n      for (var e = 7; e > 4; e--) {\n        var t = r.createElement(\"div\");\n        if (t.innerHTML = \"<!--[if IE \" + e + \"]><span></span><![endif]-->\", t.getElementsByTagName(\"span\").length) return t = null, e;\n      }\n\n      return a;\n    }(),\n        g = function () {\n      var e = 0;\n      return t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || function (t) {\n        var r,\n            a = new Date().getTime();\n        return r = Math.max(0, 16 - (a - e)), e = a + r, setTimeout(function () {\n          t(a + r);\n        }, r);\n      };\n    }(),\n        m = {\n      isString: function isString(e) {\n        return \"string\" == typeof e;\n      },\n      isArray: Array.isArray || function (e) {\n        return \"[object Array]\" === Object.prototype.toString.call(e);\n      },\n      isFunction: function isFunction(e) {\n        return \"[object Function]\" === Object.prototype.toString.call(e);\n      },\n      isNode: function isNode(e) {\n        return e && e.nodeType;\n      },\n      isNodeList: function isNodeList(e) {\n        return \"object\" == typeof e && /^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(e)) && e.length !== a && (0 === e.length || \"object\" == typeof e[0] && e[0].nodeType > 0);\n      },\n      isWrapped: function isWrapped(e) {\n        return e && (e.jquery || t.Zepto && t.Zepto.zepto.isZ(e));\n      },\n      isSVG: function isSVG(e) {\n        return t.SVGElement && e instanceof t.SVGElement;\n      },\n      isEmptyObject: function isEmptyObject(e) {\n        for (var t in e) {\n          return !1;\n        }\n\n        return !0;\n      }\n    },\n        y = !1;\n\n    if (e.fn && e.fn.jquery ? (f = e, y = !0) : f = t.Velocity.Utilities, 8 >= d && !y) throw new Error(\"Velocity: IE8 and below require jQuery to be loaded before Velocity.\");\n    if (7 >= d) return void (jQuery.fn.velocity = jQuery.fn.animate);\n    var h = 400,\n        v = \"swing\",\n        b = {\n      State: {\n        isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),\n        isAndroid: /Android/i.test(navigator.userAgent),\n        isGingerbread: /Android 2\\.3\\.[3-7]/i.test(navigator.userAgent),\n        isChrome: t.chrome,\n        isFirefox: /Firefox/i.test(navigator.userAgent),\n        prefixElement: r.createElement(\"div\"),\n        prefixMatches: {},\n        scrollAnchor: null,\n        scrollPropertyLeft: null,\n        scrollPropertyTop: null,\n        isTicking: !1,\n        calls: []\n      },\n      CSS: {},\n      Utilities: f,\n      Redirects: {},\n      Easings: {},\n      Promise: t.Promise,\n      defaults: {\n        queue: \"\",\n        duration: h,\n        easing: v,\n        begin: a,\n        complete: a,\n        progress: a,\n        display: a,\n        visibility: a,\n        loop: !1,\n        delay: !1,\n        mobileHA: !0,\n        _cacheValues: !0\n      },\n      init: function init(e) {\n        f.data(e, \"velocity\", {\n          isSVG: m.isSVG(e),\n          isAnimating: !1,\n          computedStyle: null,\n          tweensContainer: null,\n          rootPropertyValueCache: {},\n          transformCache: {}\n        });\n      },\n      hook: null,\n      mock: !1,\n      version: {\n        major: 1,\n        minor: 2,\n        patch: 2\n      },\n      debug: !1\n    };\n    t.pageYOffset !== a ? (b.State.scrollAnchor = t, b.State.scrollPropertyLeft = \"pageXOffset\", b.State.scrollPropertyTop = \"pageYOffset\") : (b.State.scrollAnchor = r.documentElement || r.body.parentNode || r.body, b.State.scrollPropertyLeft = \"scrollLeft\", b.State.scrollPropertyTop = \"scrollTop\");\n\n    var x = function () {\n      function e(e) {\n        return -e.tension * e.x - e.friction * e.v;\n      }\n\n      function t(t, r, a) {\n        var n = {\n          x: t.x + a.dx * r,\n          v: t.v + a.dv * r,\n          tension: t.tension,\n          friction: t.friction\n        };\n        return {\n          dx: n.v,\n          dv: e(n)\n        };\n      }\n\n      function r(r, a) {\n        var n = {\n          dx: r.v,\n          dv: e(r)\n        },\n            o = t(r, .5 * a, n),\n            i = t(r, .5 * a, o),\n            s = t(r, a, i),\n            l = 1 / 6 * (n.dx + 2 * (o.dx + i.dx) + s.dx),\n            u = 1 / 6 * (n.dv + 2 * (o.dv + i.dv) + s.dv);\n        return r.x = r.x + l * a, r.v = r.v + u * a, r;\n      }\n\n      return function a(e, t, n) {\n        var o,\n            i,\n            s,\n            l = {\n          x: -1,\n          v: 0,\n          tension: null,\n          friction: null\n        },\n            u = [0],\n            c = 0,\n            p = 1e-4,\n            f = .016;\n\n        for (e = parseFloat(e) || 500, t = parseFloat(t) || 20, n = n || null, l.tension = e, l.friction = t, o = null !== n, o ? (c = a(e, t), i = c / n * f) : i = f; s = r(s || l, i), u.push(1 + s.x), c += 16, Math.abs(s.x) > p && Math.abs(s.v) > p;) {}\n\n        return o ? function (e) {\n          return u[e * (u.length - 1) | 0];\n        } : c;\n      };\n    }();\n\n    b.Easings = {\n      linear: function linear(e) {\n        return e;\n      },\n      swing: function swing(e) {\n        return .5 - Math.cos(e * Math.PI) / 2;\n      },\n      spring: function spring(e) {\n        return 1 - Math.cos(4.5 * e * Math.PI) * Math.exp(6 * -e);\n      }\n    }, f.each([[\"ease\", [.25, .1, .25, 1]], [\"ease-in\", [.42, 0, 1, 1]], [\"ease-out\", [0, 0, .58, 1]], [\"ease-in-out\", [.42, 0, .58, 1]], [\"easeInSine\", [.47, 0, .745, .715]], [\"easeOutSine\", [.39, .575, .565, 1]], [\"easeInOutSine\", [.445, .05, .55, .95]], [\"easeInQuad\", [.55, .085, .68, .53]], [\"easeOutQuad\", [.25, .46, .45, .94]], [\"easeInOutQuad\", [.455, .03, .515, .955]], [\"easeInCubic\", [.55, .055, .675, .19]], [\"easeOutCubic\", [.215, .61, .355, 1]], [\"easeInOutCubic\", [.645, .045, .355, 1]], [\"easeInQuart\", [.895, .03, .685, .22]], [\"easeOutQuart\", [.165, .84, .44, 1]], [\"easeInOutQuart\", [.77, 0, .175, 1]], [\"easeInQuint\", [.755, .05, .855, .06]], [\"easeOutQuint\", [.23, 1, .32, 1]], [\"easeInOutQuint\", [.86, 0, .07, 1]], [\"easeInExpo\", [.95, .05, .795, .035]], [\"easeOutExpo\", [.19, 1, .22, 1]], [\"easeInOutExpo\", [1, 0, 0, 1]], [\"easeInCirc\", [.6, .04, .98, .335]], [\"easeOutCirc\", [.075, .82, .165, 1]], [\"easeInOutCirc\", [.785, .135, .15, .86]]], function (e, t) {\n      b.Easings[t[0]] = l.apply(null, t[1]);\n    });\n    var S = b.CSS = {\n      RegEx: {\n        isHex: /^#([A-f\\d]{3}){1,2}$/i,\n        valueUnwrap: /^[A-z]+\\((.*)\\)$/i,\n        wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,\n        valueSplit: /([A-z]+\\(.+\\))|(([A-z0-9#-.]+?)(?=\\s|$))/gi\n      },\n      Lists: {\n        colors: [\"fill\", \"stroke\", \"stopColor\", \"color\", \"backgroundColor\", \"borderColor\", \"borderTopColor\", \"borderRightColor\", \"borderBottomColor\", \"borderLeftColor\", \"outlineColor\"],\n        transformsBase: [\"translateX\", \"translateY\", \"scale\", \"scaleX\", \"scaleY\", \"skewX\", \"skewY\", \"rotateZ\"],\n        transforms3D: [\"transformPerspective\", \"translateZ\", \"scaleZ\", \"rotateX\", \"rotateY\"]\n      },\n      Hooks: {\n        templates: {\n          textShadow: [\"Color X Y Blur\", \"black 0px 0px 0px\"],\n          boxShadow: [\"Color X Y Blur Spread\", \"black 0px 0px 0px 0px\"],\n          clip: [\"Top Right Bottom Left\", \"0px 0px 0px 0px\"],\n          backgroundPosition: [\"X Y\", \"0% 0%\"],\n          transformOrigin: [\"X Y Z\", \"50% 50% 0px\"],\n          perspectiveOrigin: [\"X Y\", \"50% 50%\"]\n        },\n        registered: {},\n        register: function register() {\n          for (var e = 0; e < S.Lists.colors.length; e++) {\n            var t = \"color\" === S.Lists.colors[e] ? \"0 0 0 1\" : \"255 255 255 1\";\n            S.Hooks.templates[S.Lists.colors[e]] = [\"Red Green Blue Alpha\", t];\n          }\n\n          var r, a, n;\n          if (d) for (r in S.Hooks.templates) {\n            a = S.Hooks.templates[r], n = a[0].split(\" \");\n            var o = a[1].match(S.RegEx.valueSplit);\n            \"Color\" === n[0] && (n.push(n.shift()), o.push(o.shift()), S.Hooks.templates[r] = [n.join(\" \"), o.join(\" \")]);\n          }\n\n          for (r in S.Hooks.templates) {\n            a = S.Hooks.templates[r], n = a[0].split(\" \");\n\n            for (var e in n) {\n              var i = r + n[e],\n                  s = e;\n              S.Hooks.registered[i] = [r, s];\n            }\n          }\n        },\n        getRoot: function getRoot(e) {\n          var t = S.Hooks.registered[e];\n          return t ? t[0] : e;\n        },\n        cleanRootPropertyValue: function cleanRootPropertyValue(e, t) {\n          return S.RegEx.valueUnwrap.test(t) && (t = t.match(S.RegEx.valueUnwrap)[1]), S.Values.isCSSNullValue(t) && (t = S.Hooks.templates[e][1]), t;\n        },\n        extractValue: function extractValue(e, t) {\n          var r = S.Hooks.registered[e];\n\n          if (r) {\n            var a = r[0],\n                n = r[1];\n            return t = S.Hooks.cleanRootPropertyValue(a, t), t.toString().match(S.RegEx.valueSplit)[n];\n          }\n\n          return t;\n        },\n        injectValue: function injectValue(e, t, r) {\n          var a = S.Hooks.registered[e];\n\n          if (a) {\n            var n,\n                o,\n                i = a[0],\n                s = a[1];\n            return r = S.Hooks.cleanRootPropertyValue(i, r), n = r.toString().match(S.RegEx.valueSplit), n[s] = t, o = n.join(\" \");\n          }\n\n          return r;\n        }\n      },\n      Normalizations: {\n        registered: {\n          clip: function clip(e, t, r) {\n            switch (e) {\n              case \"name\":\n                return \"clip\";\n\n              case \"extract\":\n                var a;\n                return S.RegEx.wrappedValueAlreadyExtracted.test(r) ? a = r : (a = r.toString().match(S.RegEx.valueUnwrap), a = a ? a[1].replace(/,(\\s+)?/g, \" \") : r), a;\n\n              case \"inject\":\n                return \"rect(\" + r + \")\";\n            }\n          },\n          blur: function blur(e, t, r) {\n            switch (e) {\n              case \"name\":\n                return b.State.isFirefox ? \"filter\" : \"-webkit-filter\";\n\n              case \"extract\":\n                var a = parseFloat(r);\n\n                if (!a && 0 !== a) {\n                  var n = r.toString().match(/blur\\(([0-9]+[A-z]+)\\)/i);\n                  a = n ? n[1] : 0;\n                }\n\n                return a;\n\n              case \"inject\":\n                return parseFloat(r) ? \"blur(\" + r + \")\" : \"none\";\n            }\n          },\n          opacity: function opacity(e, t, r) {\n            if (8 >= d) switch (e) {\n              case \"name\":\n                return \"filter\";\n\n              case \"extract\":\n                var a = r.toString().match(/alpha\\(opacity=(.*)\\)/i);\n                return r = a ? a[1] / 100 : 1;\n\n              case \"inject\":\n                return t.style.zoom = 1, parseFloat(r) >= 1 ? \"\" : \"alpha(opacity=\" + parseInt(100 * parseFloat(r), 10) + \")\";\n            } else switch (e) {\n              case \"name\":\n                return \"opacity\";\n\n              case \"extract\":\n                return r;\n\n              case \"inject\":\n                return r;\n            }\n          }\n        },\n        register: function register() {\n          9 >= d || b.State.isGingerbread || (S.Lists.transformsBase = S.Lists.transformsBase.concat(S.Lists.transforms3D));\n\n          for (var e = 0; e < S.Lists.transformsBase.length; e++) {\n            !function () {\n              var t = S.Lists.transformsBase[e];\n\n              S.Normalizations.registered[t] = function (e, r, n) {\n                switch (e) {\n                  case \"name\":\n                    return \"transform\";\n\n                  case \"extract\":\n                    return i(r) === a || i(r).transformCache[t] === a ? /^scale/i.test(t) ? 1 : 0 : i(r).transformCache[t].replace(/[()]/g, \"\");\n\n                  case \"inject\":\n                    var o = !1;\n\n                    switch (t.substr(0, t.length - 1)) {\n                      case \"translate\":\n                        o = !/(%|px|em|rem|vw|vh|\\d)$/i.test(n);\n                        break;\n\n                      case \"scal\":\n                      case \"scale\":\n                        b.State.isAndroid && i(r).transformCache[t] === a && 1 > n && (n = 1), o = !/(\\d)$/i.test(n);\n                        break;\n\n                      case \"skew\":\n                        o = !/(deg|\\d)$/i.test(n);\n                        break;\n\n                      case \"rotate\":\n                        o = !/(deg|\\d)$/i.test(n);\n                    }\n\n                    return o || (i(r).transformCache[t] = \"(\" + n + \")\"), i(r).transformCache[t];\n                }\n              };\n            }();\n          }\n\n          for (var e = 0; e < S.Lists.colors.length; e++) {\n            !function () {\n              var t = S.Lists.colors[e];\n\n              S.Normalizations.registered[t] = function (e, r, n) {\n                switch (e) {\n                  case \"name\":\n                    return t;\n\n                  case \"extract\":\n                    var o;\n                    if (S.RegEx.wrappedValueAlreadyExtracted.test(n)) o = n;else {\n                      var i,\n                          s = {\n                        black: \"rgb(0, 0, 0)\",\n                        blue: \"rgb(0, 0, 255)\",\n                        gray: \"rgb(128, 128, 128)\",\n                        green: \"rgb(0, 128, 0)\",\n                        red: \"rgb(255, 0, 0)\",\n                        white: \"rgb(255, 255, 255)\"\n                      };\n                      /^[A-z]+$/i.test(n) ? i = s[n] !== a ? s[n] : s.black : S.RegEx.isHex.test(n) ? i = \"rgb(\" + S.Values.hexToRgb(n).join(\" \") + \")\" : /^rgba?\\(/i.test(n) || (i = s.black), o = (i || n).toString().match(S.RegEx.valueUnwrap)[1].replace(/,(\\s+)?/g, \" \");\n                    }\n                    return 8 >= d || 3 !== o.split(\" \").length || (o += \" 1\"), o;\n\n                  case \"inject\":\n                    return 8 >= d ? 4 === n.split(\" \").length && (n = n.split(/\\s+/).slice(0, 3).join(\" \")) : 3 === n.split(\" \").length && (n += \" 1\"), (8 >= d ? \"rgb\" : \"rgba\") + \"(\" + n.replace(/\\s+/g, \",\").replace(/\\.(\\d)+(?=,)/g, \"\") + \")\";\n                }\n              };\n            }();\n          }\n        }\n      },\n      Names: {\n        camelCase: function camelCase(e) {\n          return e.replace(/-(\\w)/g, function (e, t) {\n            return t.toUpperCase();\n          });\n        },\n        SVGAttribute: function SVGAttribute(e) {\n          var t = \"width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2\";\n          return (d || b.State.isAndroid && !b.State.isChrome) && (t += \"|transform\"), new RegExp(\"^(\" + t + \")$\", \"i\").test(e);\n        },\n        prefixCheck: function prefixCheck(e) {\n          if (b.State.prefixMatches[e]) return [b.State.prefixMatches[e], !0];\n\n          for (var t = [\"\", \"Webkit\", \"Moz\", \"ms\", \"O\"], r = 0, a = t.length; a > r; r++) {\n            var n;\n            if (n = 0 === r ? e : t[r] + e.replace(/^\\w/, function (e) {\n              return e.toUpperCase();\n            }), m.isString(b.State.prefixElement.style[n])) return b.State.prefixMatches[e] = n, [n, !0];\n          }\n\n          return [e, !1];\n        }\n      },\n      Values: {\n        hexToRgb: function hexToRgb(e) {\n          var t,\n              r = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i,\n              a = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n          return e = e.replace(r, function (e, t, r, a) {\n            return t + t + r + r + a + a;\n          }), t = a.exec(e), t ? [parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16)] : [0, 0, 0];\n        },\n        isCSSNullValue: function isCSSNullValue(e) {\n          return 0 == e || /^(none|auto|transparent|(rgba\\(0, ?0, ?0, ?0\\)))$/i.test(e);\n        },\n        getUnitType: function getUnitType(e) {\n          return /^(rotate|skew)/i.test(e) ? \"deg\" : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e) ? \"\" : \"px\";\n        },\n        getDisplayType: function getDisplayType(e) {\n          var t = e && e.tagName.toString().toLowerCase();\n          return /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t) ? \"inline\" : /^(li)$/i.test(t) ? \"list-item\" : /^(tr)$/i.test(t) ? \"table-row\" : /^(table)$/i.test(t) ? \"table\" : /^(tbody)$/i.test(t) ? \"table-row-group\" : \"block\";\n        },\n        addClass: function addClass(e, t) {\n          e.classList ? e.classList.add(t) : e.className += (e.className.length ? \" \" : \"\") + t;\n        },\n        removeClass: function removeClass(e, t) {\n          e.classList ? e.classList.remove(t) : e.className = e.className.toString().replace(new RegExp(\"(^|\\\\s)\" + t.split(\" \").join(\"|\") + \"(\\\\s|$)\", \"gi\"), \" \");\n        }\n      },\n      getPropertyValue: function getPropertyValue(e, r, n, o) {\n        function s(e, r) {\n          function n() {\n            u && S.setPropertyValue(e, \"display\", \"none\");\n          }\n\n          var l = 0;\n          if (8 >= d) l = f.css(e, r);else {\n            var u = !1;\n\n            if (/^(width|height)$/.test(r) && 0 === S.getPropertyValue(e, \"display\") && (u = !0, S.setPropertyValue(e, \"display\", S.Values.getDisplayType(e))), !o) {\n              if (\"height\" === r && \"border-box\" !== S.getPropertyValue(e, \"boxSizing\").toString().toLowerCase()) {\n                var c = e.offsetHeight - (parseFloat(S.getPropertyValue(e, \"borderTopWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"borderBottomWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingTop\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingBottom\")) || 0);\n                return n(), c;\n              }\n\n              if (\"width\" === r && \"border-box\" !== S.getPropertyValue(e, \"boxSizing\").toString().toLowerCase()) {\n                var p = e.offsetWidth - (parseFloat(S.getPropertyValue(e, \"borderLeftWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"borderRightWidth\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingLeft\")) || 0) - (parseFloat(S.getPropertyValue(e, \"paddingRight\")) || 0);\n                return n(), p;\n              }\n            }\n\n            var g;\n            g = i(e) === a ? t.getComputedStyle(e, null) : i(e).computedStyle ? i(e).computedStyle : i(e).computedStyle = t.getComputedStyle(e, null), \"borderColor\" === r && (r = \"borderTopColor\"), l = 9 === d && \"filter\" === r ? g.getPropertyValue(r) : g[r], (\"\" === l || null === l) && (l = e.style[r]), n();\n          }\n\n          if (\"auto\" === l && /^(top|right|bottom|left)$/i.test(r)) {\n            var m = s(e, \"position\");\n            (\"fixed\" === m || \"absolute\" === m && /top|left/i.test(r)) && (l = f(e).position()[r] + \"px\");\n          }\n\n          return l;\n        }\n\n        var l;\n\n        if (S.Hooks.registered[r]) {\n          var u = r,\n              c = S.Hooks.getRoot(u);\n          n === a && (n = S.getPropertyValue(e, S.Names.prefixCheck(c)[0])), S.Normalizations.registered[c] && (n = S.Normalizations.registered[c](\"extract\", e, n)), l = S.Hooks.extractValue(u, n);\n        } else if (S.Normalizations.registered[r]) {\n          var p, g;\n          p = S.Normalizations.registered[r](\"name\", e), \"transform\" !== p && (g = s(e, S.Names.prefixCheck(p)[0]), S.Values.isCSSNullValue(g) && S.Hooks.templates[r] && (g = S.Hooks.templates[r][1])), l = S.Normalizations.registered[r](\"extract\", e, g);\n        }\n\n        if (!/^[\\d-]/.test(l)) if (i(e) && i(e).isSVG && S.Names.SVGAttribute(r)) {\n          if (/^(height|width)$/i.test(r)) try {\n            l = e.getBBox()[r];\n          } catch (m) {\n            l = 0;\n          } else l = e.getAttribute(r);\n        } else l = s(e, S.Names.prefixCheck(r)[0]);\n        return S.Values.isCSSNullValue(l) && (l = 0), b.debug >= 2 && console.log(\"Get \" + r + \": \" + l), l;\n      },\n      setPropertyValue: function setPropertyValue(e, r, a, n, o) {\n        var s = r;\n        if (\"scroll\" === r) o.container ? o.container[\"scroll\" + o.direction] = a : \"Left\" === o.direction ? t.scrollTo(a, o.alternateValue) : t.scrollTo(o.alternateValue, a);else if (S.Normalizations.registered[r] && \"transform\" === S.Normalizations.registered[r](\"name\", e)) S.Normalizations.registered[r](\"inject\", e, a), s = \"transform\", a = i(e).transformCache[r];else {\n          if (S.Hooks.registered[r]) {\n            var l = r,\n                u = S.Hooks.getRoot(r);\n            n = n || S.getPropertyValue(e, u), a = S.Hooks.injectValue(l, a, n), r = u;\n          }\n\n          if (S.Normalizations.registered[r] && (a = S.Normalizations.registered[r](\"inject\", e, a), r = S.Normalizations.registered[r](\"name\", e)), s = S.Names.prefixCheck(r)[0], 8 >= d) try {\n            e.style[s] = a;\n          } catch (c) {\n            b.debug && console.log(\"Browser does not support [\" + a + \"] for [\" + s + \"]\");\n          } else i(e) && i(e).isSVG && S.Names.SVGAttribute(r) ? e.setAttribute(r, a) : e.style[s] = a;\n          b.debug >= 2 && console.log(\"Set \" + r + \" (\" + s + \"): \" + a);\n        }\n        return [s, a];\n      },\n      flushTransformCache: function flushTransformCache(e) {\n        function t(t) {\n          return parseFloat(S.getPropertyValue(e, t));\n        }\n\n        var r = \"\";\n\n        if ((d || b.State.isAndroid && !b.State.isChrome) && i(e).isSVG) {\n          var a = {\n            translate: [t(\"translateX\"), t(\"translateY\")],\n            skewX: [t(\"skewX\")],\n            skewY: [t(\"skewY\")],\n            scale: 1 !== t(\"scale\") ? [t(\"scale\"), t(\"scale\")] : [t(\"scaleX\"), t(\"scaleY\")],\n            rotate: [t(\"rotateZ\"), 0, 0]\n          };\n          f.each(i(e).transformCache, function (e) {\n            /^translate/i.test(e) ? e = \"translate\" : /^scale/i.test(e) ? e = \"scale\" : /^rotate/i.test(e) && (e = \"rotate\"), a[e] && (r += e + \"(\" + a[e].join(\" \") + \") \", delete a[e]);\n          });\n        } else {\n          var n, o;\n          f.each(i(e).transformCache, function (t) {\n            return n = i(e).transformCache[t], \"transformPerspective\" === t ? (o = n, !0) : (9 === d && \"rotateZ\" === t && (t = \"rotate\"), void (r += t + n + \" \"));\n          }), o && (r = \"perspective\" + o + \" \" + r);\n        }\n\n        S.setPropertyValue(e, \"transform\", r);\n      }\n    };\n    S.Hooks.register(), S.Normalizations.register(), b.hook = function (e, t, r) {\n      var n = a;\n      return e = o(e), f.each(e, function (e, o) {\n        if (i(o) === a && b.init(o), r === a) n === a && (n = b.CSS.getPropertyValue(o, t));else {\n          var s = b.CSS.setPropertyValue(o, t, r);\n          \"transform\" === s[0] && b.CSS.flushTransformCache(o), n = s;\n        }\n      }), n;\n    };\n\n    var P = function P() {\n      function e() {\n        return s ? k.promise || null : l;\n      }\n\n      function n() {\n        function e(e) {\n          function p(e, t) {\n            var r = a,\n                n = a,\n                i = a;\n            return m.isArray(e) ? (r = e[0], !m.isArray(e[1]) && /^[\\d-]/.test(e[1]) || m.isFunction(e[1]) || S.RegEx.isHex.test(e[1]) ? i = e[1] : (m.isString(e[1]) && !S.RegEx.isHex.test(e[1]) || m.isArray(e[1])) && (n = t ? e[1] : u(e[1], s.duration), e[2] !== a && (i = e[2]))) : r = e, t || (n = n || s.easing), m.isFunction(r) && (r = r.call(o, V, w)), m.isFunction(i) && (i = i.call(o, V, w)), [r || 0, n, i];\n          }\n\n          function d(e, t) {\n            var r, a;\n            return a = (t || \"0\").toString().toLowerCase().replace(/[%A-z]+$/, function (e) {\n              return r = e, \"\";\n            }), r || (r = S.Values.getUnitType(e)), [a, r];\n          }\n\n          function h() {\n            var e = {\n              myParent: o.parentNode || r.body,\n              position: S.getPropertyValue(o, \"position\"),\n              fontSize: S.getPropertyValue(o, \"fontSize\")\n            },\n                a = e.position === L.lastPosition && e.myParent === L.lastParent,\n                n = e.fontSize === L.lastFontSize;\n            L.lastParent = e.myParent, L.lastPosition = e.position, L.lastFontSize = e.fontSize;\n            var s = 100,\n                l = {};\n            if (n && a) l.emToPx = L.lastEmToPx, l.percentToPxWidth = L.lastPercentToPxWidth, l.percentToPxHeight = L.lastPercentToPxHeight;else {\n              var u = i(o).isSVG ? r.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\") : r.createElement(\"div\");\n              b.init(u), e.myParent.appendChild(u), f.each([\"overflow\", \"overflowX\", \"overflowY\"], function (e, t) {\n                b.CSS.setPropertyValue(u, t, \"hidden\");\n              }), b.CSS.setPropertyValue(u, \"position\", e.position), b.CSS.setPropertyValue(u, \"fontSize\", e.fontSize), b.CSS.setPropertyValue(u, \"boxSizing\", \"content-box\"), f.each([\"minWidth\", \"maxWidth\", \"width\", \"minHeight\", \"maxHeight\", \"height\"], function (e, t) {\n                b.CSS.setPropertyValue(u, t, s + \"%\");\n              }), b.CSS.setPropertyValue(u, \"paddingLeft\", s + \"em\"), l.percentToPxWidth = L.lastPercentToPxWidth = (parseFloat(S.getPropertyValue(u, \"width\", null, !0)) || 1) / s, l.percentToPxHeight = L.lastPercentToPxHeight = (parseFloat(S.getPropertyValue(u, \"height\", null, !0)) || 1) / s, l.emToPx = L.lastEmToPx = (parseFloat(S.getPropertyValue(u, \"paddingLeft\")) || 1) / s, e.myParent.removeChild(u);\n            }\n            return null === L.remToPx && (L.remToPx = parseFloat(S.getPropertyValue(r.body, \"fontSize\")) || 16), null === L.vwToPx && (L.vwToPx = parseFloat(t.innerWidth) / 100, L.vhToPx = parseFloat(t.innerHeight) / 100), l.remToPx = L.remToPx, l.vwToPx = L.vwToPx, l.vhToPx = L.vhToPx, b.debug >= 1 && console.log(\"Unit ratios: \" + JSON.stringify(l), o), l;\n          }\n\n          if (s.begin && 0 === V) try {\n            s.begin.call(g, g);\n          } catch (x) {\n            setTimeout(function () {\n              throw x;\n            }, 1);\n          }\n\n          if (\"scroll\" === A) {\n            var P,\n                C,\n                T,\n                F = /^x$/i.test(s.axis) ? \"Left\" : \"Top\",\n                j = parseFloat(s.offset) || 0;\n            s.container ? m.isWrapped(s.container) || m.isNode(s.container) ? (s.container = s.container[0] || s.container, P = s.container[\"scroll\" + F], T = P + f(o).position()[F.toLowerCase()] + j) : s.container = null : (P = b.State.scrollAnchor[b.State[\"scrollProperty\" + F]], C = b.State.scrollAnchor[b.State[\"scrollProperty\" + (\"Left\" === F ? \"Top\" : \"Left\")]], T = f(o).offset()[F.toLowerCase()] + j), l = {\n              scroll: {\n                rootPropertyValue: !1,\n                startValue: P,\n                currentValue: P,\n                endValue: T,\n                unitType: \"\",\n                easing: s.easing,\n                scrollData: {\n                  container: s.container,\n                  direction: F,\n                  alternateValue: C\n                }\n              },\n              element: o\n            }, b.debug && console.log(\"tweensContainer (scroll): \", l.scroll, o);\n          } else if (\"reverse\" === A) {\n            if (!i(o).tweensContainer) return void f.dequeue(o, s.queue);\n            \"none\" === i(o).opts.display && (i(o).opts.display = \"auto\"), \"hidden\" === i(o).opts.visibility && (i(o).opts.visibility = \"visible\"), i(o).opts.loop = !1, i(o).opts.begin = null, i(o).opts.complete = null, v.easing || delete s.easing, v.duration || delete s.duration, s = f.extend({}, i(o).opts, s);\n            var E = f.extend(!0, {}, i(o).tweensContainer);\n\n            for (var H in E) {\n              if (\"element\" !== H) {\n                var N = E[H].startValue;\n                E[H].startValue = E[H].currentValue = E[H].endValue, E[H].endValue = N, m.isEmptyObject(v) || (E[H].easing = s.easing), b.debug && console.log(\"reverse tweensContainer (\" + H + \"): \" + JSON.stringify(E[H]), o);\n              }\n            }\n\n            l = E;\n          } else if (\"start\" === A) {\n            var E;\n            i(o).tweensContainer && i(o).isAnimating === !0 && (E = i(o).tweensContainer), f.each(y, function (e, t) {\n              if (RegExp(\"^\" + S.Lists.colors.join(\"$|^\") + \"$\").test(e)) {\n                var r = p(t, !0),\n                    n = r[0],\n                    o = r[1],\n                    i = r[2];\n\n                if (S.RegEx.isHex.test(n)) {\n                  for (var s = [\"Red\", \"Green\", \"Blue\"], l = S.Values.hexToRgb(n), u = i ? S.Values.hexToRgb(i) : a, c = 0; c < s.length; c++) {\n                    var f = [l[c]];\n                    o && f.push(o), u !== a && f.push(u[c]), y[e + s[c]] = f;\n                  }\n\n                  delete y[e];\n                }\n              }\n            });\n\n            for (var z in y) {\n              var O = p(y[z]),\n                  q = O[0],\n                  $ = O[1],\n                  M = O[2];\n              z = S.Names.camelCase(z);\n              var I = S.Hooks.getRoot(z),\n                  B = !1;\n\n              if (i(o).isSVG || \"tween\" === I || S.Names.prefixCheck(I)[1] !== !1 || S.Normalizations.registered[I] !== a) {\n                (s.display !== a && null !== s.display && \"none\" !== s.display || s.visibility !== a && \"hidden\" !== s.visibility) && /opacity|filter/.test(z) && !M && 0 !== q && (M = 0), s._cacheValues && E && E[z] ? (M === a && (M = E[z].endValue + E[z].unitType), B = i(o).rootPropertyValueCache[I]) : S.Hooks.registered[z] ? M === a ? (B = S.getPropertyValue(o, I), M = S.getPropertyValue(o, z, B)) : B = S.Hooks.templates[I][1] : M === a && (M = S.getPropertyValue(o, z));\n                var W,\n                    G,\n                    Y,\n                    D = !1;\n                if (W = d(z, M), M = W[0], Y = W[1], W = d(z, q), q = W[0].replace(/^([+-\\/*])=/, function (e, t) {\n                  return D = t, \"\";\n                }), G = W[1], M = parseFloat(M) || 0, q = parseFloat(q) || 0, \"%\" === G && (/^(fontSize|lineHeight)$/.test(z) ? (q /= 100, G = \"em\") : /^scale/.test(z) ? (q /= 100, G = \"\") : /(Red|Green|Blue)$/i.test(z) && (q = q / 100 * 255, G = \"\")), /[\\/*]/.test(D)) G = Y;else if (Y !== G && 0 !== M) if (0 === q) G = Y;else {\n                  n = n || h();\n                  var Q = /margin|padding|left|right|width|text|word|letter/i.test(z) || /X$/.test(z) || \"x\" === z ? \"x\" : \"y\";\n\n                  switch (Y) {\n                    case \"%\":\n                      M *= \"x\" === Q ? n.percentToPxWidth : n.percentToPxHeight;\n                      break;\n\n                    case \"px\":\n                      break;\n\n                    default:\n                      M *= n[Y + \"ToPx\"];\n                  }\n\n                  switch (G) {\n                    case \"%\":\n                      M *= 1 / (\"x\" === Q ? n.percentToPxWidth : n.percentToPxHeight);\n                      break;\n\n                    case \"px\":\n                      break;\n\n                    default:\n                      M *= 1 / n[G + \"ToPx\"];\n                  }\n                }\n\n                switch (D) {\n                  case \"+\":\n                    q = M + q;\n                    break;\n\n                  case \"-\":\n                    q = M - q;\n                    break;\n\n                  case \"*\":\n                    q = M * q;\n                    break;\n\n                  case \"/\":\n                    q = M / q;\n                }\n\n                l[z] = {\n                  rootPropertyValue: B,\n                  startValue: M,\n                  currentValue: M,\n                  endValue: q,\n                  unitType: G,\n                  easing: $\n                }, b.debug && console.log(\"tweensContainer (\" + z + \"): \" + JSON.stringify(l[z]), o);\n              } else b.debug && console.log(\"Skipping [\" + I + \"] due to a lack of browser support.\");\n            }\n\n            l.element = o;\n          }\n\n          l.element && (S.Values.addClass(o, \"velocity-animating\"), R.push(l), \"\" === s.queue && (i(o).tweensContainer = l, i(o).opts = s), i(o).isAnimating = !0, V === w - 1 ? (b.State.calls.push([R, g, s, null, k.resolver]), b.State.isTicking === !1 && (b.State.isTicking = !0, c())) : V++);\n        }\n\n        var n,\n            o = this,\n            s = f.extend({}, b.defaults, v),\n            l = {};\n\n        switch (i(o) === a && b.init(o), parseFloat(s.delay) && s.queue !== !1 && f.queue(o, s.queue, function (e) {\n          b.velocityQueueEntryFlag = !0, i(o).delayTimer = {\n            setTimeout: setTimeout(e, parseFloat(s.delay)),\n            next: e\n          };\n        }), s.duration.toString().toLowerCase()) {\n          case \"fast\":\n            s.duration = 200;\n            break;\n\n          case \"normal\":\n            s.duration = h;\n            break;\n\n          case \"slow\":\n            s.duration = 600;\n            break;\n\n          default:\n            s.duration = parseFloat(s.duration) || 1;\n        }\n\n        b.mock !== !1 && (b.mock === !0 ? s.duration = s.delay = 1 : (s.duration *= parseFloat(b.mock) || 1, s.delay *= parseFloat(b.mock) || 1)), s.easing = u(s.easing, s.duration), s.begin && !m.isFunction(s.begin) && (s.begin = null), s.progress && !m.isFunction(s.progress) && (s.progress = null), s.complete && !m.isFunction(s.complete) && (s.complete = null), s.display !== a && null !== s.display && (s.display = s.display.toString().toLowerCase(), \"auto\" === s.display && (s.display = b.CSS.Values.getDisplayType(o))), s.visibility !== a && null !== s.visibility && (s.visibility = s.visibility.toString().toLowerCase()), s.mobileHA = s.mobileHA && b.State.isMobile && !b.State.isGingerbread, s.queue === !1 ? s.delay ? setTimeout(e, s.delay) : e() : f.queue(o, s.queue, function (t, r) {\n          return r === !0 ? (k.promise && k.resolver(g), !0) : (b.velocityQueueEntryFlag = !0, void e(t));\n        }), \"\" !== s.queue && \"fx\" !== s.queue || \"inprogress\" === f.queue(o)[0] || f.dequeue(o);\n      }\n\n      var s,\n          l,\n          d,\n          g,\n          y,\n          v,\n          x = arguments[0] && (arguments[0].p || f.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || m.isString(arguments[0].properties));\n\n      if (m.isWrapped(this) ? (s = !1, d = 0, g = this, l = this) : (s = !0, d = 1, g = x ? arguments[0].elements || arguments[0].e : arguments[0]), g = o(g)) {\n        x ? (y = arguments[0].properties || arguments[0].p, v = arguments[0].options || arguments[0].o) : (y = arguments[d], v = arguments[d + 1]);\n        var w = g.length,\n            V = 0;\n\n        if (!/^(stop|finish)$/i.test(y) && !f.isPlainObject(v)) {\n          var C = d + 1;\n          v = {};\n\n          for (var T = C; T < arguments.length; T++) {\n            m.isArray(arguments[T]) || !/^(fast|normal|slow)$/i.test(arguments[T]) && !/^\\d/.test(arguments[T]) ? m.isString(arguments[T]) || m.isArray(arguments[T]) ? v.easing = arguments[T] : m.isFunction(arguments[T]) && (v.complete = arguments[T]) : v.duration = arguments[T];\n          }\n        }\n\n        var k = {\n          promise: null,\n          resolver: null,\n          rejecter: null\n        };\n        s && b.Promise && (k.promise = new b.Promise(function (e, t) {\n          k.resolver = e, k.rejecter = t;\n        }));\n        var A;\n\n        switch (y) {\n          case \"scroll\":\n            A = \"scroll\";\n            break;\n\n          case \"reverse\":\n            A = \"reverse\";\n            break;\n\n          case \"finish\":\n          case \"stop\":\n            f.each(g, function (e, t) {\n              i(t) && i(t).delayTimer && (clearTimeout(i(t).delayTimer.setTimeout), i(t).delayTimer.next && i(t).delayTimer.next(), delete i(t).delayTimer);\n            });\n            var F = [];\n            return f.each(b.State.calls, function (e, t) {\n              t && f.each(t[1], function (r, n) {\n                var o = v === a ? \"\" : v;\n                return o === !0 || t[2].queue === o || v === a && t[2].queue === !1 ? void f.each(g, function (r, a) {\n                  a === n && ((v === !0 || m.isString(v)) && (f.each(f.queue(a, m.isString(v) ? v : \"\"), function (e, t) {\n                    m.isFunction(t) && t(null, !0);\n                  }), f.queue(a, m.isString(v) ? v : \"\", [])), \"stop\" === y ? (i(a) && i(a).tweensContainer && o !== !1 && f.each(i(a).tweensContainer, function (e, t) {\n                    t.endValue = t.currentValue;\n                  }), F.push(e)) : \"finish\" === y && (t[2].duration = 1));\n                }) : !0;\n              });\n            }), \"stop\" === y && (f.each(F, function (e, t) {\n              p(t, !0);\n            }), k.promise && k.resolver(g)), e();\n\n          default:\n            if (!f.isPlainObject(y) || m.isEmptyObject(y)) {\n              if (m.isString(y) && b.Redirects[y]) {\n                var j = f.extend({}, v),\n                    E = j.duration,\n                    H = j.delay || 0;\n                return j.backwards === !0 && (g = f.extend(!0, [], g).reverse()), f.each(g, function (e, t) {\n                  parseFloat(j.stagger) ? j.delay = H + parseFloat(j.stagger) * e : m.isFunction(j.stagger) && (j.delay = H + j.stagger.call(t, e, w)), j.drag && (j.duration = parseFloat(E) || (/^(callout|transition)/.test(y) ? 1e3 : h), j.duration = Math.max(j.duration * (j.backwards ? 1 - e / w : (e + 1) / w), .75 * j.duration, 200)), b.Redirects[y].call(t, t, j || {}, e, w, g, k.promise ? k : a);\n                }), e();\n              }\n\n              var N = \"Velocity: First argument (\" + y + \") was not a property map, a known action, or a registered redirect. Aborting.\";\n              return k.promise ? k.rejecter(new Error(N)) : console.log(N), e();\n            }\n\n            A = \"start\";\n        }\n\n        var L = {\n          lastParent: null,\n          lastPosition: null,\n          lastFontSize: null,\n          lastPercentToPxWidth: null,\n          lastPercentToPxHeight: null,\n          lastEmToPx: null,\n          remToPx: null,\n          vwToPx: null,\n          vhToPx: null\n        },\n            R = [];\n        f.each(g, function (e, t) {\n          m.isNode(t) && n.call(t);\n        });\n        var z,\n            j = f.extend({}, b.defaults, v);\n        if (j.loop = parseInt(j.loop), z = 2 * j.loop - 1, j.loop) for (var O = 0; z > O; O++) {\n          var q = {\n            delay: j.delay,\n            progress: j.progress\n          };\n          O === z - 1 && (q.display = j.display, q.visibility = j.visibility, q.complete = j.complete), P(g, \"reverse\", q);\n        }\n        return e();\n      }\n    };\n\n    b = f.extend(P, b), b.animate = P;\n    var w = t.requestAnimationFrame || g;\n    return b.State.isMobile || r.hidden === a || r.addEventListener(\"visibilitychange\", function () {\n      r.hidden ? (w = function w(e) {\n        return setTimeout(function () {\n          e(!0);\n        }, 16);\n      }, c()) : w = t.requestAnimationFrame || g;\n    }), e.Velocity = b, e !== t && (e.fn.velocity = P, e.fn.velocity.defaults = b.defaults), f.each([\"Down\", \"Up\"], function (e, t) {\n      b.Redirects[\"slide\" + t] = function (e, r, n, o, i, s) {\n        var l = f.extend({}, r),\n            u = l.begin,\n            c = l.complete,\n            p = {\n          height: \"\",\n          marginTop: \"\",\n          marginBottom: \"\",\n          paddingTop: \"\",\n          paddingBottom: \"\"\n        },\n            d = {};\n        l.display === a && (l.display = \"Down\" === t ? \"inline\" === b.CSS.Values.getDisplayType(e) ? \"inline-block\" : \"block\" : \"none\"), l.begin = function () {\n          u && u.call(i, i);\n\n          for (var r in p) {\n            d[r] = e.style[r];\n            var a = b.CSS.getPropertyValue(e, r);\n            p[r] = \"Down\" === t ? [a, 0] : [0, a];\n          }\n\n          d.overflow = e.style.overflow, e.style.overflow = \"hidden\";\n        }, l.complete = function () {\n          for (var t in d) {\n            e.style[t] = d[t];\n          }\n\n          c && c.call(i, i), s && s.resolver(i);\n        }, b(e, p, l);\n      };\n    }), f.each([\"In\", \"Out\"], function (e, t) {\n      b.Redirects[\"fade\" + t] = function (e, r, n, o, i, s) {\n        var l = f.extend({}, r),\n            u = {\n          opacity: \"In\" === t ? 1 : 0\n        },\n            c = l.complete;\n        l.complete = n !== o - 1 ? l.begin = null : function () {\n          c && c.call(i, i), s && s.resolver(i);\n        }, l.display === a && (l.display = \"In\" === t ? \"auto\" : \"none\"), b(this, u, l);\n      };\n    }), b;\n  }(window.jQuery || window.Zepto || window, window, document);\n}));\n;\n!function (a, b, c, d) {\n  \"use strict\";\n\n  function k(a, b, c) {\n    return setTimeout(q(a, c), b);\n  }\n\n  function l(a, b, c) {\n    return Array.isArray(a) ? (m(a, c[b], c), !0) : !1;\n  }\n\n  function m(a, b, c) {\n    var e;\n    if (a) if (a.forEach) a.forEach(b, c);else if (a.length !== d) for (e = 0; e < a.length;) {\n      b.call(c, a[e], e, a), e++;\n    } else for (e in a) {\n      a.hasOwnProperty(e) && b.call(c, a[e], e, a);\n    }\n  }\n\n  function n(a, b, c) {\n    for (var e = Object.keys(b), f = 0; f < e.length;) {\n      (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;\n    }\n\n    return a;\n  }\n\n  function o(a, b) {\n    return n(a, b, !0);\n  }\n\n  function p(a, b, c) {\n    var e,\n        d = b.prototype;\n    e = a.prototype = Object.create(d), e.constructor = a, e._super = d, c && n(e, c);\n  }\n\n  function q(a, b) {\n    return function () {\n      return a.apply(b, arguments);\n    };\n  }\n\n  function r(a, b) {\n    return typeof a == g ? a.apply(b ? b[0] || d : d, b) : a;\n  }\n\n  function s(a, b) {\n    return a === d ? b : a;\n  }\n\n  function t(a, b, c) {\n    m(x(b), function (b) {\n      a.addEventListener(b, c, !1);\n    });\n  }\n\n  function u(a, b, c) {\n    m(x(b), function (b) {\n      a.removeEventListener(b, c, !1);\n    });\n  }\n\n  function v(a, b) {\n    for (; a;) {\n      if (a == b) return !0;\n      a = a.parentNode;\n    }\n\n    return !1;\n  }\n\n  function w(a, b) {\n    return a.indexOf(b) > -1;\n  }\n\n  function x(a) {\n    return a.trim().split(/\\s+/g);\n  }\n\n  function y(a, b, c) {\n    if (a.indexOf && !c) return a.indexOf(b);\n\n    for (var d = 0; d < a.length;) {\n      if (c && a[d][c] == b || !c && a[d] === b) return d;\n      d++;\n    }\n\n    return -1;\n  }\n\n  function z(a) {\n    return Array.prototype.slice.call(a, 0);\n  }\n\n  function A(a, b, c) {\n    for (var d = [], e = [], f = 0; f < a.length;) {\n      var g = b ? a[f][b] : a[f];\n      y(e, g) < 0 && d.push(a[f]), e[f] = g, f++;\n    }\n\n    return c && (d = b ? d.sort(function (a, c) {\n      return a[b] > c[b];\n    }) : d.sort()), d;\n  }\n\n  function B(a, b) {\n    for (var c, f, g = b[0].toUpperCase() + b.slice(1), h = 0; h < e.length;) {\n      if (c = e[h], f = c ? c + g : b, f in a) return f;\n      h++;\n    }\n\n    return d;\n  }\n\n  function D() {\n    return C++;\n  }\n\n  function E(a) {\n    var b = a.ownerDocument;\n    return b.defaultView || b.parentWindow;\n  }\n\n  function ab(a, b) {\n    var c = this;\n    this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {\n      r(a.options.enable, [a]) && c.handler(b);\n    }, this.init();\n  }\n\n  function bb(a) {\n    var b,\n        c = a.options.inputClass;\n    return b = c ? c : H ? wb : I ? Eb : G ? Gb : rb, new b(a, cb);\n  }\n\n  function cb(a, b, c) {\n    var d = c.pointers.length,\n        e = c.changedPointers.length,\n        f = b & O && 0 === d - e,\n        g = b & (Q | R) && 0 === d - e;\n    c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, db(a, c), a.emit(\"hammer.input\", c), a.recognize(c), a.session.prevInput = c;\n  }\n\n  function db(a, b) {\n    var c = a.session,\n        d = b.pointers,\n        e = d.length;\n    c.firstInput || (c.firstInput = gb(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = gb(b) : 1 === e && (c.firstMultiple = !1);\n    var f = c.firstInput,\n        g = c.firstMultiple,\n        h = g ? g.center : f.center,\n        i = b.center = hb(d);\n    b.timeStamp = j(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = lb(h, i), b.distance = kb(h, i), eb(c, b), b.offsetDirection = jb(b.deltaX, b.deltaY), b.scale = g ? nb(g.pointers, d) : 1, b.rotation = g ? mb(g.pointers, d) : 0, fb(c, b);\n    var k = a.element;\n    v(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k;\n  }\n\n  function eb(a, b) {\n    var c = b.center,\n        d = a.offsetDelta || {},\n        e = a.prevDelta || {},\n        f = a.prevInput || {};\n    (b.eventType === O || f.eventType === Q) && (e = a.prevDelta = {\n      x: f.deltaX || 0,\n      y: f.deltaY || 0\n    }, d = a.offsetDelta = {\n      x: c.x,\n      y: c.y\n    }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);\n  }\n\n  function fb(a, b) {\n    var f,\n        g,\n        h,\n        j,\n        c = a.lastInterval || b,\n        e = b.timeStamp - c.timeStamp;\n\n    if (b.eventType != R && (e > N || c.velocity === d)) {\n      var k = c.deltaX - b.deltaX,\n          l = c.deltaY - b.deltaY,\n          m = ib(e, k, l);\n      g = m.x, h = m.y, f = i(m.x) > i(m.y) ? m.x : m.y, j = jb(k, l), a.lastInterval = b;\n    } else f = c.velocity, g = c.velocityX, h = c.velocityY, j = c.direction;\n\n    b.velocity = f, b.velocityX = g, b.velocityY = h, b.direction = j;\n  }\n\n  function gb(a) {\n    for (var b = [], c = 0; c < a.pointers.length;) {\n      b[c] = {\n        clientX: h(a.pointers[c].clientX),\n        clientY: h(a.pointers[c].clientY)\n      }, c++;\n    }\n\n    return {\n      timeStamp: j(),\n      pointers: b,\n      center: hb(b),\n      deltaX: a.deltaX,\n      deltaY: a.deltaY\n    };\n  }\n\n  function hb(a) {\n    var b = a.length;\n    if (1 === b) return {\n      x: h(a[0].clientX),\n      y: h(a[0].clientY)\n    };\n\n    for (var c = 0, d = 0, e = 0; b > e;) {\n      c += a[e].clientX, d += a[e].clientY, e++;\n    }\n\n    return {\n      x: h(c / b),\n      y: h(d / b)\n    };\n  }\n\n  function ib(a, b, c) {\n    return {\n      x: b / a || 0,\n      y: c / a || 0\n    };\n  }\n\n  function jb(a, b) {\n    return a === b ? S : i(a) >= i(b) ? a > 0 ? T : U : b > 0 ? V : W;\n  }\n\n  function kb(a, b, c) {\n    c || (c = $);\n    var d = b[c[0]] - a[c[0]],\n        e = b[c[1]] - a[c[1]];\n    return Math.sqrt(d * d + e * e);\n  }\n\n  function lb(a, b, c) {\n    c || (c = $);\n    var d = b[c[0]] - a[c[0]],\n        e = b[c[1]] - a[c[1]];\n    return 180 * Math.atan2(e, d) / Math.PI;\n  }\n\n  function mb(a, b) {\n    return lb(b[1], b[0], _) - lb(a[1], a[0], _);\n  }\n\n  function nb(a, b) {\n    return kb(b[0], b[1], _) / kb(a[0], a[1], _);\n  }\n\n  function rb() {\n    this.evEl = pb, this.evWin = qb, this.allow = !0, this.pressed = !1, ab.apply(this, arguments);\n  }\n\n  function wb() {\n    this.evEl = ub, this.evWin = vb, ab.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];\n  }\n\n  function Ab() {\n    this.evTarget = yb, this.evWin = zb, this.started = !1, ab.apply(this, arguments);\n  }\n\n  function Bb(a, b) {\n    var c = z(a.touches),\n        d = z(a.changedTouches);\n    return b & (Q | R) && (c = A(c.concat(d), \"identifier\", !0)), [c, d];\n  }\n\n  function Eb() {\n    this.evTarget = Db, this.targetIds = {}, ab.apply(this, arguments);\n  }\n\n  function Fb(a, b) {\n    var c = z(a.touches),\n        d = this.targetIds;\n    if (b & (O | P) && 1 === c.length) return d[c[0].identifier] = !0, [c, c];\n    var e,\n        f,\n        g = z(a.changedTouches),\n        h = [],\n        i = this.target;\n    if (f = c.filter(function (a) {\n      return v(a.target, i);\n    }), b === O) for (e = 0; e < f.length;) {\n      d[f[e].identifier] = !0, e++;\n    }\n\n    for (e = 0; e < g.length;) {\n      d[g[e].identifier] && h.push(g[e]), b & (Q | R) && delete d[g[e].identifier], e++;\n    }\n\n    return h.length ? [A(f.concat(h), \"identifier\", !0), h] : void 0;\n  }\n\n  function Gb() {\n    ab.apply(this, arguments);\n    var a = q(this.handler, this);\n    this.touch = new Eb(this.manager, a), this.mouse = new rb(this.manager, a);\n  }\n\n  function Pb(a, b) {\n    this.manager = a, this.set(b);\n  }\n\n  function Qb(a) {\n    if (w(a, Mb)) return Mb;\n    var b = w(a, Nb),\n        c = w(a, Ob);\n    return b && c ? Nb + \" \" + Ob : b || c ? b ? Nb : Ob : w(a, Lb) ? Lb : Kb;\n  }\n\n  function Yb(a) {\n    this.id = D(), this.manager = null, this.options = o(a || {}, this.defaults), this.options.enable = s(this.options.enable, !0), this.state = Rb, this.simultaneous = {}, this.requireFail = [];\n  }\n\n  function Zb(a) {\n    return a & Wb ? \"cancel\" : a & Ub ? \"end\" : a & Tb ? \"move\" : a & Sb ? \"start\" : \"\";\n  }\n\n  function $b(a) {\n    return a == W ? \"down\" : a == V ? \"up\" : a == T ? \"left\" : a == U ? \"right\" : \"\";\n  }\n\n  function _b(a, b) {\n    var c = b.manager;\n    return c ? c.get(a) : a;\n  }\n\n  function ac() {\n    Yb.apply(this, arguments);\n  }\n\n  function bc() {\n    ac.apply(this, arguments), this.pX = null, this.pY = null;\n  }\n\n  function cc() {\n    ac.apply(this, arguments);\n  }\n\n  function dc() {\n    Yb.apply(this, arguments), this._timer = null, this._input = null;\n  }\n\n  function ec() {\n    ac.apply(this, arguments);\n  }\n\n  function fc() {\n    ac.apply(this, arguments);\n  }\n\n  function gc() {\n    Yb.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;\n  }\n\n  function hc(a, b) {\n    return b = b || {}, b.recognizers = s(b.recognizers, hc.defaults.preset), new kc(a, b);\n  }\n\n  function kc(a, b) {\n    b = b || {}, this.options = o(b, hc.defaults), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = a, this.input = bb(this), this.touchAction = new Pb(this, this.options.touchAction), lc(this, !0), m(b.recognizers, function (a) {\n      var b = this.add(new a[0](a[1]));\n      a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);\n    }, this);\n  }\n\n  function lc(a, b) {\n    var c = a.element;\n    m(a.options.cssProps, function (a, d) {\n      c.style[B(c.style, d)] = b ? a : \"\";\n    });\n  }\n\n  function mc(a, c) {\n    var d = b.createEvent(\"Event\");\n    d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);\n  }\n\n  var e = [\"\", \"webkit\", \"moz\", \"MS\", \"ms\", \"o\"],\n      f = b.createElement(\"div\"),\n      g = \"function\",\n      h = Math.round,\n      i = Math.abs,\n      j = Date.now,\n      C = 1,\n      F = /mobile|tablet|ip(ad|hone|od)|android/i,\n      G = \"ontouchstart\" in a,\n      H = B(a, \"PointerEvent\") !== d,\n      I = G && F.test(navigator.userAgent),\n      J = \"touch\",\n      K = \"pen\",\n      L = \"mouse\",\n      M = \"kinect\",\n      N = 25,\n      O = 1,\n      P = 2,\n      Q = 4,\n      R = 8,\n      S = 1,\n      T = 2,\n      U = 4,\n      V = 8,\n      W = 16,\n      X = T | U,\n      Y = V | W,\n      Z = X | Y,\n      $ = [\"x\", \"y\"],\n      _ = [\"clientX\", \"clientY\"];\n  ab.prototype = {\n    handler: function handler() {},\n    init: function init() {\n      this.evEl && t(this.element, this.evEl, this.domHandler), this.evTarget && t(this.target, this.evTarget, this.domHandler), this.evWin && t(E(this.element), this.evWin, this.domHandler);\n    },\n    destroy: function destroy() {\n      this.evEl && u(this.element, this.evEl, this.domHandler), this.evTarget && u(this.target, this.evTarget, this.domHandler), this.evWin && u(E(this.element), this.evWin, this.domHandler);\n    }\n  };\n  var ob = {\n    mousedown: O,\n    mousemove: P,\n    mouseup: Q\n  },\n      pb = \"mousedown\",\n      qb = \"mousemove mouseup\";\n  p(rb, ab, {\n    handler: function handler(a) {\n      var b = ob[a.type];\n      b & O && 0 === a.button && (this.pressed = !0), b & P && 1 !== a.which && (b = Q), this.pressed && this.allow && (b & Q && (this.pressed = !1), this.callback(this.manager, b, {\n        pointers: [a],\n        changedPointers: [a],\n        pointerType: L,\n        srcEvent: a\n      }));\n    }\n  });\n  var sb = {\n    pointerdown: O,\n    pointermove: P,\n    pointerup: Q,\n    pointercancel: R,\n    pointerout: R\n  },\n      tb = {\n    2: J,\n    3: K,\n    4: L,\n    5: M\n  },\n      ub = \"pointerdown\",\n      vb = \"pointermove pointerup pointercancel\";\n  a.MSPointerEvent && (ub = \"MSPointerDown\", vb = \"MSPointerMove MSPointerUp MSPointerCancel\"), p(wb, ab, {\n    handler: function handler(a) {\n      var b = this.store,\n          c = !1,\n          d = a.type.toLowerCase().replace(\"ms\", \"\"),\n          e = sb[d],\n          f = tb[a.pointerType] || a.pointerType,\n          g = f == J,\n          h = y(b, a.pointerId, \"pointerId\");\n      e & O && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Q | R) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, {\n        pointers: b,\n        changedPointers: [a],\n        pointerType: f,\n        srcEvent: a\n      }), c && b.splice(h, 1));\n    }\n  });\n  var xb = {\n    touchstart: O,\n    touchmove: P,\n    touchend: Q,\n    touchcancel: R\n  },\n      yb = \"touchstart\",\n      zb = \"touchstart touchmove touchend touchcancel\";\n  p(Ab, ab, {\n    handler: function handler(a) {\n      var b = xb[a.type];\n\n      if (b === O && (this.started = !0), this.started) {\n        var c = Bb.call(this, a, b);\n        b & (Q | R) && 0 === c[0].length - c[1].length && (this.started = !1), this.callback(this.manager, b, {\n          pointers: c[0],\n          changedPointers: c[1],\n          pointerType: J,\n          srcEvent: a\n        });\n      }\n    }\n  });\n  var Cb = {\n    touchstart: O,\n    touchmove: P,\n    touchend: Q,\n    touchcancel: R\n  },\n      Db = \"touchstart touchmove touchend touchcancel\";\n  p(Eb, ab, {\n    handler: function handler(a) {\n      var b = Cb[a.type],\n          c = Fb.call(this, a, b);\n      c && this.callback(this.manager, b, {\n        pointers: c[0],\n        changedPointers: c[1],\n        pointerType: J,\n        srcEvent: a\n      });\n    }\n  }), p(Gb, ab, {\n    handler: function handler(a, b, c) {\n      var d = c.pointerType == J,\n          e = c.pointerType == L;\n      if (d) this.mouse.allow = !1;else if (e && !this.mouse.allow) return;\n      b & (Q | R) && (this.mouse.allow = !0), this.callback(a, b, c);\n    },\n    destroy: function destroy() {\n      this.touch.destroy(), this.mouse.destroy();\n    }\n  });\n  var Hb = B(f.style, \"touchAction\"),\n      Ib = Hb !== d,\n      Jb = \"compute\",\n      Kb = \"auto\",\n      Lb = \"manipulation\",\n      Mb = \"none\",\n      Nb = \"pan-x\",\n      Ob = \"pan-y\";\n  Pb.prototype = {\n    set: function set(a) {\n      a == Jb && (a = this.compute()), Ib && (this.manager.element.style[Hb] = a), this.actions = a.toLowerCase().trim();\n    },\n    update: function update() {\n      this.set(this.manager.options.touchAction);\n    },\n    compute: function compute() {\n      var a = [];\n      return m(this.manager.recognizers, function (b) {\n        r(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()));\n      }), Qb(a.join(\" \"));\n    },\n    preventDefaults: function preventDefaults(a) {\n      if (!Ib) {\n        var b = a.srcEvent,\n            c = a.offsetDirection;\n        if (this.manager.session.prevented) return b.preventDefault(), void 0;\n        var d = this.actions,\n            e = w(d, Mb),\n            f = w(d, Ob),\n            g = w(d, Nb);\n        return e || f && c & X || g && c & Y ? this.preventSrc(b) : void 0;\n      }\n    },\n    preventSrc: function preventSrc(a) {\n      this.manager.session.prevented = !0, a.preventDefault();\n    }\n  };\n  var Rb = 1,\n      Sb = 2,\n      Tb = 4,\n      Ub = 8,\n      Vb = Ub,\n      Wb = 16,\n      Xb = 32;\n  Yb.prototype = {\n    defaults: {},\n    set: function set(a) {\n      return n(this.options, a), this.manager && this.manager.touchAction.update(), this;\n    },\n    recognizeWith: function recognizeWith(a) {\n      if (l(a, \"recognizeWith\", this)) return this;\n      var b = this.simultaneous;\n      return a = _b(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;\n    },\n    dropRecognizeWith: function dropRecognizeWith(a) {\n      return l(a, \"dropRecognizeWith\", this) ? this : (a = _b(a, this), delete this.simultaneous[a.id], this);\n    },\n    requireFailure: function requireFailure(a) {\n      if (l(a, \"requireFailure\", this)) return this;\n      var b = this.requireFail;\n      return a = _b(a, this), -1 === y(b, a) && (b.push(a), a.requireFailure(this)), this;\n    },\n    dropRequireFailure: function dropRequireFailure(a) {\n      if (l(a, \"dropRequireFailure\", this)) return this;\n      a = _b(a, this);\n      var b = y(this.requireFail, a);\n      return b > -1 && this.requireFail.splice(b, 1), this;\n    },\n    hasRequireFailures: function hasRequireFailures() {\n      return this.requireFail.length > 0;\n    },\n    canRecognizeWith: function canRecognizeWith(a) {\n      return !!this.simultaneous[a.id];\n    },\n    emit: function emit(a) {\n      function d(d) {\n        b.manager.emit(b.options.event + (d ? Zb(c) : \"\"), a);\n      }\n\n      var b = this,\n          c = this.state;\n      Ub > c && d(!0), d(), c >= Ub && d(!0);\n    },\n    tryEmit: function tryEmit(a) {\n      return this.canEmit() ? this.emit(a) : (this.state = Xb, void 0);\n    },\n    canEmit: function canEmit() {\n      for (var a = 0; a < this.requireFail.length;) {\n        if (!(this.requireFail[a].state & (Xb | Rb))) return !1;\n        a++;\n      }\n\n      return !0;\n    },\n    recognize: function recognize(a) {\n      var b = n({}, a);\n      return r(this.options.enable, [this, b]) ? (this.state & (Vb | Wb | Xb) && (this.state = Rb), this.state = this.process(b), this.state & (Sb | Tb | Ub | Wb) && this.tryEmit(b), void 0) : (this.reset(), this.state = Xb, void 0);\n    },\n    process: function process() {},\n    getTouchAction: function getTouchAction() {},\n    reset: function reset() {}\n  }, p(ac, Yb, {\n    defaults: {\n      pointers: 1\n    },\n    attrTest: function attrTest(a) {\n      var b = this.options.pointers;\n      return 0 === b || a.pointers.length === b;\n    },\n    process: function process(a) {\n      var b = this.state,\n          c = a.eventType,\n          d = b & (Sb | Tb),\n          e = this.attrTest(a);\n      return d && (c & R || !e) ? b | Wb : d || e ? c & Q ? b | Ub : b & Sb ? b | Tb : Sb : Xb;\n    }\n  }), p(bc, ac, {\n    defaults: {\n      event: \"pan\",\n      threshold: 10,\n      pointers: 1,\n      direction: Z\n    },\n    getTouchAction: function getTouchAction() {\n      var a = this.options.direction,\n          b = [];\n      return a & X && b.push(Ob), a & Y && b.push(Nb), b;\n    },\n    directionTest: function directionTest(a) {\n      var b = this.options,\n          c = !0,\n          d = a.distance,\n          e = a.direction,\n          f = a.deltaX,\n          g = a.deltaY;\n      return e & b.direction || (b.direction & X ? (e = 0 === f ? S : 0 > f ? T : U, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? S : 0 > g ? V : W, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;\n    },\n    attrTest: function attrTest(a) {\n      return ac.prototype.attrTest.call(this, a) && (this.state & Sb || !(this.state & Sb) && this.directionTest(a));\n    },\n    emit: function emit(a) {\n      this.pX = a.deltaX, this.pY = a.deltaY;\n      var b = $b(a.direction);\n      b && this.manager.emit(this.options.event + b, a), this._super.emit.call(this, a);\n    }\n  }), p(cc, ac, {\n    defaults: {\n      event: \"pinch\",\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [Mb];\n    },\n    attrTest: function attrTest(a) {\n      return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & Sb);\n    },\n    emit: function emit(a) {\n      if (this._super.emit.call(this, a), 1 !== a.scale) {\n        var b = a.scale < 1 ? \"in\" : \"out\";\n        this.manager.emit(this.options.event + b, a);\n      }\n    }\n  }), p(dc, Yb, {\n    defaults: {\n      event: \"press\",\n      pointers: 1,\n      time: 500,\n      threshold: 5\n    },\n    getTouchAction: function getTouchAction() {\n      return [Kb];\n    },\n    process: function process(a) {\n      var b = this.options,\n          c = a.pointers.length === b.pointers,\n          d = a.distance < b.threshold,\n          e = a.deltaTime > b.time;\n      if (this._input = a, !d || !c || a.eventType & (Q | R) && !e) this.reset();else if (a.eventType & O) this.reset(), this._timer = k(function () {\n        this.state = Vb, this.tryEmit();\n      }, b.time, this);else if (a.eventType & Q) return Vb;\n      return Xb;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit(a) {\n      this.state === Vb && (a && a.eventType & Q ? this.manager.emit(this.options.event + \"up\", a) : (this._input.timeStamp = j(), this.manager.emit(this.options.event, this._input)));\n    }\n  }), p(ec, ac, {\n    defaults: {\n      event: \"rotate\",\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function getTouchAction() {\n      return [Mb];\n    },\n    attrTest: function attrTest(a) {\n      return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & Sb);\n    }\n  }), p(fc, ac, {\n    defaults: {\n      event: \"swipe\",\n      threshold: 10,\n      velocity: .65,\n      direction: X | Y,\n      pointers: 1\n    },\n    getTouchAction: function getTouchAction() {\n      return bc.prototype.getTouchAction.call(this);\n    },\n    attrTest: function attrTest(a) {\n      var c,\n          b = this.options.direction;\n      return b & (X | Y) ? c = a.velocity : b & X ? c = a.velocityX : b & Y && (c = a.velocityY), this._super.attrTest.call(this, a) && b & a.direction && a.distance > this.options.threshold && i(c) > this.options.velocity && a.eventType & Q;\n    },\n    emit: function emit(a) {\n      var b = $b(a.direction);\n      b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);\n    }\n  }), p(gc, Yb, {\n    defaults: {\n      event: \"tap\",\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      time: 250,\n      threshold: 2,\n      posThreshold: 10\n    },\n    getTouchAction: function getTouchAction() {\n      return [Lb];\n    },\n    process: function process(a) {\n      var b = this.options,\n          c = a.pointers.length === b.pointers,\n          d = a.distance < b.threshold,\n          e = a.deltaTime < b.time;\n      if (this.reset(), a.eventType & O && 0 === this.count) return this.failTimeout();\n\n      if (d && e && c) {\n        if (a.eventType != Q) return this.failTimeout();\n        var f = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,\n            g = !this.pCenter || kb(this.pCenter, a.center) < b.posThreshold;\n        this.pTime = a.timeStamp, this.pCenter = a.center, g && f ? this.count += 1 : this.count = 1, this._input = a;\n        var h = this.count % b.taps;\n        if (0 === h) return this.hasRequireFailures() ? (this._timer = k(function () {\n          this.state = Vb, this.tryEmit();\n        }, b.interval, this), Sb) : Vb;\n      }\n\n      return Xb;\n    },\n    failTimeout: function failTimeout() {\n      return this._timer = k(function () {\n        this.state = Xb;\n      }, this.options.interval, this), Xb;\n    },\n    reset: function reset() {\n      clearTimeout(this._timer);\n    },\n    emit: function emit() {\n      this.state == Vb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));\n    }\n  }), hc.VERSION = \"2.0.4\", hc.defaults = {\n    domEvents: !1,\n    touchAction: Jb,\n    enable: !0,\n    inputTarget: null,\n    inputClass: null,\n    preset: [[ec, {\n      enable: !1\n    }], [cc, {\n      enable: !1\n    }, [\"rotate\"]], [fc, {\n      direction: X\n    }], [bc, {\n      direction: X\n    }, [\"swipe\"]], [gc], [gc, {\n      event: \"doubletap\",\n      taps: 2\n    }, [\"tap\"]], [dc]],\n    cssProps: {\n      userSelect: \"default\",\n      touchSelect: \"none\",\n      touchCallout: \"none\",\n      contentZooming: \"none\",\n      userDrag: \"none\",\n      tapHighlightColor: \"rgba(0,0,0,0)\"\n    }\n  };\n  var ic = 1,\n      jc = 2;\n  kc.prototype = {\n    set: function set(a) {\n      return n(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this;\n    },\n    stop: function stop(a) {\n      this.session.stopped = a ? jc : ic;\n    },\n    recognize: function recognize(a) {\n      var b = this.session;\n\n      if (!b.stopped) {\n        this.touchAction.preventDefaults(a);\n        var c,\n            d = this.recognizers,\n            e = b.curRecognizer;\n        (!e || e && e.state & Vb) && (e = b.curRecognizer = null);\n\n        for (var f = 0; f < d.length;) {\n          c = d[f], b.stopped === jc || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (Sb | Tb | Ub) && (e = b.curRecognizer = c), f++;\n        }\n      }\n    },\n    get: function get(a) {\n      if (a instanceof Yb) return a;\n\n      for (var b = this.recognizers, c = 0; c < b.length; c++) {\n        if (b[c].options.event == a) return b[c];\n      }\n\n      return null;\n    },\n    add: function add(a) {\n      if (l(a, \"add\", this)) return this;\n      var b = this.get(a.options.event);\n      return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a;\n    },\n    remove: function remove(a) {\n      if (l(a, \"remove\", this)) return this;\n      var b = this.recognizers;\n      return a = this.get(a), b.splice(y(b, a), 1), this.touchAction.update(), this;\n    },\n    on: function on(a, b) {\n      var c = this.handlers;\n      return m(x(a), function (a) {\n        c[a] = c[a] || [], c[a].push(b);\n      }), this;\n    },\n    off: function off(a, b) {\n      var c = this.handlers;\n      return m(x(a), function (a) {\n        b ? c[a].splice(y(c[a], b), 1) : delete c[a];\n      }), this;\n    },\n    emit: function emit(a, b) {\n      this.options.domEvents && mc(a, b);\n      var c = this.handlers[a] && this.handlers[a].slice();\n\n      if (c && c.length) {\n        b.type = a, b.preventDefault = function () {\n          b.srcEvent.preventDefault();\n        };\n\n        for (var d = 0; d < c.length;) {\n          c[d](b), d++;\n        }\n      }\n    },\n    destroy: function destroy() {\n      this.element && lc(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;\n    }\n  }, n(hc, {\n    INPUT_START: O,\n    INPUT_MOVE: P,\n    INPUT_END: Q,\n    INPUT_CANCEL: R,\n    STATE_POSSIBLE: Rb,\n    STATE_BEGAN: Sb,\n    STATE_CHANGED: Tb,\n    STATE_ENDED: Ub,\n    STATE_RECOGNIZED: Vb,\n    STATE_CANCELLED: Wb,\n    STATE_FAILED: Xb,\n    DIRECTION_NONE: S,\n    DIRECTION_LEFT: T,\n    DIRECTION_RIGHT: U,\n    DIRECTION_UP: V,\n    DIRECTION_DOWN: W,\n    DIRECTION_HORIZONTAL: X,\n    DIRECTION_VERTICAL: Y,\n    DIRECTION_ALL: Z,\n    Manager: kc,\n    Input: ab,\n    TouchAction: Pb,\n    TouchInput: Eb,\n    MouseInput: rb,\n    PointerEventInput: wb,\n    TouchMouseInput: Gb,\n    SingleTouchInput: Ab,\n    Recognizer: Yb,\n    AttrRecognizer: ac,\n    Tap: gc,\n    Pan: bc,\n    Swipe: fc,\n    Pinch: cc,\n    Rotate: ec,\n    Press: dc,\n    on: t,\n    off: u,\n    each: m,\n    merge: o,\n    extend: n,\n    inherit: p,\n    bindFn: q,\n    prefixed: B\n  }), typeof define == g && define.amd ? define(function () {\n    return hc;\n  }) : \"undefined\" != typeof module && module.exports ? module.exports = hc : a[c] = hc;\n}(window, document, \"Hammer\");\n;\n\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery', 'hammerjs'], factory);\n  } else if (typeof exports === 'object') {\n    factory(require('jquery'), require('hammerjs'));\n  } else {\n    factory(jQuery, Hammer);\n  }\n})(function ($, Hammer) {\n  function hammerify(el, options) {\n    var $el = $(el);\n\n    if (!$el.data(\"hammer\")) {\n      $el.data(\"hammer\", new Hammer($el[0], options));\n    }\n  }\n\n  $.fn.hammer = function (options) {\n    return this.each(function () {\n      hammerify(this, options);\n    });\n  }; // extend the emit method to also trigger jQuery events\n\n\n  Hammer.Manager.prototype.emit = function (originalEmit) {\n    return function (type, data) {\n      originalEmit.call(this, type, data);\n      $(this.element).trigger({\n        type: type,\n        gesture: data\n      });\n    };\n  }(Hammer.Manager.prototype.emit);\n});\n\n; // Required for Meteor package, the use of window prevents export by Meteor\n\n(function (window) {\n  if (window.Package) {\n    Materialize = {};\n  } else {\n    window.Materialize = {};\n  }\n})(window);\n\nif (typeof exports !== 'undefined' && !exports.nodeType) {\n  if (typeof module !== 'undefined' && !module.nodeType && module.exports) {\n    exports = module.exports = Materialize;\n  }\n\n  exports.default = Materialize;\n}\n/*\r\n * raf.js\r\n * https://github.com/ngryman/raf.js\r\n *\r\n * original requestAnimationFrame polyfill by Erik MÃ¶ller\r\n * inspired from paul_irish gist and post\r\n *\r\n * Copyright (c) 2013 ngryman\r\n * Licensed under the MIT license.\r\n */\n\n\n(function (window) {\n  var lastTime = 0,\n      vendors = ['webkit', 'moz'],\n      requestAnimationFrame = window.requestAnimationFrame,\n      cancelAnimationFrame = window.cancelAnimationFrame,\n      i = vendors.length; // try to un-prefix existing raf\n\n  while (--i >= 0 && !requestAnimationFrame) {\n    requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];\n    cancelAnimationFrame = window[vendors[i] + 'CancelRequestAnimationFrame'];\n  } // polyfill with setTimeout fallback\n  // heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945\n\n\n  if (!requestAnimationFrame || !cancelAnimationFrame) {\n    requestAnimationFrame = function requestAnimationFrame(callback) {\n      var now = +Date.now(),\n          nextTime = Math.max(lastTime + 16, now);\n      return setTimeout(function () {\n        callback(lastTime = nextTime);\n      }, nextTime - now);\n    };\n\n    cancelAnimationFrame = clearTimeout;\n  } // export to window\n\n\n  window.requestAnimationFrame = requestAnimationFrame;\n  window.cancelAnimationFrame = cancelAnimationFrame;\n})(window);\n/**\r\n * Generate approximated selector string for a jQuery object\r\n * @param {jQuery} obj  jQuery object to be parsed\r\n * @returns {string}\r\n */\n\n\nMaterialize.objectSelectorString = function (obj) {\n  var tagStr = obj.prop('tagName') || '';\n  var idStr = obj.attr('id') || '';\n  var classStr = obj.attr('class') || '';\n  return (tagStr + idStr + classStr).replace(/\\s/g, '');\n}; // Unique Random ID\n\n\nMaterialize.guid = function () {\n  function s4() {\n    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n  }\n\n  return function () {\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n  };\n}();\n/**\r\n * Escapes hash from special characters\r\n * @param {string} hash  String returned from this.hash\r\n * @returns {string}\r\n */\n\n\nMaterialize.escapeHash = function (hash) {\n  return hash.replace(/(:|\\.|\\[|\\]|,|=)/g, \"\\\\$1\");\n};\n\nMaterialize.elementOrParentIsFixed = function (element) {\n  var $element = $(element);\n  var $checkElements = $element.add($element.parents());\n  var isFixed = false;\n  $checkElements.each(function () {\n    if ($(this).css(\"position\") === \"fixed\") {\n      isFixed = true;\n      return false;\n    }\n  });\n  return isFixed;\n};\n/**\r\n * Get time in ms\r\n * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\r\n * @type {function}\r\n * @return {number}\r\n */\n\n\nvar getTime = Date.now || function () {\n  return new Date().getTime();\n};\n/**\r\n * Returns a function, that, when invoked, will only be triggered at most once\r\n * during a given window of time. Normally, the throttled function will run\r\n * as much as it can, without ever going more than once per `wait` duration;\r\n * but if you'd like to disable the execution on the leading edge, pass\r\n * `{leading: false}`. To disable execution on the trailing edge, ditto.\r\n * @license https://raw.github.com/jashkenas/underscore/master/LICENSE\r\n * @param {function} func\r\n * @param {number} wait\r\n * @param {Object=} options\r\n * @returns {Function}\r\n */\n\n\nMaterialize.throttle = function (func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  options || (options = {});\n\n  var later = function later() {\n    previous = options.leading === false ? 0 : getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    context = args = null;\n  };\n\n  return function () {\n    var now = getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(context, args);\n      context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}; // Velocity has conflicts when loaded with jQuery, this will check for it\n// First, check if in noConflict mode\n\n\nvar Vel;\n\nif (jQuery) {\n  Vel = jQuery.Velocity;\n} else if ($) {\n  Vel = $.Velocity;\n} else {\n  Vel = Velocity;\n}\n\nif (Vel) {\n  Materialize.Vel = Vel;\n} else {\n  Materialize.Vel = Velocity;\n}\n\n;\n\n(function ($) {\n  $.fn.collapsible = function (options, methodParam) {\n    var defaults = {\n      accordion: undefined,\n      onOpen: undefined,\n      onClose: undefined\n    };\n    var methodName = options;\n    options = $.extend(defaults, options);\n    return this.each(function () {\n      var $this = $(this);\n      var $panel_headers = $(this).find('> li > .collapsible-header');\n      var collapsible_type = $this.data(\"collapsible\");\n      /****************\r\n      Helper Functions\r\n      ****************/\n      // Accordion Open\n\n      function accordionOpen(object) {\n        $panel_headers = $this.find('> li > .collapsible-header');\n\n        if (object.hasClass('active')) {\n          object.parent().addClass('active');\n        } else {\n          object.parent().removeClass('active');\n        }\n\n        if (object.parent().hasClass('active')) {\n          object.siblings('.collapsible-body').stop(true, false).slideDown({\n            duration: 350,\n            easing: \"easeOutQuart\",\n            queue: false,\n            complete: function complete() {\n              $(this).css('height', '');\n            }\n          });\n        } else {\n          object.siblings('.collapsible-body').stop(true, false).slideUp({\n            duration: 350,\n            easing: \"easeOutQuart\",\n            queue: false,\n            complete: function complete() {\n              $(this).css('height', '');\n            }\n          });\n        }\n\n        $panel_headers.not(object).removeClass('active').parent().removeClass('active'); // Close previously open accordion elements.\n\n        $panel_headers.not(object).parent().children('.collapsible-body').stop(true, false).each(function () {\n          if ($(this).is(':visible')) {\n            $(this).slideUp({\n              duration: 350,\n              easing: \"easeOutQuart\",\n              queue: false,\n              complete: function complete() {\n                $(this).css('height', '');\n                execCallbacks($(this).siblings('.collapsible-header'));\n              }\n            });\n          }\n        });\n      } // Expandable Open\n\n\n      function expandableOpen(object) {\n        if (object.hasClass('active')) {\n          object.parent().addClass('active');\n        } else {\n          object.parent().removeClass('active');\n        }\n\n        if (object.parent().hasClass('active')) {\n          object.siblings('.collapsible-body').stop(true, false).slideDown({\n            duration: 350,\n            easing: \"easeOutQuart\",\n            queue: false,\n            complete: function complete() {\n              $(this).css('height', '');\n            }\n          });\n        } else {\n          object.siblings('.collapsible-body').stop(true, false).slideUp({\n            duration: 350,\n            easing: \"easeOutQuart\",\n            queue: false,\n            complete: function complete() {\n              $(this).css('height', '');\n            }\n          });\n        }\n      } // Open collapsible. object: .collapsible-header\n\n\n      function collapsibleOpen(object, noToggle) {\n        if (!noToggle) {\n          object.toggleClass('active');\n        }\n\n        if (options.accordion || collapsible_type === \"accordion\" || collapsible_type === undefined) {\n          // Handle Accordion\n          accordionOpen(object);\n        } else {\n          // Handle Expandables\n          expandableOpen(object);\n        }\n\n        execCallbacks(object);\n      } // Handle callbacks\n\n\n      function execCallbacks(object) {\n        if (object.hasClass('active')) {\n          if (typeof options.onOpen === \"function\") {\n            options.onOpen.call(this, object.parent());\n          }\n        } else {\n          if (typeof options.onClose === \"function\") {\n            options.onClose.call(this, object.parent());\n          }\n        }\n      }\n      /**\r\n       * Check if object is children of panel header\r\n       * @param  {Object}  object Jquery object\r\n       * @return {Boolean} true if it is children\r\n       */\n\n\n      function isChildrenOfPanelHeader(object) {\n        var panelHeader = getPanelHeader(object);\n        return panelHeader.length > 0;\n      }\n      /**\r\n       * Get panel header from a children element\r\n       * @param  {Object} object Jquery object\r\n       * @return {Object} panel header object\r\n       */\n\n\n      function getPanelHeader(object) {\n        return object.closest('li > .collapsible-header');\n      } // Turn off any existing event handlers\n\n\n      function removeEventHandlers() {\n        $this.off('click.collapse', '> li > .collapsible-header');\n      }\n      /*****  End Helper Functions  *****/\n      // Methods\n\n\n      if (methodName === 'destroy') {\n        removeEventHandlers();\n        return;\n      } else if (methodParam >= 0 && methodParam < $panel_headers.length) {\n        var $curr_header = $panel_headers.eq(methodParam);\n\n        if ($curr_header.length && (methodName === 'open' || methodName === 'close' && $curr_header.hasClass('active'))) {\n          collapsibleOpen($curr_header);\n        }\n\n        return;\n      }\n\n      removeEventHandlers(); // Add click handler to only direct collapsible header children\n\n      $this.on('click.collapse', '> li > .collapsible-header', function (e) {\n        var element = $(e.target);\n\n        if (isChildrenOfPanelHeader(element)) {\n          element = getPanelHeader(element);\n        }\n\n        collapsibleOpen(element);\n      }); // Open first active\n\n      if (options.accordion || collapsible_type === \"accordion\" || collapsible_type === undefined) {\n        // Handle Accordion\n        collapsibleOpen($panel_headers.filter('.active').first(), true);\n      } else {\n        // Handle Expandables\n        $panel_headers.filter('.active').each(function () {\n          collapsibleOpen($(this), true);\n        });\n      }\n    });\n  };\n\n  $(document).ready(function () {\n    $('.collapsible').collapsible();\n  });\n})(jQuery);\n\n;\n\n(function ($) {\n  // Add posibility to scroll to selected option\n  // usefull for select for example\n  $.fn.scrollTo = function (elem) {\n    $(this).scrollTop($(this).scrollTop() - $(this).offset().top + $(elem).offset().top);\n    return this;\n  };\n\n  $.fn.dropdown = function (options) {\n    var defaults = {\n      inDuration: 300,\n      outDuration: 225,\n      constrainWidth: true,\n      // Constrains width of dropdown to the activator\n      hover: false,\n      gutter: 0,\n      // Spacing from edge\n      belowOrigin: false,\n      alignment: 'left',\n      stopPropagation: false\n    }; // Open dropdown.\n\n    if (options === \"open\") {\n      this.each(function () {\n        $(this).trigger('open');\n      });\n      return false;\n    } // Close dropdown.\n\n\n    if (options === \"close\") {\n      this.each(function () {\n        $(this).trigger('close');\n      });\n      return false;\n    }\n\n    this.each(function () {\n      var origin = $(this);\n      var curr_options = $.extend({}, defaults, options);\n      var isFocused = false; // Dropdown menu\n\n      var activates = $(\"#\" + origin.attr('data-activates'));\n\n      function updateOptions() {\n        if (origin.data('induration') !== undefined) curr_options.inDuration = origin.data('induration');\n        if (origin.data('outduration') !== undefined) curr_options.outDuration = origin.data('outduration');\n        if (origin.data('constrainwidth') !== undefined) curr_options.constrainWidth = origin.data('constrainwidth');\n        if (origin.data('hover') !== undefined) curr_options.hover = origin.data('hover');\n        if (origin.data('gutter') !== undefined) curr_options.gutter = origin.data('gutter');\n        if (origin.data('beloworigin') !== undefined) curr_options.belowOrigin = origin.data('beloworigin');\n        if (origin.data('alignment') !== undefined) curr_options.alignment = origin.data('alignment');\n        if (origin.data('stoppropagation') !== undefined) curr_options.stopPropagation = origin.data('stoppropagation');\n      }\n\n      updateOptions(); // Attach dropdown to its activator\n\n      origin.after(activates);\n      /*\r\n        Helper function to position and resize dropdown.\r\n        Used in hover and click handler.\r\n      */\n\n      function placeDropdown(eventType) {\n        // Check for simultaneous focus and click events.\n        if (eventType === 'focus') {\n          isFocused = true;\n        } // Check html data attributes\n\n\n        updateOptions(); // Set Dropdown state\n\n        activates.addClass('active');\n        origin.addClass('active');\n        var originWidth = origin[0].getBoundingClientRect().width; // Constrain width\n\n        if (curr_options.constrainWidth === true) {\n          activates.css('width', originWidth);\n        } else {\n          activates.css('white-space', 'nowrap');\n        } // Offscreen detection\n\n\n        var windowHeight = window.innerHeight;\n        var originHeight = origin.innerHeight();\n        var offsetLeft = origin.offset().left;\n        var offsetTop = origin.offset().top - $(window).scrollTop();\n        var currAlignment = curr_options.alignment;\n        var gutterSpacing = 0;\n        var leftPosition = 0; // Below Origin\n\n        var verticalOffset = 0;\n\n        if (curr_options.belowOrigin === true) {\n          verticalOffset = originHeight;\n        } // Check for scrolling positioned container.\n\n\n        var scrollYOffset = 0;\n        var scrollXOffset = 0;\n        var wrapper = origin.parent();\n\n        if (!wrapper.is('body')) {\n          if (wrapper[0].scrollHeight > wrapper[0].clientHeight) {\n            scrollYOffset = wrapper[0].scrollTop;\n          }\n\n          if (wrapper[0].scrollWidth > wrapper[0].clientWidth) {\n            scrollXOffset = wrapper[0].scrollLeft;\n          }\n        }\n\n        if (offsetLeft + activates.innerWidth() > $(window).width()) {\n          // Dropdown goes past screen on right, force right alignment\n          currAlignment = 'right';\n        } else if (offsetLeft - activates.innerWidth() + origin.innerWidth() < 0) {\n          // Dropdown goes past screen on left, force left alignment\n          currAlignment = 'left';\n        } // Vertical bottom offscreen detection\n\n\n        if (offsetTop + activates.innerHeight() > windowHeight) {\n          // If going upwards still goes offscreen, just crop height of dropdown.\n          if (offsetTop + originHeight - activates.innerHeight() < 0) {\n            var adjustedHeight = windowHeight - offsetTop - verticalOffset;\n            activates.css('max-height', adjustedHeight);\n          } else {\n            // Flow upwards.\n            if (!verticalOffset) {\n              verticalOffset += originHeight;\n            }\n\n            verticalOffset -= activates.innerHeight();\n          }\n        } // Handle edge alignment\n\n\n        if (currAlignment === 'left') {\n          gutterSpacing = curr_options.gutter;\n          leftPosition = origin.position().left + gutterSpacing;\n        } else if (currAlignment === 'right') {\n          // Material icons fix\n          activates.stop(true, true).css({\n            opacity: 0,\n            left: 0\n          });\n          var offsetRight = origin.position().left + originWidth - activates.width();\n          gutterSpacing = -curr_options.gutter;\n          leftPosition = offsetRight + gutterSpacing;\n        } // Position dropdown\n\n\n        activates.css({\n          position: 'absolute',\n          top: origin.position().top + verticalOffset + scrollYOffset,\n          left: leftPosition + scrollXOffset\n        }); // Show dropdown\n\n        activates.slideDown({\n          queue: false,\n          duration: curr_options.inDuration,\n          easing: 'easeOutCubic',\n          complete: function complete() {\n            $(this).css('height', '');\n          }\n        }).animate({\n          opacity: 1\n        }, {\n          queue: false,\n          duration: curr_options.inDuration,\n          easing: 'easeOutSine'\n        }); // Add click close handler to document\n\n        setTimeout(function () {\n          $(document).on('click.' + activates.attr('id'), function (e) {\n            hideDropdown();\n            $(document).off('click.' + activates.attr('id'));\n          });\n        }, 0);\n      }\n\n      function hideDropdown() {\n        // Check for simultaneous focus and click events.\n        isFocused = false;\n        activates.fadeOut(curr_options.outDuration);\n        activates.removeClass('active');\n        origin.removeClass('active');\n        $(document).off('click.' + activates.attr('id'));\n        setTimeout(function () {\n          activates.css('max-height', '');\n        }, curr_options.outDuration);\n      } // Hover\n\n\n      if (curr_options.hover) {\n        var open = false;\n        origin.off('click.' + origin.attr('id')); // Hover handler to show dropdown\n\n        origin.on('mouseenter', function (e) {\n          // Mouse over\n          if (open === false) {\n            placeDropdown();\n            open = true;\n          }\n        });\n        origin.on('mouseleave', function (e) {\n          // If hover on origin then to something other than dropdown content, then close\n          var toEl = e.toElement || e.relatedTarget; // added browser compatibility for target element\n\n          if (!$(toEl).closest('.dropdown-content').is(activates)) {\n            activates.stop(true, true);\n            hideDropdown();\n            open = false;\n          }\n        });\n        activates.on('mouseleave', function (e) {\n          // Mouse out\n          var toEl = e.toElement || e.relatedTarget;\n\n          if (!$(toEl).closest('.dropdown-button').is(origin)) {\n            activates.stop(true, true);\n            hideDropdown();\n            open = false;\n          }\n        }); // Click\n      } else {\n        // Click handler to show dropdown\n        origin.off('click.' + origin.attr('id'));\n        origin.on('click.' + origin.attr('id'), function (e) {\n          if (!isFocused) {\n            if (origin[0] == e.currentTarget && !origin.hasClass('active') && $(e.target).closest('.dropdown-content').length === 0) {\n              e.preventDefault(); // Prevents button click from moving window\n\n              if (curr_options.stopPropagation) {\n                e.stopPropagation();\n              }\n\n              placeDropdown('click');\n            } // If origin is clicked and menu is open, close menu\n            else if (origin.hasClass('active')) {\n                hideDropdown();\n                $(document).off('click.' + activates.attr('id'));\n              }\n          }\n        });\n      } // End else\n      // Listen to open and close event - useful for select component\n\n\n      origin.on('open', function (e, eventType) {\n        placeDropdown(eventType);\n      });\n      origin.on('close', hideDropdown);\n    });\n  }; // End dropdown plugin\n\n\n  $(document).ready(function () {\n    $('.dropdown-button').dropdown();\n  });\n})(jQuery);\n\n;\n\n(function ($, Vel) {\n  'use strict';\n\n  var _defaults = {\n    opacity: 0.5,\n    inDuration: 250,\n    outDuration: 250,\n    ready: undefined,\n    complete: undefined,\n    dismissible: true,\n    startingTop: '4%',\n    endingTop: '10%'\n  };\n  /**\r\n   * @class\r\n   *\r\n   */\n\n  var Modal = function () {\n    /**\r\n     * Construct Modal instance and set up overlay\r\n     * @constructor\r\n     * @param {jQuery} $el\r\n     * @param {Object} options\r\n     */\n    function Modal($el, options) {\n      _classCallCheck(this, Modal); // If exists, destroy and reinitialize\n\n\n      if (!!$el[0].M_Modal) {\n        $el[0].M_Modal.destroy();\n      }\n      /**\r\n       * The jQuery element\r\n       * @type {jQuery}\r\n       */\n\n\n      this.$el = $el;\n      /**\r\n       * Options for the modal\r\n       * @member Modal#options\r\n       * @prop {Number} [opacity=0.5] - Opacity of the modal overlay\r\n       * @prop {Number} [inDuration=250] - Length in ms of enter transition\r\n       * @prop {Number} [outDuration=250] - Length in ms of exit transition\r\n       * @prop {Function} ready - Callback function called when modal is finished entering\r\n       * @prop {Function} complete - Callback function called when modal is finished exiting\r\n       * @prop {Boolean} [dismissible=true] - Allow modal to be dismissed by keyboard or overlay click\r\n       * @prop {String} [startingTop='4%'] - startingTop\r\n       * @prop {String} [endingTop='10%'] - endingTop\r\n       */\n\n      this.options = $.extend({}, Modal.defaults, options);\n      /**\r\n       * Describes open/close state of modal\r\n       * @type {Boolean}\r\n       */\n\n      this.isOpen = false;\n      this.$el[0].M_Modal = this;\n      this.id = $el.attr('id');\n      this.openingTrigger = undefined;\n      this.$overlay = $('<div class=\"modal-overlay\"></div>');\n      Modal._increment++;\n      Modal._count++;\n      this.$overlay[0].style.zIndex = 1000 + Modal._increment * 2;\n      this.$el[0].style.zIndex = 1000 + Modal._increment * 2 + 1;\n      this.setupEventHandlers();\n    }\n\n    _createClass(Modal, [{\n      key: 'getInstance',\n\n      /**\r\n       * Get Instance\r\n       */\n      value: function getInstance() {\n        return this;\n      }\n      /**\r\n       * Teardown component\r\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this.removeEventHandlers();\n        this.$el[0].removeAttribute('style');\n\n        if (!!this.$overlay[0].parentNode) {\n          this.$overlay[0].parentNode.removeChild(this.$overlay[0]);\n        }\n\n        this.$el[0].M_Modal = undefined;\n        Modal._count--;\n      }\n      /**\r\n       * Setup Event Handlers\r\n       */\n\n    }, {\n      key: 'setupEventHandlers',\n      value: function setupEventHandlers() {\n        this.handleOverlayClickBound = this.handleOverlayClick.bind(this);\n        this.handleModalCloseClickBound = this.handleModalCloseClick.bind(this);\n\n        if (Modal._count === 1) {\n          document.body.addEventListener('click', this.handleTriggerClick);\n        }\n\n        this.$overlay[0].addEventListener('click', this.handleOverlayClickBound);\n        this.$el[0].addEventListener('click', this.handleModalCloseClickBound);\n      }\n      /**\r\n       * Remove Event Handlers\r\n       */\n\n    }, {\n      key: 'removeEventHandlers',\n      value: function removeEventHandlers() {\n        if (Modal._count === 0) {\n          document.body.removeEventListener('click', this.handleTriggerClick);\n        }\n\n        this.$overlay[0].removeEventListener('click', this.handleOverlayClickBound);\n        this.$el[0].removeEventListener('click', this.handleModalCloseClickBound);\n      }\n      /**\r\n       * Handle Trigger Click\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: 'handleTriggerClick',\n      value: function handleTriggerClick(e) {\n        var $trigger = $(e.target).closest('.modal-trigger');\n\n        if (e.target && $trigger.length) {\n          var modalId = $trigger[0].getAttribute('href');\n\n          if (modalId) {\n            modalId = modalId.slice(1);\n          } else {\n            modalId = $trigger[0].getAttribute('data-target');\n          }\n\n          var modalInstance = document.getElementById(modalId).M_Modal;\n\n          if (modalInstance) {\n            modalInstance.open($trigger);\n          }\n\n          e.preventDefault();\n        }\n      }\n      /**\r\n       * Handle Overlay Click\r\n       */\n\n    }, {\n      key: 'handleOverlayClick',\n      value: function handleOverlayClick() {\n        if (this.options.dismissible) {\n          this.close();\n        }\n      }\n      /**\r\n       * Handle Modal Close Click\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: 'handleModalCloseClick',\n      value: function handleModalCloseClick(e) {\n        var $closeTrigger = $(e.target).closest('.modal-close');\n\n        if (e.target && $closeTrigger.length) {\n          this.close();\n        }\n      }\n      /**\r\n       * Handle Keydown\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: 'handleKeydown',\n      value: function handleKeydown(e) {\n        // ESC key\n        if (e.keyCode === 27 && this.options.dismissible) {\n          this.close();\n        }\n      }\n      /**\r\n       * Animate in modal\r\n       */\n\n    }, {\n      key: 'animateIn',\n      value: function animateIn() {\n        var _this = this; // Set initial styles\n\n\n        $.extend(this.$el[0].style, {\n          display: 'block',\n          opacity: 0\n        });\n        $.extend(this.$overlay[0].style, {\n          display: 'block',\n          opacity: 0\n        }); // Animate overlay\n\n        Vel(this.$overlay[0], {\n          opacity: this.options.opacity\n        }, {\n          duration: this.options.inDuration,\n          queue: false,\n          ease: 'easeOutCubic'\n        }); // Define modal animation options\n\n        var enterVelocityOptions = {\n          duration: this.options.inDuration,\n          queue: false,\n          ease: 'easeOutCubic',\n          // Handle modal ready callback\n          complete: function complete() {\n            if (typeof _this.options.ready === 'function') {\n              _this.options.ready.call(_this, _this.$el, _this.openingTrigger);\n            }\n          }\n        }; // Bottom sheet animation\n\n        if (this.$el[0].classList.contains('bottom-sheet')) {\n          Vel(this.$el[0], {\n            bottom: 0,\n            opacity: 1\n          }, enterVelocityOptions); // Normal modal animation\n        } else {\n          Vel.hook(this.$el[0], 'scaleX', 0.7);\n          this.$el[0].style.top = this.options.startingTop;\n          Vel(this.$el[0], {\n            top: this.options.endingTop,\n            opacity: 1,\n            scaleX: 1\n          }, enterVelocityOptions);\n        }\n      }\n      /**\r\n       * Animate out modal\r\n       */\n\n    }, {\n      key: 'animateOut',\n      value: function animateOut() {\n        var _this2 = this; // Animate overlay\n\n\n        Vel(this.$overlay[0], {\n          opacity: 0\n        }, {\n          duration: this.options.outDuration,\n          queue: false,\n          ease: 'easeOutQuart'\n        }); // Define modal animation options\n\n        var exitVelocityOptions = {\n          duration: this.options.outDuration,\n          queue: false,\n          ease: 'easeOutCubic',\n          // Handle modal ready callback\n          complete: function complete() {\n            _this2.$el[0].style.display = 'none'; // Call complete callback\n\n            if (typeof _this2.options.complete === 'function') {\n              _this2.options.complete.call(_this2, _this2.$el);\n            }\n\n            _this2.$overlay[0].parentNode.removeChild(_this2.$overlay[0]);\n          }\n        }; // Bottom sheet animation\n\n        if (this.$el[0].classList.contains('bottom-sheet')) {\n          Vel(this.$el[0], {\n            bottom: '-100%',\n            opacity: 0\n          }, exitVelocityOptions); // Normal modal animation\n        } else {\n          Vel(this.$el[0], {\n            top: this.options.startingTop,\n            opacity: 0,\n            scaleX: 0.7\n          }, exitVelocityOptions);\n        }\n      }\n      /**\r\n       * Open Modal\r\n       * @param {jQuery} [$trigger]\r\n       */\n\n    }, {\n      key: 'open',\n      value: function open($trigger) {\n        if (this.isOpen) {\n          return;\n        }\n\n        this.isOpen = true;\n        var body = document.body;\n        body.style.overflow = 'hidden';\n        this.$el[0].classList.add('open');\n        body.appendChild(this.$overlay[0]); // Set opening trigger, undefined indicates modal was opened by javascript\n\n        this.openingTrigger = !!$trigger ? $trigger : undefined;\n\n        if (this.options.dismissible) {\n          this.handleKeydownBound = this.handleKeydown.bind(this);\n          document.addEventListener('keydown', this.handleKeydownBound);\n        }\n\n        this.animateIn();\n        return this;\n      }\n      /**\r\n       * Close Modal\r\n       */\n\n    }, {\n      key: 'close',\n      value: function close() {\n        if (!this.isOpen) {\n          return;\n        }\n\n        this.isOpen = false;\n        this.$el[0].classList.remove('open');\n        document.body.style.overflow = '';\n\n        if (this.options.dismissible) {\n          document.removeEventListener('keydown', this.handleKeydownBound);\n        }\n\n        this.animateOut();\n        return this;\n      }\n    }], [{\n      key: 'init',\n      value: function init($els, options) {\n        var arr = [];\n        $els.each(function () {\n          arr.push(new Modal($(this), options));\n        });\n        return arr;\n      }\n    }, {\n      key: 'defaults',\n      get: function get() {\n        return _defaults;\n      }\n    }]);\n\n    return Modal;\n  }();\n  /**\r\n   * @static\r\n   * @memberof Modal\r\n   */\n\n\n  Modal._increment = 0;\n  /**\r\n   * @static\r\n   * @memberof Modal\r\n   */\n\n  Modal._count = 0;\n  Materialize.Modal = Modal;\n\n  $.fn.modal = function (methodOrOptions) {\n    // Call plugin method if valid method name is passed in\n    if (Modal.prototype[methodOrOptions]) {\n      // Getter methods\n      if (methodOrOptions.slice(0, 3) === 'get') {\n        return this.first()[0].M_Modal[methodOrOptions](); // Void methods\n      } else {\n        return this.each(function () {\n          this.M_Modal[methodOrOptions]();\n        });\n      } // Initialize plugin if options or no argument is passed in\n\n    } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n      Modal.init(this, arguments[0]);\n      return this; // Return error if an unrecognized  method name is passed in\n    } else {\n      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.modal');\n    }\n  };\n})(jQuery, Materialize.Vel);\n\n;\n\n(function ($) {\n  $.fn.materialbox = function () {\n    return this.each(function () {\n      if ($(this).hasClass('initialized')) {\n        return;\n      }\n\n      $(this).addClass('initialized');\n      var overlayActive = false;\n      var doneAnimating = true;\n      var inDuration = 275;\n      var outDuration = 200;\n      var origin = $(this);\n      var placeholder = $('<div></div>').addClass('material-placeholder');\n      var originalWidth = 0;\n      var originalHeight = 0;\n      var ancestorsChanged;\n      var ancestor;\n      var originInlineStyles = origin.attr('style');\n      origin.wrap(placeholder); // Start click handler\n\n      origin.on('click', function () {\n        var placeholder = origin.parent('.material-placeholder');\n        var windowWidth = window.innerWidth;\n        var windowHeight = window.innerHeight;\n        var originalWidth = origin.width();\n        var originalHeight = origin.height(); // If already modal, return to original\n\n        if (doneAnimating === false) {\n          returnToOriginal();\n          return false;\n        } else if (overlayActive && doneAnimating === true) {\n          returnToOriginal();\n          return false;\n        } // Set states\n\n\n        doneAnimating = false;\n        origin.addClass('active');\n        overlayActive = true; // Set positioning for placeholder\n\n        placeholder.css({\n          width: placeholder[0].getBoundingClientRect().width,\n          height: placeholder[0].getBoundingClientRect().height,\n          position: 'relative',\n          top: 0,\n          left: 0\n        }); // Find ancestor with overflow: hidden; and remove it\n\n        ancestorsChanged = undefined;\n        ancestor = placeholder[0].parentNode;\n        var count = 0;\n\n        while (ancestor !== null && !$(ancestor).is(document)) {\n          var curr = $(ancestor);\n\n          if (curr.css('overflow') !== 'visible') {\n            curr.css('overflow', 'visible');\n\n            if (ancestorsChanged === undefined) {\n              ancestorsChanged = curr;\n            } else {\n              ancestorsChanged = ancestorsChanged.add(curr);\n            }\n          }\n\n          ancestor = ancestor.parentNode;\n        } // Set css on origin\n\n\n        origin.css({\n          position: 'absolute',\n          'z-index': 1000,\n          'will-change': 'left, top, width, height'\n        }).data('width', originalWidth).data('height', originalHeight); // Add overlay\n\n        var overlay = $('<div id=\"materialbox-overlay\"></div>').css({\n          opacity: 0\n        }).click(function () {\n          if (doneAnimating === true) returnToOriginal();\n        }); // Put before in origin image to preserve z-index layering.\n\n        origin.before(overlay); // Set dimensions if needed\n\n        var overlayOffset = overlay[0].getBoundingClientRect();\n        overlay.css({\n          width: windowWidth,\n          height: windowHeight,\n          left: -1 * overlayOffset.left,\n          top: -1 * overlayOffset.top\n        }); // Animate Overlay\n\n        overlay.velocity({\n          opacity: 1\n        }, {\n          duration: inDuration,\n          queue: false,\n          easing: 'easeOutQuad'\n        }); // Add and animate caption if it exists\n\n        if (origin.data('caption') !== \"\") {\n          var $photo_caption = $('<div class=\"materialbox-caption\"></div>');\n          $photo_caption.text(origin.data('caption'));\n          $('body').append($photo_caption);\n          $photo_caption.css({\n            \"display\": \"inline\"\n          });\n          $photo_caption.velocity({\n            opacity: 1\n          }, {\n            duration: inDuration,\n            queue: false,\n            easing: 'easeOutQuad'\n          });\n        } // Resize Image\n\n\n        var ratio = 0;\n        var widthPercent = originalWidth / windowWidth;\n        var heightPercent = originalHeight / windowHeight;\n        var newWidth = 0;\n        var newHeight = 0;\n\n        if (widthPercent > heightPercent) {\n          ratio = originalHeight / originalWidth;\n          newWidth = windowWidth * 0.9;\n          newHeight = windowWidth * 0.9 * ratio;\n        } else {\n          ratio = originalWidth / originalHeight;\n          newWidth = windowHeight * 0.9 * ratio;\n          newHeight = windowHeight * 0.9;\n        } // Animate image + set z-index\n\n\n        if (origin.hasClass('responsive-img')) {\n          origin.velocity({\n            'max-width': newWidth,\n            'width': originalWidth\n          }, {\n            duration: 0,\n            queue: false,\n            complete: function complete() {\n              origin.css({\n                left: 0,\n                top: 0\n              }).velocity({\n                height: newHeight,\n                width: newWidth,\n                left: $(document).scrollLeft() + windowWidth / 2 - origin.parent('.material-placeholder').offset().left - newWidth / 2,\n                top: $(document).scrollTop() + windowHeight / 2 - origin.parent('.material-placeholder').offset().top - newHeight / 2\n              }, {\n                duration: inDuration,\n                queue: false,\n                easing: 'easeOutQuad',\n                complete: function complete() {\n                  doneAnimating = true;\n                }\n              });\n            } // End Complete\n\n          }); // End Velocity\n        } else {\n          origin.css('left', 0).css('top', 0).velocity({\n            height: newHeight,\n            width: newWidth,\n            left: $(document).scrollLeft() + windowWidth / 2 - origin.parent('.material-placeholder').offset().left - newWidth / 2,\n            top: $(document).scrollTop() + windowHeight / 2 - origin.parent('.material-placeholder').offset().top - newHeight / 2\n          }, {\n            duration: inDuration,\n            queue: false,\n            easing: 'easeOutQuad',\n            complete: function complete() {\n              doneAnimating = true;\n            }\n          }); // End Velocity\n        } // Handle Exit triggers\n\n\n        $(window).on('scroll.materialbox', function () {\n          if (overlayActive) {\n            returnToOriginal();\n          }\n        });\n        $(window).on('resize.materialbox', function () {\n          if (overlayActive) {\n            returnToOriginal();\n          }\n        });\n        $(document).on('keyup.materialbox', function (e) {\n          // ESC key\n          if (e.keyCode === 27 && doneAnimating === true && overlayActive) {\n            returnToOriginal();\n          }\n        });\n      }); // End click handler\n      // This function returns the modaled image to the original spot\n\n      function returnToOriginal() {\n        doneAnimating = false;\n        var placeholder = origin.parent('.material-placeholder');\n        var windowWidth = window.innerWidth;\n        var windowHeight = window.innerHeight;\n        var originalWidth = origin.data('width');\n        var originalHeight = origin.data('height');\n        origin.velocity(\"stop\", true);\n        $('#materialbox-overlay').velocity(\"stop\", true);\n        $('.materialbox-caption').velocity(\"stop\", true); // disable exit handlers\n\n        $(window).off('scroll.materialbox');\n        $(document).off('keyup.materialbox');\n        $(window).off('resize.materialbox');\n        $('#materialbox-overlay').velocity({\n          opacity: 0\n        }, {\n          duration: outDuration,\n          // Delay prevents animation overlapping\n          queue: false,\n          easing: 'easeOutQuad',\n          complete: function complete() {\n            // Remove Overlay\n            overlayActive = false;\n            $(this).remove();\n          }\n        }); // Resize Image\n\n        origin.velocity({\n          width: originalWidth,\n          height: originalHeight,\n          left: 0,\n          top: 0\n        }, {\n          duration: outDuration,\n          queue: false,\n          easing: 'easeOutQuad',\n          complete: function complete() {\n            placeholder.css({\n              height: '',\n              width: '',\n              position: '',\n              top: '',\n              left: ''\n            });\n            origin.removeAttr('style');\n            origin.attr('style', originInlineStyles); // Remove class\n\n            origin.removeClass('active');\n            doneAnimating = true; // Remove overflow overrides on ancestors\n\n            if (ancestorsChanged) {\n              ancestorsChanged.css('overflow', '');\n            }\n          }\n        }); // Remove Caption + reset css settings on image\n\n        $('.materialbox-caption').velocity({\n          opacity: 0\n        }, {\n          duration: outDuration,\n          // Delay prevents animation overlapping\n          queue: false,\n          easing: 'easeOutQuad',\n          complete: function complete() {\n            $(this).remove();\n          }\n        });\n      }\n    });\n  };\n\n  $(document).ready(function () {\n    $('.materialboxed').materialbox();\n  });\n})(jQuery);\n\n;\n\n(function ($) {\n  $.fn.parallax = function () {\n    var window_width = $(window).width(); // Parallax Scripts\n\n    return this.each(function (i) {\n      var $this = $(this);\n      $this.addClass('parallax');\n\n      function updateParallax(initial) {\n        var container_height;\n\n        if (window_width < 601) {\n          container_height = $this.height() > 0 ? $this.height() : $this.children(\"img\").height();\n        } else {\n          container_height = $this.height() > 0 ? $this.height() : 500;\n        }\n\n        var $img = $this.children(\"img\").first();\n        var img_height = $img.height();\n        var parallax_dist = img_height - container_height;\n        var bottom = $this.offset().top + container_height;\n        var top = $this.offset().top;\n        var scrollTop = $(window).scrollTop();\n        var windowHeight = window.innerHeight;\n        var windowBottom = scrollTop + windowHeight;\n        var percentScrolled = (windowBottom - top) / (container_height + windowHeight);\n        var parallax = Math.round(parallax_dist * percentScrolled);\n\n        if (initial) {\n          $img.css('display', 'block');\n        }\n\n        if (bottom > scrollTop && top < scrollTop + windowHeight) {\n          $img.css('transform', \"translate3D(-50%,\" + parallax + \"px, 0)\");\n        }\n      } // Wait for image load\n\n\n      $this.children(\"img\").one(\"load\", function () {\n        updateParallax(true);\n      }).each(function () {\n        if (this.complete) $(this).trigger(\"load\");\n      });\n      $(window).scroll(function () {\n        window_width = $(window).width();\n        updateParallax(false);\n      });\n      $(window).resize(function () {\n        window_width = $(window).width();\n        updateParallax(false);\n      });\n    });\n  };\n})(jQuery);\n\n;\n\n(function ($) {\n  var methods = {\n    init: function init(options) {\n      var defaults = {\n        onShow: null,\n        swipeable: false,\n        responsiveThreshold: Infinity // breakpoint for swipeable\n\n      };\n      options = $.extend(defaults, options);\n      var namespace = Materialize.objectSelectorString($(this));\n      return this.each(function (i) {\n        var uniqueNamespace = namespace + i; // For each set of tabs, we want to keep track of\n        // which tab is active and its associated content\n\n        var $this = $(this),\n            window_width = $(window).width();\n        var $active,\n            $content,\n            $links = $this.find('li.tab a'),\n            $tabs_width = $this.width(),\n            $tabs_content = $(),\n            $tabs_wrapper,\n            $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length,\n            $indicator,\n            index = 0,\n            prev_index = 0,\n            clicked = false,\n            clickedTimeout,\n            transition = 300; // Finds right attribute for indicator based on active tab.\n        // el: jQuery Object\n\n        var calcRightPos = function calcRightPos(el) {\n          return Math.ceil($tabs_width - el.position().left - el[0].getBoundingClientRect().width - $this.scrollLeft());\n        }; // Finds left attribute for indicator based on active tab.\n        // el: jQuery Object\n\n\n        var calcLeftPos = function calcLeftPos(el) {\n          return Math.floor(el.position().left + $this.scrollLeft());\n        }; // Animates Indicator to active tab.\n        // prev_index: Number\n\n\n        var animateIndicator = function animateIndicator(prev_index) {\n          if (index - prev_index >= 0) {\n            $indicator.velocity({\n              \"right\": calcRightPos($active)\n            }, {\n              duration: transition,\n              queue: false,\n              easing: 'easeOutQuad'\n            });\n            $indicator.velocity({\n              \"left\": calcLeftPos($active)\n            }, {\n              duration: transition,\n              queue: false,\n              easing: 'easeOutQuad',\n              delay: 90\n            });\n          } else {\n            $indicator.velocity({\n              \"left\": calcLeftPos($active)\n            }, {\n              duration: transition,\n              queue: false,\n              easing: 'easeOutQuad'\n            });\n            $indicator.velocity({\n              \"right\": calcRightPos($active)\n            }, {\n              duration: transition,\n              queue: false,\n              easing: 'easeOutQuad',\n              delay: 90\n            });\n          }\n        }; // Change swipeable according to responsive threshold\n\n\n        if (options.swipeable) {\n          if (window_width > options.responsiveThreshold) {\n            options.swipeable = false;\n          }\n        } // If the location.hash matches one of the links, use that as the active tab.\n\n\n        $active = $($links.filter('[href=\"' + location.hash + '\"]')); // If no match is found, use the first link or any with class 'active' as the initial active tab.\n\n        if ($active.length === 0) {\n          $active = $(this).find('li.tab a.active').first();\n        }\n\n        if ($active.length === 0) {\n          $active = $(this).find('li.tab a').first();\n        }\n\n        $active.addClass('active');\n        index = $links.index($active);\n\n        if (index < 0) {\n          index = 0;\n        }\n\n        if ($active[0] !== undefined) {\n          $content = $($active[0].hash);\n          $content.addClass('active');\n        } // append indicator then set indicator width to tab width\n\n\n        if (!$this.find('.indicator').length) {\n          $this.append('<li class=\"indicator\"></li>');\n        }\n\n        $indicator = $this.find('.indicator'); // we make sure that the indicator is at the end of the tabs\n\n        $this.append($indicator);\n\n        if ($this.is(\":visible\")) {\n          // $indicator.css({\"right\": $tabs_width - ((index + 1) * $tab_width)});\n          // $indicator.css({\"left\": index * $tab_width});\n          setTimeout(function () {\n            $indicator.css({\n              \"right\": calcRightPos($active)\n            });\n            $indicator.css({\n              \"left\": calcLeftPos($active)\n            });\n          }, 0);\n        }\n\n        $(window).off('resize.tabs-' + uniqueNamespace).on('resize.tabs-' + uniqueNamespace, function () {\n          $tabs_width = $this.width();\n          $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length;\n\n          if (index < 0) {\n            index = 0;\n          }\n\n          if ($tab_width !== 0 && $tabs_width !== 0) {\n            $indicator.css({\n              \"right\": calcRightPos($active)\n            });\n            $indicator.css({\n              \"left\": calcLeftPos($active)\n            });\n          }\n        }); // Initialize Tabs Content.\n\n        if (options.swipeable) {\n          // TODO: Duplicate calls with swipeable? handle multiple div wrapping.\n          $links.each(function () {\n            var $curr_content = $(Materialize.escapeHash(this.hash));\n            $curr_content.addClass('carousel-item');\n            $tabs_content = $tabs_content.add($curr_content);\n          });\n          $tabs_wrapper = $tabs_content.wrapAll('<div class=\"tabs-content carousel\"></div>');\n          $tabs_content.css('display', '');\n          $('.tabs-content.carousel').carousel({\n            fullWidth: true,\n            noWrap: true,\n            onCycleTo: function onCycleTo(item) {\n              if (!clicked) {\n                var prev_index = index;\n                index = $tabs_wrapper.index(item);\n                $active.removeClass('active');\n                $active = $links.eq(index);\n                $active.addClass('active');\n                animateIndicator(prev_index);\n\n                if (typeof options.onShow === \"function\") {\n                  options.onShow.call($this[0], $content);\n                }\n              }\n            }\n          });\n        } else {\n          // Hide the remaining content\n          $links.not($active).each(function () {\n            $(Materialize.escapeHash(this.hash)).hide();\n          });\n        } // Bind the click event handler\n\n\n        $this.off('click.tabs').on('click.tabs', 'a', function (e) {\n          if ($(this).parent().hasClass('disabled')) {\n            e.preventDefault();\n            return;\n          } // Act as regular link if target attribute is specified.\n\n\n          if (!!$(this).attr(\"target\")) {\n            return;\n          }\n\n          clicked = true;\n          $tabs_width = $this.width();\n          $tab_width = Math.max($tabs_width, $this[0].scrollWidth) / $links.length; // Make the old tab inactive.\n\n          $active.removeClass('active');\n          var $oldContent = $content; // Update the variables with the new link and content\n\n          $active = $(this);\n          $content = $(Materialize.escapeHash(this.hash));\n          $links = $this.find('li.tab a');\n          var activeRect = $active.position(); // Make the tab active.\n\n          $active.addClass('active');\n          prev_index = index;\n          index = $links.index($(this));\n\n          if (index < 0) {\n            index = 0;\n          } // Change url to current tab\n          // window.location.hash = $active.attr('href');\n          // Swap content\n\n\n          if (options.swipeable) {\n            if ($tabs_content.length) {\n              $tabs_content.carousel('set', index, function () {\n                if (typeof options.onShow === \"function\") {\n                  options.onShow.call($this[0], $content);\n                }\n              });\n            }\n          } else {\n            if ($content !== undefined) {\n              $content.show();\n              $content.addClass('active');\n\n              if (typeof options.onShow === \"function\") {\n                options.onShow.call(this, $content);\n              }\n            }\n\n            if ($oldContent !== undefined && !$oldContent.is($content)) {\n              $oldContent.hide();\n              $oldContent.removeClass('active');\n            }\n          } // Reset clicked state\n\n\n          clickedTimeout = setTimeout(function () {\n            clicked = false;\n          }, transition); // Update indicator\n\n          animateIndicator(prev_index); // Prevent the anchor's default click action\n\n          e.preventDefault();\n        });\n      });\n    },\n    select_tab: function select_tab(id) {\n      this.find('a[href=\"#' + id + '\"]').trigger('click');\n    }\n  };\n\n  $.fn.tabs = function (methodOrOptions) {\n    if (methods[methodOrOptions]) {\n      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n      // Default to \"init\"\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tabs');\n    }\n  };\n\n  $(document).ready(function () {\n    $('ul.tabs').tabs();\n  });\n})(jQuery);\n\n;\n\n(function ($) {\n  $.fn.tooltip = function (options) {\n    var timeout = null,\n        margin = 5; // Defaults\n\n    var defaults = {\n      delay: 350,\n      tooltip: '',\n      position: 'bottom',\n      html: false\n    }; // Remove tooltip from the activator\n\n    if (options === \"remove\") {\n      this.each(function () {\n        $('#' + $(this).attr('data-tooltip-id')).remove();\n        $(this).removeAttr('data-tooltip-id');\n        $(this).off('mouseenter.tooltip mouseleave.tooltip');\n      });\n      return false;\n    }\n\n    options = $.extend(defaults, options);\n    return this.each(function () {\n      var tooltipId = Materialize.guid();\n      var origin = $(this); // Destroy old tooltip\n\n      if (origin.attr('data-tooltip-id')) {\n        $('#' + origin.attr('data-tooltip-id')).remove();\n      }\n\n      origin.attr('data-tooltip-id', tooltipId); // Get attributes.\n\n      var allowHtml, tooltipDelay, tooltipPosition, tooltipText, tooltipEl, backdrop;\n\n      var setAttributes = function setAttributes() {\n        allowHtml = origin.attr('data-html') ? origin.attr('data-html') === 'true' : options.html;\n        tooltipDelay = origin.attr('data-delay');\n        tooltipDelay = tooltipDelay === undefined || tooltipDelay === '' ? options.delay : tooltipDelay;\n        tooltipPosition = origin.attr('data-position');\n        tooltipPosition = tooltipPosition === undefined || tooltipPosition === '' ? options.position : tooltipPosition;\n        tooltipText = origin.attr('data-tooltip');\n        tooltipText = tooltipText === undefined || tooltipText === '' ? options.tooltip : tooltipText;\n      };\n\n      setAttributes();\n\n      var renderTooltipEl = function renderTooltipEl() {\n        var tooltip = $('<div class=\"material-tooltip\"></div>'); // Create Text span\n\n        if (allowHtml) {\n          tooltipText = $('<span></span>').html(tooltipText);\n        } else {\n          tooltipText = $('<span></span>').text(tooltipText);\n        } // Create tooltip\n\n\n        tooltip.append(tooltipText).appendTo($('body')).attr('id', tooltipId); // Create backdrop\n\n        backdrop = $('<div class=\"backdrop\"></div>');\n        backdrop.appendTo(tooltip);\n        return tooltip;\n      };\n\n      tooltipEl = renderTooltipEl(); // Destroy previously binded events\n\n      origin.off('mouseenter.tooltip mouseleave.tooltip'); // Mouse In\n\n      var started = false,\n          timeoutRef;\n      origin.on({\n        'mouseenter.tooltip': function mouseenterTooltip(e) {\n          var showTooltip = function showTooltip() {\n            setAttributes();\n            started = true;\n            tooltipEl.velocity('stop');\n            backdrop.velocity('stop');\n            tooltipEl.css({\n              visibility: 'visible',\n              left: '0px',\n              top: '0px'\n            }); // Tooltip positioning\n\n            var originWidth = origin.outerWidth();\n            var originHeight = origin.outerHeight();\n            var tooltipHeight = tooltipEl.outerHeight();\n            var tooltipWidth = tooltipEl.outerWidth();\n            var tooltipVerticalMovement = '0px';\n            var tooltipHorizontalMovement = '0px';\n            var backdropOffsetWidth = backdrop[0].offsetWidth;\n            var backdropOffsetHeight = backdrop[0].offsetHeight;\n            var scaleXFactor = 8;\n            var scaleYFactor = 8;\n            var scaleFactor = 0;\n            var targetTop, targetLeft, newCoordinates;\n\n            if (tooltipPosition === \"top\") {\n              // Top Position\n              targetTop = origin.offset().top - tooltipHeight - margin;\n              targetLeft = origin.offset().left + originWidth / 2 - tooltipWidth / 2;\n              newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n              tooltipVerticalMovement = '-10px';\n              backdrop.css({\n                bottom: 0,\n                left: 0,\n                borderRadius: '14px 14px 0 0',\n                transformOrigin: '50% 100%',\n                marginTop: tooltipHeight,\n                marginLeft: tooltipWidth / 2 - backdropOffsetWidth / 2\n              });\n            } // Left Position\n            else if (tooltipPosition === \"left\") {\n                targetTop = origin.offset().top + originHeight / 2 - tooltipHeight / 2;\n                targetLeft = origin.offset().left - tooltipWidth - margin;\n                newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n                tooltipHorizontalMovement = '-10px';\n                backdrop.css({\n                  top: '-7px',\n                  right: 0,\n                  width: '14px',\n                  height: '14px',\n                  borderRadius: '14px 0 0 14px',\n                  transformOrigin: '95% 50%',\n                  marginTop: tooltipHeight / 2,\n                  marginLeft: tooltipWidth\n                });\n              } // Right Position\n              else if (tooltipPosition === \"right\") {\n                  targetTop = origin.offset().top + originHeight / 2 - tooltipHeight / 2;\n                  targetLeft = origin.offset().left + originWidth + margin;\n                  newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n                  tooltipHorizontalMovement = '+10px';\n                  backdrop.css({\n                    top: '-7px',\n                    left: 0,\n                    width: '14px',\n                    height: '14px',\n                    borderRadius: '0 14px 14px 0',\n                    transformOrigin: '5% 50%',\n                    marginTop: tooltipHeight / 2,\n                    marginLeft: '0px'\n                  });\n                } else {\n                  // Bottom Position\n                  targetTop = origin.offset().top + origin.outerHeight() + margin;\n                  targetLeft = origin.offset().left + originWidth / 2 - tooltipWidth / 2;\n                  newCoordinates = repositionWithinScreen(targetLeft, targetTop, tooltipWidth, tooltipHeight);\n                  tooltipVerticalMovement = '+10px';\n                  backdrop.css({\n                    top: 0,\n                    left: 0,\n                    marginLeft: tooltipWidth / 2 - backdropOffsetWidth / 2\n                  });\n                } // Set tooptip css placement\n\n\n            tooltipEl.css({\n              top: newCoordinates.y,\n              left: newCoordinates.x\n            }); // Calculate Scale to fill\n\n            scaleXFactor = Math.SQRT2 * tooltipWidth / parseInt(backdropOffsetWidth);\n            scaleYFactor = Math.SQRT2 * tooltipHeight / parseInt(backdropOffsetHeight);\n            scaleFactor = Math.max(scaleXFactor, scaleYFactor);\n            tooltipEl.velocity({\n              translateY: tooltipVerticalMovement,\n              translateX: tooltipHorizontalMovement\n            }, {\n              duration: 350,\n              queue: false\n            }).velocity({\n              opacity: 1\n            }, {\n              duration: 300,\n              delay: 50,\n              queue: false\n            });\n            backdrop.css({\n              visibility: 'visible'\n            }).velocity({\n              opacity: 1\n            }, {\n              duration: 55,\n              delay: 0,\n              queue: false\n            }).velocity({\n              scaleX: scaleFactor,\n              scaleY: scaleFactor\n            }, {\n              duration: 300,\n              delay: 0,\n              queue: false,\n              easing: 'easeInOutQuad'\n            });\n          };\n\n          timeoutRef = setTimeout(showTooltip, tooltipDelay); // End Interval\n          // Mouse Out\n        },\n        'mouseleave.tooltip': function mouseleaveTooltip() {\n          // Reset State\n          started = false;\n          clearTimeout(timeoutRef); // Animate back\n\n          setTimeout(function () {\n            if (started !== true) {\n              tooltipEl.velocity({\n                opacity: 0,\n                translateY: 0,\n                translateX: 0\n              }, {\n                duration: 225,\n                queue: false\n              });\n              backdrop.velocity({\n                opacity: 0,\n                scaleX: 1,\n                scaleY: 1\n              }, {\n                duration: 225,\n                queue: false,\n                complete: function complete() {\n                  backdrop.css({\n                    visibility: 'hidden'\n                  });\n                  tooltipEl.css({\n                    visibility: 'hidden'\n                  });\n                  started = false;\n                }\n              });\n            }\n          }, 225);\n        }\n      });\n    });\n  };\n\n  var repositionWithinScreen = function repositionWithinScreen(x, y, width, height) {\n    var newX = x;\n    var newY = y;\n\n    if (newX < 0) {\n      newX = 4;\n    } else if (newX + width > window.innerWidth) {\n      newX -= newX + width - window.innerWidth;\n    }\n\n    if (newY < 0) {\n      newY = 4;\n    } else if (newY + height > window.innerHeight + $(window).scrollTop) {\n      newY -= newY + height - window.innerHeight;\n    }\n\n    return {\n      x: newX,\n      y: newY\n    };\n  };\n\n  $(document).ready(function () {\n    $('.tooltipped').tooltip();\n  });\n})(jQuery);\n\n;\n/*!\r\n* Waves v0.6.4\r\n* http://fian.my.id/Waves\r\n*\r\n* Copyright 2014 Alfiana E. Sibuea and other contributors\r\n* Released under the MIT license\r\n* https://github.com/fians/Waves/blob/master/LICENSE\r\n*/\n\n;\n\n(function (window) {\n  'use strict';\n\n  var Waves = Waves || {};\n  var $$ = document.querySelectorAll.bind(document); // Find exact position of element\n\n  function isWindow(obj) {\n    return obj !== null && obj === obj.window;\n  }\n\n  function getWindow(elem) {\n    return isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;\n  }\n\n  function offset(elem) {\n    var docElem,\n        win,\n        box = {\n      top: 0,\n      left: 0\n    },\n        doc = elem && elem.ownerDocument;\n    docElem = doc.documentElement;\n\n    if (typeof elem.getBoundingClientRect !== typeof undefined) {\n      box = elem.getBoundingClientRect();\n    }\n\n    win = getWindow(doc);\n    return {\n      top: box.top + win.pageYOffset - docElem.clientTop,\n      left: box.left + win.pageXOffset - docElem.clientLeft\n    };\n  }\n\n  function convertStyle(obj) {\n    var style = '';\n\n    for (var a in obj) {\n      if (obj.hasOwnProperty(a)) {\n        style += a + ':' + obj[a] + ';';\n      }\n    }\n\n    return style;\n  }\n\n  var Effect = {\n    // Effect delay\n    duration: 750,\n    show: function show(e, element) {\n      // Disable right click\n      if (e.button === 2) {\n        return false;\n      }\n\n      var el = element || this; // Create ripple\n\n      var ripple = document.createElement('div');\n      ripple.className = 'waves-ripple';\n      el.appendChild(ripple); // Get click coordinate and element witdh\n\n      var pos = offset(el);\n      var relativeY = e.pageY - pos.top;\n      var relativeX = e.pageX - pos.left;\n      var scale = 'scale(' + el.clientWidth / 100 * 10 + ')'; // Support for touch devices\n\n      if ('touches' in e) {\n        relativeY = e.touches[0].pageY - pos.top;\n        relativeX = e.touches[0].pageX - pos.left;\n      } // Attach data to element\n\n\n      ripple.setAttribute('data-hold', Date.now());\n      ripple.setAttribute('data-scale', scale);\n      ripple.setAttribute('data-x', relativeX);\n      ripple.setAttribute('data-y', relativeY); // Set ripple position\n\n      var rippleStyle = {\n        'top': relativeY + 'px',\n        'left': relativeX + 'px'\n      };\n      ripple.className = ripple.className + ' waves-notransition';\n      ripple.setAttribute('style', convertStyle(rippleStyle));\n      ripple.className = ripple.className.replace('waves-notransition', ''); // Scale the ripple\n\n      rippleStyle['-webkit-transform'] = scale;\n      rippleStyle['-moz-transform'] = scale;\n      rippleStyle['-ms-transform'] = scale;\n      rippleStyle['-o-transform'] = scale;\n      rippleStyle.transform = scale;\n      rippleStyle.opacity = '1';\n      rippleStyle['-webkit-transition-duration'] = Effect.duration + 'ms';\n      rippleStyle['-moz-transition-duration'] = Effect.duration + 'ms';\n      rippleStyle['-o-transition-duration'] = Effect.duration + 'ms';\n      rippleStyle['transition-duration'] = Effect.duration + 'ms';\n      rippleStyle['-webkit-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n      rippleStyle['-moz-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n      rippleStyle['-o-transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n      rippleStyle['transition-timing-function'] = 'cubic-bezier(0.250, 0.460, 0.450, 0.940)';\n      ripple.setAttribute('style', convertStyle(rippleStyle));\n    },\n    hide: function hide(e) {\n      TouchHandler.touchup(e);\n      var el = this;\n      var width = el.clientWidth * 1.4; // Get first ripple\n\n      var ripple = null;\n      var ripples = el.getElementsByClassName('waves-ripple');\n\n      if (ripples.length > 0) {\n        ripple = ripples[ripples.length - 1];\n      } else {\n        return false;\n      }\n\n      var relativeX = ripple.getAttribute('data-x');\n      var relativeY = ripple.getAttribute('data-y');\n      var scale = ripple.getAttribute('data-scale'); // Get delay beetween mousedown and mouse leave\n\n      var diff = Date.now() - Number(ripple.getAttribute('data-hold'));\n      var delay = 350 - diff;\n\n      if (delay < 0) {\n        delay = 0;\n      } // Fade out ripple after delay\n\n\n      setTimeout(function () {\n        var style = {\n          'top': relativeY + 'px',\n          'left': relativeX + 'px',\n          'opacity': '0',\n          // Duration\n          '-webkit-transition-duration': Effect.duration + 'ms',\n          '-moz-transition-duration': Effect.duration + 'ms',\n          '-o-transition-duration': Effect.duration + 'ms',\n          'transition-duration': Effect.duration + 'ms',\n          '-webkit-transform': scale,\n          '-moz-transform': scale,\n          '-ms-transform': scale,\n          '-o-transform': scale,\n          'transform': scale\n        };\n        ripple.setAttribute('style', convertStyle(style));\n        setTimeout(function () {\n          try {\n            el.removeChild(ripple);\n          } catch (e) {\n            return false;\n          }\n        }, Effect.duration);\n      }, delay);\n    },\n    // Little hack to make <input> can perform waves effect\n    wrapInput: function wrapInput(elements) {\n      for (var a = 0; a < elements.length; a++) {\n        var el = elements[a];\n\n        if (el.tagName.toLowerCase() === 'input') {\n          var parent = el.parentNode; // If input already have parent just pass through\n\n          if (parent.tagName.toLowerCase() === 'i' && parent.className.indexOf('waves-effect') !== -1) {\n            continue;\n          } // Put element class and style to the specified parent\n\n\n          var wrapper = document.createElement('i');\n          wrapper.className = el.className + ' waves-input-wrapper';\n          var elementStyle = el.getAttribute('style');\n\n          if (!elementStyle) {\n            elementStyle = '';\n          }\n\n          wrapper.setAttribute('style', elementStyle);\n          el.className = 'waves-button-input';\n          el.removeAttribute('style'); // Put element as child\n\n          parent.replaceChild(wrapper, el);\n          wrapper.appendChild(el);\n        }\n      }\n    }\n  };\n  /**\r\n   * Disable mousedown event for 500ms during and after touch\r\n   */\n\n  var TouchHandler = {\n    /* uses an integer rather than bool so there's no issues with\r\n     * needing to clear timeouts if another touch event occurred\r\n     * within the 500ms. Cannot mouseup between touchstart and\r\n     * touchend, nor in the 500ms after touchend. */\n    touches: 0,\n    allowEvent: function allowEvent(e) {\n      var allow = true;\n\n      if (e.type === 'touchstart') {\n        TouchHandler.touches += 1; //push\n      } else if (e.type === 'touchend' || e.type === 'touchcancel') {\n        setTimeout(function () {\n          if (TouchHandler.touches > 0) {\n            TouchHandler.touches -= 1; //pop after 500ms\n          }\n        }, 500);\n      } else if (e.type === 'mousedown' && TouchHandler.touches > 0) {\n        allow = false;\n      }\n\n      return allow;\n    },\n    touchup: function touchup(e) {\n      TouchHandler.allowEvent(e);\n    }\n  };\n  /**\r\n   * Delegated click handler for .waves-effect element.\r\n   * returns null when .waves-effect element not in \"click tree\"\r\n   */\n\n  function getWavesEffectElement(e) {\n    if (TouchHandler.allowEvent(e) === false) {\n      return null;\n    }\n\n    var element = null;\n    var target = e.target || e.srcElement;\n\n    while (target.parentNode !== null) {\n      if (!(target instanceof SVGElement) && target.className.indexOf('waves-effect') !== -1) {\n        element = target;\n        break;\n      }\n\n      target = target.parentNode;\n    }\n\n    return element;\n  }\n  /**\r\n   * Bubble the click and show effect if .waves-effect elem was found\r\n   */\n\n\n  function showEffect(e) {\n    var element = getWavesEffectElement(e);\n\n    if (element !== null) {\n      Effect.show(e, element);\n\n      if ('ontouchstart' in window) {\n        element.addEventListener('touchend', Effect.hide, false);\n        element.addEventListener('touchcancel', Effect.hide, false);\n      }\n\n      element.addEventListener('mouseup', Effect.hide, false);\n      element.addEventListener('mouseleave', Effect.hide, false);\n      element.addEventListener('dragend', Effect.hide, false);\n    }\n  }\n\n  Waves.displayEffect = function (options) {\n    options = options || {};\n\n    if ('duration' in options) {\n      Effect.duration = options.duration;\n    } //Wrap input inside <i> tag\n\n\n    Effect.wrapInput($$('.waves-effect'));\n\n    if ('ontouchstart' in window) {\n      document.body.addEventListener('touchstart', showEffect, false);\n    }\n\n    document.body.addEventListener('mousedown', showEffect, false);\n  };\n  /**\r\n   * Attach Waves to an input element (or any element which doesn't\r\n   * bubble mouseup/mousedown events).\r\n   *   Intended to be used with dynamically loaded forms/inputs, or\r\n   * where the user doesn't want a delegated click handler.\r\n   */\n\n\n  Waves.attach = function (element) {\n    //FUTURE: automatically add waves classes and allow users\n    // to specify them with an options param? Eg. light/classic/button\n    if (element.tagName.toLowerCase() === 'input') {\n      Effect.wrapInput([element]);\n      element = element.parentNode;\n    }\n\n    if ('ontouchstart' in window) {\n      element.addEventListener('touchstart', showEffect, false);\n    }\n\n    element.addEventListener('mousedown', showEffect, false);\n  };\n\n  window.Waves = Waves;\n  document.addEventListener('DOMContentLoaded', function () {\n    Waves.displayEffect();\n  }, false);\n})(window);\n\n;\n\n(function ($, Vel) {\n  'use strict';\n\n  var _defaults = {\n    displayLength: Infinity,\n    inDuration: 300,\n    outDuration: 375,\n    className: undefined,\n    completeCallback: undefined,\n    activationPercent: 0.8\n  };\n\n  var Toast = function () {\n    function Toast(message, displayLength, className, completeCallback) {\n      _classCallCheck(this, Toast);\n\n      if (!message) {\n        return;\n      }\n      /**\r\n       * Options for the toast\r\n       * @member Toast#options\r\n       */\n\n\n      this.options = {\n        displayLength: displayLength,\n        className: className,\n        completeCallback: completeCallback\n      };\n      this.options = $.extend({}, Toast.defaults, this.options);\n      this.message = message;\n      /**\r\n       * Describes current pan state toast\r\n       * @type {Boolean}\r\n       */\n\n      this.panning = false;\n      /**\r\n       * Time remaining until toast is removed\r\n       */\n\n      this.timeRemaining = this.options.displayLength;\n\n      if (Toast._toasts.length === 0) {\n        Toast._createContainer();\n      } // Create new toast\n\n\n      Toast._toasts.push(this);\n\n      var toastElement = this.createToast();\n      toastElement.M_Toast = this;\n      this.el = toastElement;\n\n      this._animateIn();\n\n      this.setTimer();\n    }\n\n    _createClass(Toast, [{\n      key: 'createToast',\n\n      /**\r\n       * Create toast and append it to toast container\r\n       */\n      value: function createToast() {\n        var toast = document.createElement('div');\n        toast.classList.add('toast'); // Add custom classes onto toast\n\n        if (this.options.className) {\n          var classes = this.options.className.split(' ');\n          var i = void 0,\n              count = void 0;\n\n          for (i = 0, count = classes.length; i < count; i++) {\n            toast.classList.add(classes[i]);\n          }\n        } // Set content\n\n\n        if (typeof HTMLElement === 'object' ? this.message instanceof HTMLElement : this.message && typeof this.message === 'object' && this.message !== null && this.message.nodeType === 1 && typeof this.message.nodeName === 'string') {\n          toast.appendChild(this.message); // Check if it is jQuery object\n        } else if (this.message instanceof jQuery) {\n          $(toast).append(this.message); // Insert as text;\n        } else {\n          toast.innerHTML = this.message;\n        } // Append toasft\n\n\n        Toast._container.appendChild(toast);\n\n        return toast;\n      }\n      /**\r\n       * Animate in toast\r\n       */\n\n    }, {\n      key: '_animateIn',\n      value: function _animateIn() {\n        // Animate toast in\n        Vel(this.el, {\n          top: 0,\n          opacity: 1\n        }, {\n          duration: 300,\n          easing: 'easeOutCubic',\n          queue: false\n        });\n      }\n      /**\r\n       * Create setInterval which automatically removes toast when timeRemaining >= 0\r\n       * has been reached\r\n       */\n\n    }, {\n      key: 'setTimer',\n      value: function setTimer() {\n        var _this3 = this;\n\n        if (this.timeRemaining !== Infinity) {\n          this.counterInterval = setInterval(function () {\n            // If toast is not being dragged, decrease its time remaining\n            if (!_this3.panning) {\n              _this3.timeRemaining -= 20;\n            } // Animate toast out\n\n\n            if (_this3.timeRemaining <= 0) {\n              _this3.remove();\n            }\n          }, 20);\n        }\n      }\n      /**\r\n       * Dismiss toast with animation\r\n       */\n\n    }, {\n      key: 'remove',\n      value: function remove() {\n        var _this4 = this;\n\n        window.clearInterval(this.counterInterval);\n        var activationDistance = this.el.offsetWidth * this.options.activationPercent;\n\n        if (this.wasSwiped) {\n          this.el.style.transition = 'transform .05s, opacity .05s';\n          this.el.style.transform = 'translateX(' + activationDistance + 'px)';\n          this.el.style.opacity = 0;\n        }\n\n        Vel(this.el, {\n          opacity: 0,\n          marginTop: '-40px'\n        }, {\n          duration: this.options.outDuration,\n          easing: 'easeOutExpo',\n          queue: false,\n          complete: function complete() {\n            // Call the optional callback\n            if (typeof _this4.options.completeCallback === 'function') {\n              _this4.options.completeCallback();\n            } // Remove toast from DOM\n\n\n            _this4.el.parentNode.removeChild(_this4.el);\n\n            Toast._toasts.splice(Toast._toasts.indexOf(_this4), 1);\n\n            if (Toast._toasts.length === 0) {\n              Toast._removeContainer();\n            }\n          }\n        });\n      }\n    }], [{\n      key: '_createContainer',\n\n      /**\r\n       * Append toast container and add event handlers\r\n       */\n      value: function _createContainer() {\n        var container = document.createElement('div');\n        container.setAttribute('id', 'toast-container'); // Add event handler\n\n        container.addEventListener('touchstart', Toast._onDragStart);\n        container.addEventListener('touchmove', Toast._onDragMove);\n        container.addEventListener('touchend', Toast._onDragEnd);\n        container.addEventListener('mousedown', Toast._onDragStart);\n        document.addEventListener('mousemove', Toast._onDragMove);\n        document.addEventListener('mouseup', Toast._onDragEnd);\n        document.body.appendChild(container);\n        Toast._container = container;\n      }\n      /**\r\n       * Remove toast container and event handlers\r\n       */\n\n    }, {\n      key: '_removeContainer',\n      value: function _removeContainer() {\n        // Add event handler\n        document.removeEventListener('mousemove', Toast._onDragMove);\n        document.removeEventListener('mouseup', Toast._onDragEnd);\n\n        Toast._container.parentNode.removeChild(Toast._container);\n\n        Toast._container = null;\n      }\n      /**\r\n       * Begin drag handler\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: '_onDragStart',\n      value: function _onDragStart(e) {\n        if (e.target && $(e.target).closest('.toast').length) {\n          var $toast = $(e.target).closest('.toast');\n          var toast = $toast[0].M_Toast;\n          toast.panning = true;\n          Toast._draggedToast = toast;\n          toast.el.classList.add('panning');\n          toast.el.style.transition = '';\n          toast.startingXPos = Toast._xPos(e);\n          toast.time = Date.now();\n          toast.xPos = Toast._xPos(e);\n        }\n      }\n      /**\r\n       * Drag move handler\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: '_onDragMove',\n      value: function _onDragMove(e) {\n        if (!!Toast._draggedToast) {\n          e.preventDefault();\n          var toast = Toast._draggedToast;\n          toast.deltaX = Math.abs(toast.xPos - Toast._xPos(e));\n          toast.xPos = Toast._xPos(e);\n          toast.velocityX = toast.deltaX / (Date.now() - toast.time);\n          toast.time = Date.now();\n          var totalDeltaX = toast.xPos - toast.startingXPos;\n          var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;\n          toast.el.style.transform = 'translateX(' + totalDeltaX + 'px)';\n          toast.el.style.opacity = 1 - Math.abs(totalDeltaX / activationDistance);\n        }\n      }\n      /**\r\n       * End drag handler\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: '_onDragEnd',\n      value: function _onDragEnd(e) {\n        if (!!Toast._draggedToast) {\n          var toast = Toast._draggedToast;\n          toast.panning = false;\n          toast.el.classList.remove('panning');\n          var totalDeltaX = toast.xPos - toast.startingXPos;\n          var activationDistance = toast.el.offsetWidth * toast.options.activationPercent;\n          var shouldBeDismissed = Math.abs(totalDeltaX) > activationDistance || toast.velocityX > 1; // Remove toast\n\n          if (shouldBeDismissed) {\n            toast.wasSwiped = true;\n            toast.remove(); // Animate toast back to original position\n          } else {\n            toast.el.style.transition = 'transform .2s, opacity .2s';\n            toast.el.style.transform = '';\n            toast.el.style.opacity = '';\n          }\n\n          Toast._draggedToast = null;\n        }\n      }\n      /**\r\n       * Get x position of mouse or touch event\r\n       * @param {Event} e\r\n       */\n\n    }, {\n      key: '_xPos',\n      value: function _xPos(e) {\n        if (e.targetTouches && e.targetTouches.length >= 1) {\n          return e.targetTouches[0].clientX;\n        } // mouse event\n\n\n        return e.clientX;\n      }\n      /**\r\n       * Remove all toasts\r\n       */\n\n    }, {\n      key: 'removeAll',\n      value: function removeAll() {\n        for (var toastIndex in Toast._toasts) {\n          Toast._toasts[toastIndex].remove();\n        }\n      }\n    }, {\n      key: 'defaults',\n      get: function get() {\n        return _defaults;\n      }\n    }]);\n\n    return Toast;\n  }();\n  /**\r\n   * @static\r\n   * @memberof Toast\r\n   * @type {Array.<Toast>}\r\n   */\n\n\n  Toast._toasts = [];\n  /**\r\n   * @static\r\n   * @memberof Toast\r\n   */\n\n  Toast._container = null;\n  /**\r\n   * @static\r\n   * @memberof Toast\r\n   * @type {Toast}\r\n   */\n\n  Toast._draggedToast = null;\n  Materialize.Toast = Toast;\n\n  Materialize.toast = function (message, displayLength, className, completeCallback) {\n    return new Toast(message, displayLength, className, completeCallback);\n  };\n})(jQuery, Materialize.Vel);\n\n;\n\n(function ($) {\n  var methods = {\n    init: function init(options) {\n      var defaults = {\n        menuWidth: 300,\n        edge: 'left',\n        closeOnClick: false,\n        draggable: true,\n        onOpen: null,\n        onClose: null\n      };\n      options = $.extend(defaults, options);\n      $(this).each(function () {\n        var $this = $(this);\n        var menuId = $this.attr('data-activates');\n        var menu = $(\"#\" + menuId); // Set to width\n\n        if (options.menuWidth != 300) {\n          menu.css('width', options.menuWidth);\n        } // Add Touch Area\n\n\n        var $dragTarget = $('.drag-target[data-sidenav=\"' + menuId + '\"]');\n\n        if (options.draggable) {\n          // Regenerate dragTarget\n          if ($dragTarget.length) {\n            $dragTarget.remove();\n          }\n\n          $dragTarget = $('<div class=\"drag-target\"></div>').attr('data-sidenav', menuId);\n          $('body').append($dragTarget);\n        } else {\n          $dragTarget = $();\n        }\n\n        if (options.edge == 'left') {\n          menu.css('transform', 'translateX(-100%)');\n          $dragTarget.css({\n            'left': 0\n          }); // Add Touch Area\n        } else {\n          menu.addClass('right-aligned') // Change text-alignment to right\n          .css('transform', 'translateX(100%)');\n          $dragTarget.css({\n            'right': 0\n          }); // Add Touch Area\n        } // If fixed sidenav, bring menu out\n\n\n        if (menu.hasClass('fixed')) {\n          if (window.innerWidth > 992) {\n            menu.css('transform', 'translateX(0)');\n          }\n        } // Window resize to reset on large screens fixed\n\n\n        if (menu.hasClass('fixed')) {\n          $(window).resize(function () {\n            if (window.innerWidth > 992) {\n              // Close menu if window is resized bigger than 992 and user has fixed sidenav\n              if ($('#sidenav-overlay').length !== 0 && menuOut) {\n                removeMenu(true);\n              } else {\n                // menu.removeAttr('style');\n                menu.css('transform', 'translateX(0%)'); // menu.css('width', options.menuWidth);\n              }\n            } else if (menuOut === false) {\n              if (options.edge === 'left') {\n                menu.css('transform', 'translateX(-100%)');\n              } else {\n                menu.css('transform', 'translateX(100%)');\n              }\n            }\n          });\n        } // if closeOnClick, then add close event for all a tags in side sideNav\n\n\n        if (options.closeOnClick === true) {\n          menu.on(\"click.itemclick\", \"a:not(.collapsible-header)\", function () {\n            if (!(window.innerWidth > 992 && menu.hasClass('fixed'))) {\n              removeMenu();\n            }\n          });\n        }\n\n        var removeMenu = function removeMenu(restoreNav) {\n          panning = false;\n          menuOut = false; // Reenable scrolling\n\n          $('body').css({\n            overflow: '',\n            width: ''\n          });\n          $('#sidenav-overlay').velocity({\n            opacity: 0\n          }, {\n            duration: 200,\n            queue: false,\n            easing: 'easeOutQuad',\n            complete: function complete() {\n              $(this).remove();\n            }\n          });\n\n          if (options.edge === 'left') {\n            // Reset phantom div\n            $dragTarget.css({\n              width: '',\n              right: '',\n              left: '0'\n            });\n            menu.velocity({\n              'translateX': '-100%'\n            }, {\n              duration: 200,\n              queue: false,\n              easing: 'easeOutCubic',\n              complete: function complete() {\n                if (restoreNav === true) {\n                  // Restore Fixed sidenav\n                  menu.removeAttr('style');\n                  menu.css('width', options.menuWidth);\n                }\n              }\n            });\n          } else {\n            // Reset phantom div\n            $dragTarget.css({\n              width: '',\n              right: '0',\n              left: ''\n            });\n            menu.velocity({\n              'translateX': '100%'\n            }, {\n              duration: 200,\n              queue: false,\n              easing: 'easeOutCubic',\n              complete: function complete() {\n                if (restoreNav === true) {\n                  // Restore Fixed sidenav\n                  menu.removeAttr('style');\n                  menu.css('width', options.menuWidth);\n                }\n              }\n            });\n          } // Callback\n\n\n          if (typeof options.onClose === 'function') {\n            options.onClose.call(this, menu);\n          }\n        }; // Touch Event\n\n\n        var panning = false;\n        var menuOut = false;\n\n        if (options.draggable) {\n          $dragTarget.on('click', function () {\n            if (menuOut) {\n              removeMenu();\n            }\n          });\n          $dragTarget.hammer({\n            prevent_default: false\n          }).on('pan', function (e) {\n            if (e.gesture.pointerType == \"touch\") {\n              var direction = e.gesture.direction;\n              var x = e.gesture.center.x;\n              var y = e.gesture.center.y;\n              var velocityX = e.gesture.velocityX; // Vertical scroll bugfix\n\n              if (x === 0 && y === 0) {\n                return;\n              } // Disable Scrolling\n\n\n              var $body = $('body');\n              var $overlay = $('#sidenav-overlay');\n              var oldWidth = $body.innerWidth();\n              $body.css('overflow', 'hidden');\n              $body.width(oldWidth); // If overlay does not exist, create one and if it is clicked, close menu\n\n              if ($overlay.length === 0) {\n                $overlay = $('<div id=\"sidenav-overlay\"></div>');\n                $overlay.css('opacity', 0).click(function () {\n                  removeMenu();\n                }); // Run 'onOpen' when sidenav is opened via touch/swipe if applicable\n\n                if (typeof options.onOpen === 'function') {\n                  options.onOpen.call(this, menu);\n                }\n\n                $('body').append($overlay);\n              } // Keep within boundaries\n\n\n              if (options.edge === 'left') {\n                if (x > options.menuWidth) {\n                  x = options.menuWidth;\n                } else if (x < 0) {\n                  x = 0;\n                }\n              }\n\n              if (options.edge === 'left') {\n                // Left Direction\n                if (x < options.menuWidth / 2) {\n                  menuOut = false;\n                } // Right Direction\n                else if (x >= options.menuWidth / 2) {\n                    menuOut = true;\n                  }\n\n                menu.css('transform', 'translateX(' + (x - options.menuWidth) + 'px)');\n              } else {\n                // Left Direction\n                if (x < window.innerWidth - options.menuWidth / 2) {\n                  menuOut = true;\n                } // Right Direction\n                else if (x >= window.innerWidth - options.menuWidth / 2) {\n                    menuOut = false;\n                  }\n\n                var rightPos = x - options.menuWidth / 2;\n\n                if (rightPos < 0) {\n                  rightPos = 0;\n                }\n\n                menu.css('transform', 'translateX(' + rightPos + 'px)');\n              } // Percentage overlay\n\n\n              var overlayPerc;\n\n              if (options.edge === 'left') {\n                overlayPerc = x / options.menuWidth;\n                $overlay.velocity({\n                  opacity: overlayPerc\n                }, {\n                  duration: 10,\n                  queue: false,\n                  easing: 'easeOutQuad'\n                });\n              } else {\n                overlayPerc = Math.abs((x - window.innerWidth) / options.menuWidth);\n                $overlay.velocity({\n                  opacity: overlayPerc\n                }, {\n                  duration: 10,\n                  queue: false,\n                  easing: 'easeOutQuad'\n                });\n              }\n            }\n          }).on('panend', function (e) {\n            if (e.gesture.pointerType == \"touch\") {\n              var $overlay = $('#sidenav-overlay');\n              var velocityX = e.gesture.velocityX;\n              var x = e.gesture.center.x;\n              var leftPos = x - options.menuWidth;\n              var rightPos = x - options.menuWidth / 2;\n\n              if (leftPos > 0) {\n                leftPos = 0;\n              }\n\n              if (rightPos < 0) {\n                rightPos = 0;\n              }\n\n              panning = false;\n\n              if (options.edge === 'left') {\n                // If velocityX <= 0.3 then the user is flinging the menu closed so ignore menuOut\n                if (menuOut && velocityX <= 0.3 || velocityX < -0.5) {\n                  // Return menu to open\n                  if (leftPos !== 0) {\n                    menu.velocity({\n                      'translateX': [0, leftPos]\n                    }, {\n                      duration: 300,\n                      queue: false,\n                      easing: 'easeOutQuad'\n                    });\n                  }\n\n                  $overlay.velocity({\n                    opacity: 1\n                  }, {\n                    duration: 50,\n                    queue: false,\n                    easing: 'easeOutQuad'\n                  });\n                  $dragTarget.css({\n                    width: '50%',\n                    right: 0,\n                    left: ''\n                  });\n                  menuOut = true;\n                } else if (!menuOut || velocityX > 0.3) {\n                  // Enable Scrolling\n                  $('body').css({\n                    overflow: '',\n                    width: ''\n                  }); // Slide menu closed\n\n                  menu.velocity({\n                    'translateX': [-1 * options.menuWidth - 10, leftPos]\n                  }, {\n                    duration: 200,\n                    queue: false,\n                    easing: 'easeOutQuad'\n                  });\n                  $overlay.velocity({\n                    opacity: 0\n                  }, {\n                    duration: 200,\n                    queue: false,\n                    easing: 'easeOutQuad',\n                    complete: function complete() {\n                      // Run 'onClose' when sidenav is closed via touch/swipe if applicable\n                      if (typeof options.onClose === 'function') {\n                        options.onClose.call(this, menu);\n                      }\n\n                      $(this).remove();\n                    }\n                  });\n                  $dragTarget.css({\n                    width: '10px',\n                    right: '',\n                    left: 0\n                  });\n                }\n              } else {\n                if (menuOut && velocityX >= -0.3 || velocityX > 0.5) {\n                  // Return menu to open\n                  if (rightPos !== 0) {\n                    menu.velocity({\n                      'translateX': [0, rightPos]\n                    }, {\n                      duration: 300,\n                      queue: false,\n                      easing: 'easeOutQuad'\n                    });\n                  }\n\n                  $overlay.velocity({\n                    opacity: 1\n                  }, {\n                    duration: 50,\n                    queue: false,\n                    easing: 'easeOutQuad'\n                  });\n                  $dragTarget.css({\n                    width: '50%',\n                    right: '',\n                    left: 0\n                  });\n                  menuOut = true;\n                } else if (!menuOut || velocityX < -0.3) {\n                  // Enable Scrolling\n                  $('body').css({\n                    overflow: '',\n                    width: ''\n                  }); // Slide menu closed\n\n                  menu.velocity({\n                    'translateX': [options.menuWidth + 10, rightPos]\n                  }, {\n                    duration: 200,\n                    queue: false,\n                    easing: 'easeOutQuad'\n                  });\n                  $overlay.velocity({\n                    opacity: 0\n                  }, {\n                    duration: 200,\n                    queue: false,\n                    easing: 'easeOutQuad',\n                    complete: function complete() {\n                      // Run 'onClose' when sidenav is closed via touch/swipe if applicable\n                      if (typeof options.onClose === 'function') {\n                        options.onClose.call(this, menu);\n                      }\n\n                      $(this).remove();\n                    }\n                  });\n                  $dragTarget.css({\n                    width: '10px',\n                    right: 0,\n                    left: ''\n                  });\n                }\n              }\n            }\n          });\n        }\n\n        $this.off('click.sidenav').on('click.sidenav', function () {\n          if (menuOut === true) {\n            menuOut = false;\n            panning = false;\n            removeMenu();\n          } else {\n            // Disable Scrolling\n            var $body = $('body');\n            var $overlay = $('<div id=\"sidenav-overlay\"></div>');\n            var oldWidth = $body.innerWidth();\n            $body.css('overflow', 'hidden');\n            $body.width(oldWidth); // Push current drag target on top of DOM tree\n\n            $('body').append($dragTarget);\n\n            if (options.edge === 'left') {\n              $dragTarget.css({\n                width: '50%',\n                right: 0,\n                left: ''\n              });\n              menu.velocity({\n                'translateX': [0, -1 * options.menuWidth]\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            } else {\n              $dragTarget.css({\n                width: '50%',\n                right: '',\n                left: 0\n              });\n              menu.velocity({\n                'translateX': [0, options.menuWidth]\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            } // Overlay close on click\n\n\n            $overlay.css('opacity', 0).click(function () {\n              menuOut = false;\n              panning = false;\n              removeMenu();\n              $overlay.velocity({\n                opacity: 0\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad',\n                complete: function complete() {\n                  $(this).remove();\n                }\n              });\n            }); // Append body\n\n            $('body').append($overlay);\n            $overlay.velocity({\n              opacity: 1\n            }, {\n              duration: 300,\n              queue: false,\n              easing: 'easeOutQuad',\n              complete: function complete() {\n                menuOut = true;\n                panning = false;\n              }\n            }); // Callback\n\n            if (typeof options.onOpen === 'function') {\n              options.onOpen.call(this, menu);\n            }\n          }\n\n          return false;\n        });\n      });\n    },\n    destroy: function destroy() {\n      var $overlay = $('#sidenav-overlay');\n      var $dragTarget = $('.drag-target[data-sidenav=\"' + $(this).attr('data-activates') + '\"]');\n      $overlay.trigger('click');\n      $dragTarget.remove();\n      $(this).off('click');\n      $overlay.remove();\n    },\n    show: function show() {\n      this.trigger('click');\n    },\n    hide: function hide() {\n      $('#sidenav-overlay').trigger('click');\n    }\n  };\n\n  $.fn.sideNav = function (methodOrOptions) {\n    if (methods[methodOrOptions]) {\n      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n      // Default to \"init\"\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.sideNav');\n    }\n  }; // Plugin end\n\n})(jQuery);\n\n;\n/**\r\n* Extend jquery with a scrollspy plugin.\r\n* This watches the window scroll and fires events when elements are scrolled into viewport.\r\n*\r\n* throttle() and getTime() taken from Underscore.js\r\n* https://github.com/jashkenas/underscore\r\n*\r\n* @author Copyright 2013 John Smart\r\n* @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE\r\n* @see https://github.com/thesmart\r\n* @version 0.1.2\r\n*/\n\n(function ($) {\n  var jWindow = $(window);\n  var elements = [];\n  var elementsInView = [];\n  var isSpying = false;\n  var ticks = 0;\n  var unique_id = 1;\n  var offset = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n    /**\r\n     * Find elements that are within the boundary\r\n     * @param {number} top\r\n     * @param {number} right\r\n     * @param {number} bottom\r\n     * @param {number} left\r\n     * @return {jQuery}\t\tA collection of elements\r\n     */\n\n  };\n\n  function findElements(top, right, bottom, left) {\n    var hits = $();\n    $.each(elements, function (i, element) {\n      if (element.height() > 0) {\n        var elTop = element.offset().top,\n            elLeft = element.offset().left,\n            elRight = elLeft + element.width(),\n            elBottom = elTop + element.height();\n        var isIntersect = !(elLeft > right || elRight < left || elTop > bottom || elBottom < top);\n\n        if (isIntersect) {\n          hits.push(element);\n        }\n      }\n    });\n    return hits;\n  }\n  /**\r\n   * Called when the user scrolls the window\r\n   */\n\n\n  function onScroll(scrollOffset) {\n    // unique tick id\n    ++ticks; // viewport rectangle\n\n    var top = jWindow.scrollTop(),\n        left = jWindow.scrollLeft(),\n        right = left + jWindow.width(),\n        bottom = top + jWindow.height(); // determine which elements are in view\n\n    var intersections = findElements(top + offset.top + scrollOffset || 200, right + offset.right, bottom + offset.bottom, left + offset.left);\n    $.each(intersections, function (i, element) {\n      var lastTick = element.data('scrollSpy:ticks');\n\n      if (typeof lastTick != 'number') {\n        // entered into view\n        element.triggerHandler('scrollSpy:enter');\n      } // update tick id\n\n\n      element.data('scrollSpy:ticks', ticks);\n    }); // determine which elements are no longer in view\n\n    $.each(elementsInView, function (i, element) {\n      var lastTick = element.data('scrollSpy:ticks');\n\n      if (typeof lastTick == 'number' && lastTick !== ticks) {\n        // exited from view\n        element.triggerHandler('scrollSpy:exit');\n        element.data('scrollSpy:ticks', null);\n      }\n    }); // remember elements in view for next tick\n\n    elementsInView = intersections;\n  }\n  /**\r\n   * Called when window is resized\r\n  */\n\n\n  function onWinSize() {\n    jWindow.trigger('scrollSpy:winSize');\n  }\n  /**\r\n   * Enables ScrollSpy using a selector\r\n   * @param {jQuery|string} selector  The elements collection, or a selector\r\n   * @param {Object=} options\tOptional.\r\n         throttle : number -> scrollspy throttling. Default: 100 ms\r\n         offsetTop : number -> offset from top. Default: 0\r\n         offsetRight : number -> offset from right. Default: 0\r\n         offsetBottom : number -> offset from bottom. Default: 0\r\n         offsetLeft : number -> offset from left. Default: 0\r\n  \t\t\tactiveClass : string -> Class name to be added to the active link. Default: active\r\n   * @returns {jQuery}\r\n   */\n\n\n  $.scrollSpy = function (selector, options) {\n    var defaults = {\n      throttle: 100,\n      scrollOffset: 200,\n      // offset - 200 allows elements near bottom of page to scroll\n      activeClass: 'active',\n      getActiveElement: function getActiveElement(id) {\n        return 'a[href=\"#' + id + '\"]';\n      }\n    };\n    options = $.extend(defaults, options);\n    var visible = [];\n    selector = $(selector);\n    selector.each(function (i, element) {\n      elements.push($(element));\n      $(element).data(\"scrollSpy:id\", i); // Smooth scroll to section\n\n      $('a[href=\"#' + $(element).attr('id') + '\"]').click(function (e) {\n        e.preventDefault();\n        var offset = $(Materialize.escapeHash(this.hash)).offset().top + 1;\n        $('html, body').animate({\n          scrollTop: offset - options.scrollOffset\n        }, {\n          duration: 400,\n          queue: false,\n          easing: 'easeOutCubic'\n        });\n      });\n    });\n    offset.top = options.offsetTop || 0;\n    offset.right = options.offsetRight || 0;\n    offset.bottom = options.offsetBottom || 0;\n    offset.left = options.offsetLeft || 0;\n    var throttledScroll = Materialize.throttle(function () {\n      onScroll(options.scrollOffset);\n    }, options.throttle || 100);\n\n    var readyScroll = function readyScroll() {\n      $(document).ready(throttledScroll);\n    };\n\n    if (!isSpying) {\n      jWindow.on('scroll', readyScroll);\n      jWindow.on('resize', readyScroll);\n      isSpying = true;\n    } // perform a scan once, after current execution context, and after dom is ready\n\n\n    setTimeout(readyScroll, 0);\n    selector.on('scrollSpy:enter', function () {\n      visible = $.grep(visible, function (value) {\n        return value.height() != 0;\n      });\n      var $this = $(this);\n\n      if (visible[0]) {\n        $(options.getActiveElement(visible[0].attr('id'))).removeClass(options.activeClass);\n\n        if ($this.data('scrollSpy:id') < visible[0].data('scrollSpy:id')) {\n          visible.unshift($(this));\n        } else {\n          visible.push($(this));\n        }\n      } else {\n        visible.push($(this));\n      }\n\n      $(options.getActiveElement(visible[0].attr('id'))).addClass(options.activeClass);\n    });\n    selector.on('scrollSpy:exit', function () {\n      visible = $.grep(visible, function (value) {\n        return value.height() != 0;\n      });\n\n      if (visible[0]) {\n        $(options.getActiveElement(visible[0].attr('id'))).removeClass(options.activeClass);\n        var $this = $(this);\n        visible = $.grep(visible, function (value) {\n          return value.attr('id') != $this.attr('id');\n        });\n\n        if (visible[0]) {\n          // Check if empty\n          $(options.getActiveElement(visible[0].attr('id'))).addClass(options.activeClass);\n        }\n      }\n    });\n    return selector;\n  };\n  /**\r\n   * Listen for window resize events\r\n   * @param {Object=} options\t\t\t\t\t\tOptional. Set { throttle: number } to change throttling. Default: 100 ms\r\n   * @returns {jQuery}\t\t$(window)\r\n   */\n\n\n  $.winSizeSpy = function (options) {\n    $.winSizeSpy = function () {\n      return jWindow;\n    }; // lock from multiple calls\n\n\n    options = options || {\n      throttle: 100\n    };\n    return jWindow.on('resize', Materialize.throttle(onWinSize, options.throttle || 100));\n  };\n  /**\r\n   * Enables ScrollSpy on a collection of elements\r\n   * e.g. $('.scrollSpy').scrollSpy()\r\n   * @param {Object=} options\tOptional.\r\n  \t\t\t\t\t\t\t\t\t\tthrottle : number -> scrollspy throttling. Default: 100 ms\r\n  \t\t\t\t\t\t\t\t\t\toffsetTop : number -> offset from top. Default: 0\r\n  \t\t\t\t\t\t\t\t\t\toffsetRight : number -> offset from right. Default: 0\r\n  \t\t\t\t\t\t\t\t\t\toffsetBottom : number -> offset from bottom. Default: 0\r\n  \t\t\t\t\t\t\t\t\t\toffsetLeft : number -> offset from left. Default: 0\r\n   * @returns {jQuery}\r\n   */\n\n\n  $.fn.scrollSpy = function (options) {\n    return $.scrollSpy($(this), options);\n  };\n})(jQuery);\n\n;\n\n(function ($) {\n  $(document).ready(function () {\n    // Function to update labels of text fields\n    Materialize.updateTextFields = function () {\n      var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea';\n      $(input_selector).each(function (index, element) {\n        var $this = $(this);\n\n        if ($(element).val().length > 0 || $(element).is(':focus') || element.autofocus || $this.attr('placeholder') !== undefined) {\n          $this.siblings('label').addClass('active');\n        } else if ($(element)[0].validity) {\n          $this.siblings('label').toggleClass('active', $(element)[0].validity.badInput === true);\n        } else {\n          $this.siblings('label').removeClass('active');\n        }\n      });\n    }; // Text based inputs\n\n\n    var input_selector = 'input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea'; // Add active if form auto complete\n\n    $(document).on('change', input_selector, function () {\n      if ($(this).val().length !== 0 || $(this).attr('placeholder') !== undefined) {\n        $(this).siblings('label').addClass('active');\n      }\n\n      validate_field($(this));\n    }); // Add active if input element has been pre-populated on document ready\n\n    $(document).ready(function () {\n      Materialize.updateTextFields();\n    }); // HTML DOM FORM RESET handling\n\n    $(document).on('reset', function (e) {\n      var formReset = $(e.target);\n\n      if (formReset.is('form')) {\n        formReset.find(input_selector).removeClass('valid').removeClass('invalid');\n        formReset.find(input_selector).each(function () {\n          if ($(this).attr('value') === '') {\n            $(this).siblings('label').removeClass('active');\n          }\n        }); // Reset select\n\n        formReset.find('select.initialized').each(function () {\n          var reset_text = formReset.find('option[selected]').text();\n          formReset.siblings('input.select-dropdown').val(reset_text);\n        });\n      }\n    }); // Add active when element has focus\n\n    $(document).on('focus', input_selector, function () {\n      $(this).siblings('label, .prefix').addClass('active');\n    });\n    $(document).on('blur', input_selector, function () {\n      var $inputElement = $(this);\n      var selector = \".prefix\";\n\n      if ($inputElement.val().length === 0 && $inputElement[0].validity.badInput !== true && $inputElement.attr('placeholder') === undefined) {\n        selector += \", label\";\n      }\n\n      $inputElement.siblings(selector).removeClass('active');\n      validate_field($inputElement);\n    });\n\n    window.validate_field = function (object) {\n      var hasLength = object.attr('data-length') !== undefined;\n      var lenAttr = parseInt(object.attr('data-length'));\n      var len = object.val().length;\n\n      if (object.val().length === 0 && object[0].validity.badInput === false && !object.is(':required')) {\n        if (object.hasClass('validate')) {\n          object.removeClass('valid');\n          object.removeClass('invalid');\n        }\n      } else {\n        if (object.hasClass('validate')) {\n          // Check for character counter attributes\n          if (object.is(':valid') && hasLength && len <= lenAttr || object.is(':valid') && !hasLength) {\n            object.removeClass('invalid');\n            object.addClass('valid');\n          } else {\n            object.removeClass('valid');\n            object.addClass('invalid');\n          }\n        }\n      }\n    }; // Radio and Checkbox focus class\n\n\n    var radio_checkbox = 'input[type=radio], input[type=checkbox]';\n    $(document).on('keyup.radio', radio_checkbox, function (e) {\n      // TAB, check if tabbing to radio or checkbox.\n      if (e.which === 9) {\n        $(this).addClass('tabbed');\n        var $this = $(this);\n        $this.one('blur', function (e) {\n          $(this).removeClass('tabbed');\n        });\n        return;\n      }\n    }); // Textarea Auto Resize\n\n    var hiddenDiv = $('.hiddendiv').first();\n\n    if (!hiddenDiv.length) {\n      hiddenDiv = $('<div class=\"hiddendiv common\"></div>');\n      $('body').append(hiddenDiv);\n    }\n\n    var text_area_selector = '.materialize-textarea';\n\n    function textareaAutoResize($textarea) {\n      // Set font properties of hiddenDiv\n      var fontFamily = $textarea.css('font-family');\n      var fontSize = $textarea.css('font-size');\n      var lineHeight = $textarea.css('line-height');\n      var padding = $textarea.css('padding');\n\n      if (fontSize) {\n        hiddenDiv.css('font-size', fontSize);\n      }\n\n      if (fontFamily) {\n        hiddenDiv.css('font-family', fontFamily);\n      }\n\n      if (lineHeight) {\n        hiddenDiv.css('line-height', lineHeight);\n      }\n\n      if (padding) {\n        hiddenDiv.css('padding', padding);\n      } // Set original-height, if none\n\n\n      if (!$textarea.data('original-height')) {\n        $textarea.data('original-height', $textarea.height());\n      }\n\n      if ($textarea.attr('wrap') === 'off') {\n        hiddenDiv.css('overflow-wrap', 'normal').css('white-space', 'pre');\n      }\n\n      hiddenDiv.text($textarea.val() + '\\n');\n      var content = hiddenDiv.html().replace(/\\n/g, '<br>');\n      hiddenDiv.html(content); // When textarea is hidden, width goes crazy.\n      // Approximate with half of window size\n\n      if ($textarea.is(':visible')) {\n        hiddenDiv.css('width', $textarea.width());\n      } else {\n        hiddenDiv.css('width', $(window).width() / 2);\n      }\n      /**\r\n       * Resize if the new height is greater than the\r\n       * original height of the textarea\r\n       */\n\n\n      if ($textarea.data('original-height') <= hiddenDiv.height()) {\n        $textarea.css('height', hiddenDiv.height());\n      } else if ($textarea.val().length < $textarea.data('previous-length')) {\n        /**\r\n         * In case the new height is less than original height, it\r\n         * means the textarea has less text than before\r\n         * So we set the height to the original one\r\n         */\n        $textarea.css('height', $textarea.data('original-height'));\n      }\n\n      $textarea.data('previous-length', $textarea.val().length);\n    }\n\n    $(text_area_selector).each(function () {\n      var $textarea = $(this);\n      /**\r\n       * Instead of resizing textarea on document load,\r\n       * store the original height and the original length\r\n       */\n\n      $textarea.data('original-height', $textarea.height());\n      $textarea.data('previous-length', $textarea.val().length);\n    });\n    $('body').on('keyup keydown autoresize', text_area_selector, function () {\n      textareaAutoResize($(this));\n    }); // File Input Path\n\n    $(document).on('change', '.file-field input[type=\"file\"]', function () {\n      var file_field = $(this).closest('.file-field');\n      var path_input = file_field.find('input.file-path');\n      var files = $(this)[0].files;\n      var file_names = [];\n\n      for (var i = 0; i < files.length; i++) {\n        file_names.push(files[i].name);\n      }\n\n      path_input.val(file_names.join(\", \"));\n      path_input.trigger('change');\n    });\n    /****************\r\n    *  Range Input  *\r\n    ****************/\n\n    var range_type = 'input[type=range]';\n    var range_mousedown = false;\n    var left;\n    $(range_type).each(function () {\n      var thumb = $('<span class=\"thumb\"><span class=\"value\"></span></span>');\n      $(this).after(thumb);\n    });\n\n    var showRangeBubble = function showRangeBubble(thumb) {\n      var paddingLeft = parseInt(thumb.parent().css('padding-left'));\n      var marginLeft = -7 + paddingLeft + 'px';\n      thumb.velocity({\n        height: \"30px\",\n        width: \"30px\",\n        top: \"-30px\",\n        marginLeft: marginLeft\n      }, {\n        duration: 300,\n        easing: 'easeOutExpo'\n      });\n    };\n\n    var calcRangeOffset = function calcRangeOffset(range) {\n      var width = range.width() - 15;\n      var max = parseFloat(range.attr('max'));\n      var min = parseFloat(range.attr('min'));\n      var percent = (parseFloat(range.val()) - min) / (max - min);\n      return percent * width;\n    };\n\n    var range_wrapper = '.range-field';\n    $(document).on('change', range_type, function (e) {\n      var thumb = $(this).siblings('.thumb');\n      thumb.find('.value').html($(this).val());\n\n      if (!thumb.hasClass('active')) {\n        showRangeBubble(thumb);\n      }\n\n      var offsetLeft = calcRangeOffset($(this));\n      thumb.addClass('active').css('left', offsetLeft);\n    });\n    $(document).on('mousedown touchstart', range_type, function (e) {\n      var thumb = $(this).siblings('.thumb'); // If thumb indicator does not exist yet, create it\n\n      if (thumb.length <= 0) {\n        thumb = $('<span class=\"thumb\"><span class=\"value\"></span></span>');\n        $(this).after(thumb);\n      } // Set indicator value\n\n\n      thumb.find('.value').html($(this).val());\n      range_mousedown = true;\n      $(this).addClass('active');\n\n      if (!thumb.hasClass('active')) {\n        showRangeBubble(thumb);\n      }\n\n      if (e.type !== 'input') {\n        var offsetLeft = calcRangeOffset($(this));\n        thumb.addClass('active').css('left', offsetLeft);\n      }\n    });\n    $(document).on('mouseup touchend', range_wrapper, function () {\n      range_mousedown = false;\n      $(this).removeClass('active');\n    });\n    $(document).on('input mousemove touchmove', range_wrapper, function (e) {\n      var thumb = $(this).children('.thumb');\n      var left;\n      var input = $(this).find(range_type);\n\n      if (range_mousedown) {\n        if (!thumb.hasClass('active')) {\n          showRangeBubble(thumb);\n        }\n\n        var offsetLeft = calcRangeOffset(input);\n        thumb.addClass('active').css('left', offsetLeft);\n        thumb.find('.value').html(thumb.siblings(range_type).val());\n      }\n    });\n    $(document).on('mouseout touchleave', range_wrapper, function () {\n      if (!range_mousedown) {\n        var thumb = $(this).children('.thumb');\n        var paddingLeft = parseInt($(this).css('padding-left'));\n        var marginLeft = 7 + paddingLeft + 'px';\n\n        if (thumb.hasClass('active')) {\n          thumb.velocity({\n            height: '0',\n            width: '0',\n            top: '10px',\n            marginLeft: marginLeft\n          }, {\n            duration: 100\n          });\n        }\n\n        thumb.removeClass('active');\n      }\n    });\n    /**************************\r\n     * Auto complete plugin  *\r\n     *************************/\n\n    $.fn.autocomplete = function (options) {\n      // Defaults\n      var defaults = {\n        data: {},\n        limit: Infinity,\n        onAutocomplete: null,\n        minLength: 1\n      };\n      options = $.extend(defaults, options);\n      return this.each(function () {\n        var $input = $(this);\n        var data = options.data,\n            count = 0,\n            activeIndex = -1,\n            oldVal,\n            $inputDiv = $input.closest('.input-field'); // Div to append on\n        // Check if data isn't empty\n\n        if (!$.isEmptyObject(data)) {\n          var $autocomplete = $('<ul class=\"autocomplete-content dropdown-content\"></ul>');\n          var $oldAutocomplete; // Append autocomplete element.\n          // Prevent double structure init.\n\n          if ($inputDiv.length) {\n            $oldAutocomplete = $inputDiv.children('.autocomplete-content.dropdown-content').first();\n\n            if (!$oldAutocomplete.length) {\n              $inputDiv.append($autocomplete); // Set ul in body\n            }\n          } else {\n            $oldAutocomplete = $input.next('.autocomplete-content.dropdown-content');\n\n            if (!$oldAutocomplete.length) {\n              $input.after($autocomplete);\n            }\n          }\n\n          if ($oldAutocomplete.length) {\n            $autocomplete = $oldAutocomplete;\n          } // Highlight partial match.\n\n\n          var highlight = function highlight(string, $el) {\n            var img = $el.find('img');\n            var matchStart = $el.text().toLowerCase().indexOf(\"\" + string.toLowerCase() + \"\"),\n                matchEnd = matchStart + string.length - 1,\n                beforeMatch = $el.text().slice(0, matchStart),\n                matchText = $el.text().slice(matchStart, matchEnd + 1),\n                afterMatch = $el.text().slice(matchEnd + 1);\n            $el.html(\"<span>\" + beforeMatch + \"<span class='highlight'>\" + matchText + \"</span>\" + afterMatch + \"</span>\");\n\n            if (img.length) {\n              $el.prepend(img);\n            }\n          }; // Reset current element position\n\n\n          var resetCurrentElement = function resetCurrentElement() {\n            activeIndex = -1;\n            $autocomplete.find('.active').removeClass('active');\n          }; // Remove autocomplete elements\n\n\n          var removeAutocomplete = function removeAutocomplete() {\n            $autocomplete.empty();\n            resetCurrentElement();\n            oldVal = undefined;\n          };\n\n          $input.off('blur.autocomplete').on('blur.autocomplete', function () {\n            removeAutocomplete();\n          }); // Perform search\n\n          $input.off('keyup.autocomplete focus.autocomplete').on('keyup.autocomplete focus.autocomplete', function (e) {\n            // Reset count.\n            count = 0;\n            var val = $input.val().toLowerCase(); // Don't capture enter or arrow key usage.\n\n            if (e.which === 13 || e.which === 38 || e.which === 40) {\n              return;\n            } // Check if the input isn't empty\n\n\n            if (oldVal !== val) {\n              removeAutocomplete();\n\n              if (val.length >= options.minLength) {\n                for (var key in data) {\n                  if (data.hasOwnProperty(key) && key.toLowerCase().indexOf(val) !== -1) {\n                    // Break if past limit\n                    if (count >= options.limit) {\n                      break;\n                    }\n\n                    var autocompleteOption = $('<li></li>');\n\n                    if (!!data[key]) {\n                      autocompleteOption.append('<img src=\"' + data[key] + '\" class=\"right circle\"><span>' + key + '</span>');\n                    } else {\n                      autocompleteOption.append('<span>' + key + '</span>');\n                    }\n\n                    $autocomplete.append(autocompleteOption);\n                    highlight(val, autocompleteOption);\n                    count++;\n                  }\n                }\n              }\n            } // Update oldVal\n\n\n            oldVal = val;\n          });\n          $input.off('keydown.autocomplete').on('keydown.autocomplete', function (e) {\n            // Arrow keys and enter key usage\n            var keyCode = e.which,\n                liElement,\n                numItems = $autocomplete.children('li').length,\n                $active = $autocomplete.children('.active').first(); // select element on Enter\n\n            if (keyCode === 13 && activeIndex >= 0) {\n              liElement = $autocomplete.children('li').eq(activeIndex);\n\n              if (liElement.length) {\n                liElement.trigger('mousedown.autocomplete');\n                e.preventDefault();\n              }\n\n              return;\n            } // Capture up and down key\n\n\n            if (keyCode === 38 || keyCode === 40) {\n              e.preventDefault();\n\n              if (keyCode === 38 && activeIndex > 0) {\n                activeIndex--;\n              }\n\n              if (keyCode === 40 && activeIndex < numItems - 1) {\n                activeIndex++;\n              }\n\n              $active.removeClass('active');\n\n              if (activeIndex >= 0) {\n                $autocomplete.children('li').eq(activeIndex).addClass('active');\n              }\n            }\n          }); // Set input value\n\n          $autocomplete.off('mousedown.autocomplete touchstart.autocomplete').on('mousedown.autocomplete touchstart.autocomplete', 'li', function () {\n            var text = $(this).text().trim();\n            $input.val(text);\n            $input.trigger('change');\n            removeAutocomplete(); // Handle onAutocomplete callback.\n\n            if (typeof options.onAutocomplete === \"function\") {\n              options.onAutocomplete.call(this, text);\n            }\n          }); // Empty data\n        } else {\n          $input.off('keyup.autocomplete focus.autocomplete');\n        }\n      });\n    };\n  }); // End of $(document).ready\n\n  /*******************\r\n   *  Select Plugin  *\r\n   ******************/\n\n  $.fn.material_select = function (callback) {\n    $(this).each(function () {\n      var $select = $(this);\n\n      if ($select.hasClass('browser-default')) {\n        return; // Continue to next (return false breaks out of entire loop)\n      }\n\n      var multiple = $select.attr('multiple') ? true : false,\n          lastID = $select.attr('data-select-id'); // Tear down structure if Select needs to be rebuilt\n\n      if (lastID) {\n        $select.parent().find('span.caret').remove();\n        $select.parent().find('input').remove();\n        $select.unwrap();\n        $('ul#select-options-' + lastID).remove();\n      } // If destroying the select, remove the selelct-id and reset it to it's uninitialized state.\n\n\n      if (callback === 'destroy') {\n        $select.removeAttr('data-select-id').removeClass('initialized');\n        $(window).off('click.select');\n        return;\n      }\n\n      var uniqueID = Materialize.guid();\n      $select.attr('data-select-id', uniqueID);\n      var wrapper = $('<div class=\"select-wrapper\"></div>');\n      wrapper.addClass($select.attr('class'));\n      if ($select.is(':disabled')) wrapper.addClass('disabled');\n      var options = $('<ul id=\"select-options-' + uniqueID + '\" class=\"dropdown-content select-dropdown ' + (multiple ? 'multiple-select-dropdown' : '') + '\"></ul>'),\n          selectChildren = $select.children('option, optgroup'),\n          valuesSelected = [],\n          optionsHover = false;\n      var label = $select.find('option:selected').html() || $select.find('option:first').html() || \"\"; // Function that renders and appends the option taking into\n      // account type and possible image icon.\n\n      var appendOptionWithIcon = function appendOptionWithIcon(select, option, type) {\n        // Add disabled attr if disabled\n        var disabledClass = option.is(':disabled') ? 'disabled ' : '';\n        var optgroupClass = type === 'optgroup-option' ? 'optgroup-option ' : '';\n        var multipleCheckbox = multiple ? '<input type=\"checkbox\"' + disabledClass + '/><label></label>' : ''; // add icons\n\n        var icon_url = option.data('icon');\n        var classes = option.attr('class');\n\n        if (!!icon_url) {\n          var classString = '';\n          if (!!classes) classString = ' class=\"' + classes + '\"'; // Check for multiple type.\n\n          options.append($('<li class=\"' + disabledClass + optgroupClass + '\"><img alt=\"\" src=\"' + icon_url + '\"' + classString + '><span>' + multipleCheckbox + option.html() + '</span></li>'));\n          return true;\n        } // Check for multiple type.\n\n\n        options.append($('<li class=\"' + disabledClass + optgroupClass + '\"><span>' + multipleCheckbox + option.html() + '</span></li>'));\n      };\n      /* Create dropdown structure. */\n\n\n      if (selectChildren.length) {\n        selectChildren.each(function () {\n          if ($(this).is('option')) {\n            // Direct descendant option.\n            if (multiple) {\n              appendOptionWithIcon($select, $(this), 'multiple');\n            } else {\n              appendOptionWithIcon($select, $(this));\n            }\n          } else if ($(this).is('optgroup')) {\n            // Optgroup.\n            var selectOptions = $(this).children('option');\n            options.append($('<li class=\"optgroup\"><span>' + $(this).attr('label') + '</span></li>'));\n            selectOptions.each(function () {\n              appendOptionWithIcon($select, $(this), 'optgroup-option');\n            });\n          }\n        });\n      }\n\n      options.find('li:not(.optgroup)').each(function (i) {\n        $(this).click(function (e) {\n          // Check if option element is disabled\n          if (!$(this).hasClass('disabled') && !$(this).hasClass('optgroup')) {\n            var selected = true;\n\n            if (multiple) {\n              $('input[type=\"checkbox\"]', this).prop('checked', function (i, v) {\n                return !v;\n              });\n              selected = toggleEntryFromArray(valuesSelected, i, $select);\n              $newSelect.trigger('focus');\n            } else {\n              options.find('li').removeClass('active');\n              $(this).toggleClass('active');\n              $newSelect.val($(this).text());\n            }\n\n            activateOption(options, $(this));\n            $select.find('option').eq(i).prop('selected', selected); // Trigger onchange() event\n\n            $select.trigger('change');\n            if (typeof callback !== 'undefined') callback();\n          }\n\n          e.stopPropagation();\n        });\n      }); // Wrap Elements\n\n      $select.wrap(wrapper); // Add Select Display Element\n\n      var dropdownIcon = $('<span class=\"caret\">&#9660;</span>'); // escape double quotes\n\n      var sanitizedLabelHtml = label.replace(/\"/g, '&quot;');\n      var $newSelect = $('<input type=\"text\" class=\"select-dropdown\" readonly=\"true\" ' + ($select.is(':disabled') ? 'disabled' : '') + ' data-activates=\"select-options-' + uniqueID + '\" value=\"' + sanitizedLabelHtml + '\"/>');\n      $select.before($newSelect);\n      $newSelect.before(dropdownIcon);\n      $newSelect.after(options); // Check if section element is disabled\n\n      if (!$select.is(':disabled')) {\n        $newSelect.dropdown({\n          'hover': false\n        });\n      } // Copy tabindex\n\n\n      if ($select.attr('tabindex')) {\n        $($newSelect[0]).attr('tabindex', $select.attr('tabindex'));\n      }\n\n      $select.addClass('initialized');\n      $newSelect.on({\n        'focus': function focus() {\n          if ($('ul.select-dropdown').not(options[0]).is(':visible')) {\n            $('input.select-dropdown').trigger('close');\n            $(window).off('click.select');\n          }\n\n          if (!options.is(':visible')) {\n            $(this).trigger('open', ['focus']);\n            var label = $(this).val();\n\n            if (multiple && label.indexOf(',') >= 0) {\n              label = label.split(',')[0];\n            }\n\n            var selectedOption = options.find('li').filter(function () {\n              return $(this).text().toLowerCase() === label.toLowerCase();\n            })[0];\n            activateOption(options, selectedOption, true);\n            $(window).off('click.select').on('click.select', function () {\n              multiple && (optionsHover || $newSelect.trigger('close'));\n              $(window).off('click.select');\n            });\n          }\n        },\n        'click': function click(e) {\n          e.stopPropagation();\n        }\n      });\n      $newSelect.on('blur', function () {\n        if (!multiple) {\n          $(this).trigger('close');\n          $(window).off('click.select');\n        }\n\n        options.find('li.selected').removeClass('selected');\n      });\n      options.hover(function () {\n        optionsHover = true;\n      }, function () {\n        optionsHover = false;\n      }); // Add initial multiple selections.\n\n      if (multiple) {\n        $select.find(\"option:selected:not(:disabled)\").each(function () {\n          var index = this.index;\n          toggleEntryFromArray(valuesSelected, index, $select);\n          options.find(\"li:not(.optgroup)\").eq(index).find(\":checkbox\").prop(\"checked\", true);\n        });\n      }\n      /**\r\n       * Make option as selected and scroll to selected position\r\n       * @param {jQuery} collection  Select options jQuery element\r\n       * @param {Element} newOption  element of the new option\r\n       * @param {Boolean} firstActivation  If on first activation of select\r\n       */\n\n\n      var activateOption = function activateOption(collection, newOption, firstActivation) {\n        if (newOption) {\n          collection.find('li.selected').removeClass('selected');\n          var option = $(newOption);\n          option.addClass('selected');\n\n          if (!multiple || !!firstActivation) {\n            options.scrollTo(option);\n          }\n        }\n      }; // Allow user to search by typing\n      // this array is cleared after 1 second\n\n\n      var filterQuery = [],\n          onKeyDown = function onKeyDown(e) {\n        // TAB - switch to another input\n        if (e.which == 9) {\n          $newSelect.trigger('close');\n          return;\n        } // ARROW DOWN WHEN SELECT IS CLOSED - open select options\n\n\n        if (e.which == 40 && !options.is(':visible')) {\n          $newSelect.trigger('open');\n          return;\n        } // ENTER WHEN SELECT IS CLOSED - submit form\n\n\n        if (e.which == 13 && !options.is(':visible')) {\n          return;\n        }\n\n        e.preventDefault(); // CASE WHEN USER TYPE LETTERS\n\n        var letter = String.fromCharCode(e.which).toLowerCase(),\n            nonLetters = [9, 13, 27, 38, 40];\n\n        if (letter && nonLetters.indexOf(e.which) === -1) {\n          filterQuery.push(letter);\n          var string = filterQuery.join(''),\n              newOption = options.find('li').filter(function () {\n            return $(this).text().toLowerCase().indexOf(string) === 0;\n          })[0];\n\n          if (newOption) {\n            activateOption(options, newOption);\n          }\n        } // ENTER - select option and close when select options are opened\n\n\n        if (e.which == 13) {\n          var activeOption = options.find('li.selected:not(.disabled)')[0];\n\n          if (activeOption) {\n            $(activeOption).trigger('click');\n\n            if (!multiple) {\n              $newSelect.trigger('close');\n            }\n          }\n        } // ARROW DOWN - move to next not disabled option\n\n\n        if (e.which == 40) {\n          if (options.find('li.selected').length) {\n            newOption = options.find('li.selected').next('li:not(.disabled)')[0];\n          } else {\n            newOption = options.find('li:not(.disabled)')[0];\n          }\n\n          activateOption(options, newOption);\n        } // ESC - close options\n\n\n        if (e.which == 27) {\n          $newSelect.trigger('close');\n        } // ARROW UP - move to previous not disabled option\n\n\n        if (e.which == 38) {\n          newOption = options.find('li.selected').prev('li:not(.disabled)')[0];\n          if (newOption) activateOption(options, newOption);\n        } // Automaticaly clean filter query so user can search again by starting letters\n\n\n        setTimeout(function () {\n          filterQuery = [];\n        }, 1000);\n      };\n\n      $newSelect.on('keydown', onKeyDown);\n    });\n\n    function toggleEntryFromArray(entriesArray, entryIndex, select) {\n      var index = entriesArray.indexOf(entryIndex),\n          notAdded = index === -1;\n\n      if (notAdded) {\n        entriesArray.push(entryIndex);\n      } else {\n        entriesArray.splice(index, 1);\n      }\n\n      select.siblings('ul.dropdown-content').find('li:not(.optgroup)').eq(entryIndex).toggleClass('active'); // use notAdded instead of true (to detect if the option is selected or not)\n\n      select.find('option').eq(entryIndex).prop('selected', notAdded);\n      setValueToInput(entriesArray, select);\n      return notAdded;\n    }\n\n    function setValueToInput(entriesArray, select) {\n      var value = '';\n\n      for (var i = 0, count = entriesArray.length; i < count; i++) {\n        var text = select.find('option').eq(entriesArray[i]).text();\n        i === 0 ? value += text : value += ', ' + text;\n      }\n\n      if (value === '') {\n        value = select.find('option:disabled').eq(0).text();\n      }\n\n      select.siblings('input.select-dropdown').val(value);\n    }\n  };\n})(jQuery);\n\n;\n\n(function ($) {\n  var methods = {\n    init: function init(options) {\n      var defaults = {\n        indicators: true,\n        height: 400,\n        transition: 500,\n        interval: 6000\n      };\n      options = $.extend(defaults, options);\n      return this.each(function () {\n        // For each slider, we want to keep track of\n        // which slide is active and its associated content\n        var $this = $(this);\n        var $slider = $this.find('ul.slides').first();\n        var $slides = $slider.find('> li');\n        var $active_index = $slider.find('.active').index();\n        var $active, $indicators, $interval;\n\n        if ($active_index != -1) {\n          $active = $slides.eq($active_index);\n        } // Transitions the caption depending on alignment\n\n\n        function captionTransition(caption, duration) {\n          if (caption.hasClass(\"center-align\")) {\n            caption.velocity({\n              opacity: 0,\n              translateY: -100\n            }, {\n              duration: duration,\n              queue: false\n            });\n          } else if (caption.hasClass(\"right-align\")) {\n            caption.velocity({\n              opacity: 0,\n              translateX: 100\n            }, {\n              duration: duration,\n              queue: false\n            });\n          } else if (caption.hasClass(\"left-align\")) {\n            caption.velocity({\n              opacity: 0,\n              translateX: -100\n            }, {\n              duration: duration,\n              queue: false\n            });\n          }\n        } // This function will transition the slide to any index of the next slide\n\n\n        function moveToSlide(index) {\n          // Wrap around indices.\n          if (index >= $slides.length) index = 0;else if (index < 0) index = $slides.length - 1;\n          $active_index = $slider.find('.active').index(); // Only do if index changes\n\n          if ($active_index != index) {\n            $active = $slides.eq($active_index);\n            $caption = $active.find('.caption');\n            $active.removeClass('active');\n            $active.velocity({\n              opacity: 0\n            }, {\n              duration: options.transition,\n              queue: false,\n              easing: 'easeOutQuad',\n              complete: function complete() {\n                $slides.not('.active').velocity({\n                  opacity: 0,\n                  translateX: 0,\n                  translateY: 0\n                }, {\n                  duration: 0,\n                  queue: false\n                });\n              }\n            });\n            captionTransition($caption, options.transition); // Update indicators\n\n            if (options.indicators) {\n              $indicators.eq($active_index).removeClass('active');\n            }\n\n            $slides.eq(index).velocity({\n              opacity: 1\n            }, {\n              duration: options.transition,\n              queue: false,\n              easing: 'easeOutQuad'\n            });\n            $slides.eq(index).find('.caption').velocity({\n              opacity: 1,\n              translateX: 0,\n              translateY: 0\n            }, {\n              duration: options.transition,\n              delay: options.transition,\n              queue: false,\n              easing: 'easeOutQuad'\n            });\n            $slides.eq(index).addClass('active'); // Update indicators\n\n            if (options.indicators) {\n              $indicators.eq(index).addClass('active');\n            }\n          }\n        } // Set height of slider\n        // If fullscreen, do nothing\n\n\n        if (!$this.hasClass('fullscreen')) {\n          if (options.indicators) {\n            // Add height if indicators are present\n            $this.height(options.height + 40);\n          } else {\n            $this.height(options.height);\n          }\n\n          $slider.height(options.height);\n        } // Set initial positions of captions\n\n\n        $slides.find('.caption').each(function () {\n          captionTransition($(this), 0);\n        }); // Move img src into background-image\n\n        $slides.find('img').each(function () {\n          var placeholderBase64 = 'data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';\n\n          if ($(this).attr('src') !== placeholderBase64) {\n            $(this).css('background-image', 'url(\"' + $(this).attr('src') + '\")');\n            $(this).attr('src', placeholderBase64);\n          }\n        }); // dynamically add indicators\n\n        if (options.indicators) {\n          $indicators = $('<ul class=\"indicators\"></ul>');\n          $slides.each(function (index) {\n            var $indicator = $('<li class=\"indicator-item\"></li>'); // Handle clicks on indicators\n\n            $indicator.click(function () {\n              var $parent = $slider.parent();\n              var curr_index = $parent.find($(this)).index();\n              moveToSlide(curr_index); // reset interval\n\n              clearInterval($interval);\n              $interval = setInterval(function () {\n                $active_index = $slider.find('.active').index();\n                if ($slides.length == $active_index + 1) $active_index = 0; // loop to start\n                else $active_index += 1;\n                moveToSlide($active_index);\n              }, options.transition + options.interval);\n            });\n            $indicators.append($indicator);\n          });\n          $this.append($indicators);\n          $indicators = $this.find('ul.indicators').find('li.indicator-item');\n        }\n\n        if ($active) {\n          $active.show();\n        } else {\n          $slides.first().addClass('active').velocity({\n            opacity: 1\n          }, {\n            duration: options.transition,\n            queue: false,\n            easing: 'easeOutQuad'\n          });\n          $active_index = 0;\n          $active = $slides.eq($active_index); // Update indicators\n\n          if (options.indicators) {\n            $indicators.eq($active_index).addClass('active');\n          }\n        } // Adjust height to current slide\n\n\n        $active.find('img').each(function () {\n          $active.find('.caption').velocity({\n            opacity: 1,\n            translateX: 0,\n            translateY: 0\n          }, {\n            duration: options.transition,\n            queue: false,\n            easing: 'easeOutQuad'\n          });\n        }); // auto scroll\n\n        $interval = setInterval(function () {\n          $active_index = $slider.find('.active').index();\n          moveToSlide($active_index + 1);\n        }, options.transition + options.interval); // HammerJS, Swipe navigation\n        // Touch Event\n\n        var panning = false;\n        var swipeLeft = false;\n        var swipeRight = false;\n        $this.hammer({\n          prevent_default: false\n        }).on('pan', function (e) {\n          if (e.gesture.pointerType === \"touch\") {\n            // reset interval\n            clearInterval($interval);\n            var direction = e.gesture.direction;\n            var x = e.gesture.deltaX;\n            var velocityX = e.gesture.velocityX;\n            var velocityY = e.gesture.velocityY;\n            $curr_slide = $slider.find('.active');\n\n            if (Math.abs(velocityX) > Math.abs(velocityY)) {\n              $curr_slide.velocity({\n                translateX: x\n              }, {\n                duration: 50,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            } // Swipe Left\n\n\n            if (direction === 4 && (x > $this.innerWidth() / 2 || velocityX < -0.65)) {\n              swipeRight = true;\n            } // Swipe Right\n            else if (direction === 2 && (x < -1 * $this.innerWidth() / 2 || velocityX > 0.65)) {\n                swipeLeft = true;\n              } // Make Slide Behind active slide visible\n\n\n            var next_slide;\n\n            if (swipeLeft) {\n              next_slide = $curr_slide.next();\n\n              if (next_slide.length === 0) {\n                next_slide = $slides.first();\n              }\n\n              next_slide.velocity({\n                opacity: 1\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            }\n\n            if (swipeRight) {\n              next_slide = $curr_slide.prev();\n\n              if (next_slide.length === 0) {\n                next_slide = $slides.last();\n              }\n\n              next_slide.velocity({\n                opacity: 1\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            }\n          }\n        }).on('panend', function (e) {\n          if (e.gesture.pointerType === \"touch\") {\n            $curr_slide = $slider.find('.active');\n            panning = false;\n            curr_index = $slider.find('.active').index();\n\n            if (!swipeRight && !swipeLeft || $slides.length <= 1) {\n              // Return to original spot\n              $curr_slide.velocity({\n                translateX: 0\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad'\n              });\n            } else if (swipeLeft) {\n              moveToSlide(curr_index + 1);\n              $curr_slide.velocity({\n                translateX: -1 * $this.innerWidth()\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad',\n                complete: function complete() {\n                  $curr_slide.velocity({\n                    opacity: 0,\n                    translateX: 0\n                  }, {\n                    duration: 0,\n                    queue: false\n                  });\n                }\n              });\n            } else if (swipeRight) {\n              moveToSlide(curr_index - 1);\n              $curr_slide.velocity({\n                translateX: $this.innerWidth()\n              }, {\n                duration: 300,\n                queue: false,\n                easing: 'easeOutQuad',\n                complete: function complete() {\n                  $curr_slide.velocity({\n                    opacity: 0,\n                    translateX: 0\n                  }, {\n                    duration: 0,\n                    queue: false\n                  });\n                }\n              });\n            }\n\n            swipeLeft = false;\n            swipeRight = false; // Restart interval\n\n            clearInterval($interval);\n            $interval = setInterval(function () {\n              $active_index = $slider.find('.active').index();\n              if ($slides.length == $active_index + 1) $active_index = 0; // loop to start\n              else $active_index += 1;\n              moveToSlide($active_index);\n            }, options.transition + options.interval);\n          }\n        });\n        $this.on('sliderPause', function () {\n          clearInterval($interval);\n        });\n        $this.on('sliderStart', function () {\n          clearInterval($interval);\n          $interval = setInterval(function () {\n            $active_index = $slider.find('.active').index();\n            if ($slides.length == $active_index + 1) $active_index = 0; // loop to start\n            else $active_index += 1;\n            moveToSlide($active_index);\n          }, options.transition + options.interval);\n        });\n        $this.on('sliderNext', function () {\n          $active_index = $slider.find('.active').index();\n          moveToSlide($active_index + 1);\n        });\n        $this.on('sliderPrev', function () {\n          $active_index = $slider.find('.active').index();\n          moveToSlide($active_index - 1);\n        });\n      });\n    },\n    pause: function pause() {\n      $(this).trigger('sliderPause');\n    },\n    start: function start() {\n      $(this).trigger('sliderStart');\n    },\n    next: function next() {\n      $(this).trigger('sliderNext');\n    },\n    prev: function prev() {\n      $(this).trigger('sliderPrev');\n    }\n  };\n\n  $.fn.slider = function (methodOrOptions) {\n    if (methods[methodOrOptions]) {\n      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n      // Default to \"init\"\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tooltip');\n    }\n  }; // Plugin end\n\n})(jQuery);\n\n;\n\n(function ($) {\n  $(document).ready(function () {\n    $(document).on('click.card', '.card', function (e) {\n      if ($(this).find('> .card-reveal').length) {\n        var $card = $(e.target).closest('.card');\n\n        if ($card.data('initialOverflow') === undefined) {\n          $card.data('initialOverflow', $card.css('overflow') === undefined ? '' : $card.css('overflow'));\n        }\n\n        if ($(e.target).is($('.card-reveal .card-title')) || $(e.target).is($('.card-reveal .card-title i'))) {\n          // Make Reveal animate down and display none\n          $(this).find('.card-reveal').velocity({\n            translateY: 0\n          }, {\n            duration: 225,\n            queue: false,\n            easing: 'easeInOutQuad',\n            complete: function complete() {\n              $(this).css({\n                display: 'none'\n              });\n              $card.css('overflow', $card.data('initialOverflow'));\n            }\n          });\n        } else if ($(e.target).is($('.card .activator')) || $(e.target).is($('.card .activator i'))) {\n          $card.css('overflow', 'hidden');\n          $(this).find('.card-reveal').css({\n            display: 'block'\n          }).velocity(\"stop\", false).velocity({\n            translateY: '-100%'\n          }, {\n            duration: 300,\n            queue: false,\n            easing: 'easeInOutQuad'\n          });\n        }\n      }\n    });\n  });\n})(jQuery);\n\n;\n\n(function ($) {\n  var materialChipsDefaults = {\n    data: [],\n    placeholder: '',\n    secondaryPlaceholder: '',\n    autocompleteOptions: {}\n  };\n  $(document).ready(function () {\n    // Handle removal of static chips.\n    $(document).on('click', '.chip .close', function (e) {\n      var $chips = $(this).closest('.chips');\n\n      if ($chips.attr('data-initialized')) {\n        return;\n      }\n\n      $(this).closest('.chip').remove();\n    });\n  });\n\n  $.fn.material_chip = function (options) {\n    var self = this;\n    this.$el = $(this);\n    this.$document = $(document);\n    this.SELS = {\n      CHIPS: '.chips',\n      CHIP: '.chip',\n      INPUT: 'input',\n      DELETE: '.material-icons',\n      SELECTED_CHIP: '.selected'\n    };\n\n    if ('data' === options) {\n      return this.$el.data('chips');\n    }\n\n    var curr_options = $.extend({}, materialChipsDefaults, options);\n    self.hasAutocomplete = !$.isEmptyObject(curr_options.autocompleteOptions.data); // Initialize\n\n    this.init = function () {\n      var i = 0;\n      var chips;\n      self.$el.each(function () {\n        var $chips = $(this);\n        var chipId = Materialize.guid();\n        self.chipId = chipId;\n\n        if (!curr_options.data || !(curr_options.data instanceof Array)) {\n          curr_options.data = [];\n        }\n\n        $chips.data('chips', curr_options.data);\n        $chips.attr('data-index', i);\n        $chips.attr('data-initialized', true);\n\n        if (!$chips.hasClass(self.SELS.CHIPS)) {\n          $chips.addClass('chips');\n        }\n\n        self.chips($chips, chipId);\n        i++;\n      });\n    };\n\n    this.handleEvents = function () {\n      var SELS = self.SELS;\n      self.$document.off('click.chips-focus', SELS.CHIPS).on('click.chips-focus', SELS.CHIPS, function (e) {\n        $(e.target).find(SELS.INPUT).focus();\n      });\n      self.$document.off('click.chips-select', SELS.CHIP).on('click.chips-select', SELS.CHIP, function (e) {\n        var $chip = $(e.target);\n\n        if ($chip.length) {\n          var wasSelected = $chip.hasClass('selected');\n          var $chips = $chip.closest(SELS.CHIPS);\n          $(SELS.CHIP).removeClass('selected');\n\n          if (!wasSelected) {\n            self.selectChip($chip.index(), $chips);\n          }\n        }\n      });\n      self.$document.off('keydown.chips').on('keydown.chips', function (e) {\n        if ($(e.target).is('input, textarea')) {\n          return;\n        } // delete\n\n\n        var $chip = self.$document.find(SELS.CHIP + SELS.SELECTED_CHIP);\n        var $chips = $chip.closest(SELS.CHIPS);\n        var length = $chip.siblings(SELS.CHIP).length;\n        var index;\n\n        if (!$chip.length) {\n          return;\n        }\n\n        if (e.which === 8 || e.which === 46) {\n          e.preventDefault();\n          index = $chip.index();\n          self.deleteChip(index, $chips);\n          var selectIndex = null;\n\n          if (index + 1 < length) {\n            selectIndex = index;\n          } else if (index === length || index + 1 === length) {\n            selectIndex = length - 1;\n          }\n\n          if (selectIndex < 0) selectIndex = null;\n\n          if (null !== selectIndex) {\n            self.selectChip(selectIndex, $chips);\n          }\n\n          if (!length) $chips.find('input').focus(); // left\n        } else if (e.which === 37) {\n          index = $chip.index() - 1;\n\n          if (index < 0) {\n            return;\n          }\n\n          $(SELS.CHIP).removeClass('selected');\n          self.selectChip(index, $chips); // right\n        } else if (e.which === 39) {\n          index = $chip.index() + 1;\n          $(SELS.CHIP).removeClass('selected');\n\n          if (index > length) {\n            $chips.find('input').focus();\n            return;\n          }\n\n          self.selectChip(index, $chips);\n        }\n      });\n      self.$document.off('focusin.chips', SELS.CHIPS + ' ' + SELS.INPUT).on('focusin.chips', SELS.CHIPS + ' ' + SELS.INPUT, function (e) {\n        var $currChips = $(e.target).closest(SELS.CHIPS);\n        $currChips.addClass('focus');\n        $currChips.siblings('label, .prefix').addClass('active');\n        $(SELS.CHIP).removeClass('selected');\n      });\n      self.$document.off('focusout.chips', SELS.CHIPS + ' ' + SELS.INPUT).on('focusout.chips', SELS.CHIPS + ' ' + SELS.INPUT, function (e) {\n        var $currChips = $(e.target).closest(SELS.CHIPS);\n        $currChips.removeClass('focus'); // Remove active if empty\n\n        if ($currChips.data('chips') === undefined || !$currChips.data('chips').length) {\n          $currChips.siblings('label').removeClass('active');\n        }\n\n        $currChips.siblings('.prefix').removeClass('active');\n      });\n      self.$document.off('keydown.chips-add', SELS.CHIPS + ' ' + SELS.INPUT).on('keydown.chips-add', SELS.CHIPS + ' ' + SELS.INPUT, function (e) {\n        var $target = $(e.target);\n        var $chips = $target.closest(SELS.CHIPS);\n        var chipsLength = $chips.children(SELS.CHIP).length; // enter\n\n        if (13 === e.which) {\n          // Override enter if autocompleting.\n          if (self.hasAutocomplete && $chips.find('.autocomplete-content.dropdown-content').length && $chips.find('.autocomplete-content.dropdown-content').children().length) {\n            return;\n          }\n\n          e.preventDefault();\n          self.addChip({\n            tag: $target.val()\n          }, $chips);\n          $target.val('');\n          return;\n        } // delete or left\n\n\n        if ((8 === e.keyCode || 37 === e.keyCode) && '' === $target.val() && chipsLength) {\n          e.preventDefault();\n          self.selectChip(chipsLength - 1, $chips);\n          $target.blur();\n          return;\n        }\n      }); // Click on delete icon in chip.\n\n      self.$document.off('click.chips-delete', SELS.CHIPS + ' ' + SELS.DELETE).on('click.chips-delete', SELS.CHIPS + ' ' + SELS.DELETE, function (e) {\n        var $target = $(e.target);\n        var $chips = $target.closest(SELS.CHIPS);\n        var $chip = $target.closest(SELS.CHIP);\n        e.stopPropagation();\n        self.deleteChip($chip.index(), $chips);\n        $chips.find('input').focus();\n      });\n    };\n\n    this.chips = function ($chips, chipId) {\n      $chips.empty();\n      $chips.data('chips').forEach(function (elem) {\n        $chips.append(self.renderChip(elem));\n      });\n      $chips.append($('<input id=\"' + chipId + '\" class=\"input\" placeholder=\"\">'));\n      self.setPlaceholder($chips); // Set for attribute for label\n\n      var label = $chips.next('label');\n\n      if (label.length) {\n        label.attr('for', chipId);\n\n        if ($chips.data('chips') !== undefined && $chips.data('chips').length) {\n          label.addClass('active');\n        }\n      } // Setup autocomplete if needed.\n\n\n      var input = $('#' + chipId);\n\n      if (self.hasAutocomplete) {\n        curr_options.autocompleteOptions.onAutocomplete = function (val) {\n          self.addChip({\n            tag: val\n          }, $chips);\n          input.val('');\n          input.focus();\n        };\n\n        input.autocomplete(curr_options.autocompleteOptions);\n      }\n    };\n    /**\r\n     * Render chip jQuery element.\r\n     * @param {Object} elem\r\n     * @return {jQuery}\r\n     */\n\n\n    this.renderChip = function (elem) {\n      if (!elem.tag) return;\n      var $renderedChip = $('<div class=\"chip\"></div>');\n      $renderedChip.text(elem.tag);\n\n      if (elem.image) {\n        $renderedChip.prepend($('<img />').attr('src', elem.image));\n      }\n\n      $renderedChip.append($('<i class=\"material-icons close\">close</i>'));\n      return $renderedChip;\n    };\n\n    this.setPlaceholder = function ($chips) {\n      if ($chips.data('chips') !== undefined && !$chips.data('chips').length && curr_options.placeholder) {\n        $chips.find('input').prop('placeholder', curr_options.placeholder);\n      } else if (($chips.data('chips') === undefined || !!$chips.data('chips').length) && curr_options.secondaryPlaceholder) {\n        $chips.find('input').prop('placeholder', curr_options.secondaryPlaceholder);\n      }\n    };\n\n    this.isValid = function ($chips, elem) {\n      var chips = $chips.data('chips');\n      var exists = false;\n\n      for (var i = 0; i < chips.length; i++) {\n        if (chips[i].tag === elem.tag) {\n          exists = true;\n          return;\n        }\n      }\n\n      return '' !== elem.tag && !exists;\n    };\n\n    this.addChip = function (elem, $chips) {\n      if (!self.isValid($chips, elem)) {\n        return;\n      }\n\n      var $renderedChip = self.renderChip(elem);\n      var newData = [];\n      var oldData = $chips.data('chips');\n\n      for (var i = 0; i < oldData.length; i++) {\n        newData.push(oldData[i]);\n      }\n\n      newData.push(elem);\n      $chips.data('chips', newData);\n      $renderedChip.insertBefore($chips.find('input'));\n      $chips.trigger('chip.add', elem);\n      self.setPlaceholder($chips);\n    };\n\n    this.deleteChip = function (chipIndex, $chips) {\n      var chip = $chips.data('chips')[chipIndex];\n      $chips.find('.chip').eq(chipIndex).remove();\n      var newData = [];\n      var oldData = $chips.data('chips');\n\n      for (var i = 0; i < oldData.length; i++) {\n        if (i !== chipIndex) {\n          newData.push(oldData[i]);\n        }\n      }\n\n      $chips.data('chips', newData);\n      $chips.trigger('chip.delete', chip);\n      self.setPlaceholder($chips);\n    };\n\n    this.selectChip = function (chipIndex, $chips) {\n      var $chip = $chips.find('.chip').eq(chipIndex);\n\n      if ($chip && false === $chip.hasClass('selected')) {\n        $chip.addClass('selected');\n        $chips.trigger('chip.select', $chips.data('chips')[chipIndex]);\n      }\n    };\n\n    this.getChipsElement = function (index, $chips) {\n      return $chips.eq(index);\n    }; // init\n\n\n    this.init();\n    this.handleEvents();\n  };\n})(jQuery);\n\n;\n\n(function ($) {\n  $.fn.pushpin = function (options) {\n    // Defaults\n    var defaults = {\n      top: 0,\n      bottom: Infinity,\n      offset: 0\n    }; // Remove pushpin event and classes\n\n    if (options === \"remove\") {\n      this.each(function () {\n        if (id = $(this).data('pushpin-id')) {\n          $(window).off('scroll.' + id);\n          $(this).removeData('pushpin-id').removeClass('pin-top pinned pin-bottom').removeAttr('style');\n        }\n      });\n      return false;\n    }\n\n    options = $.extend(defaults, options);\n    $index = 0;\n    return this.each(function () {\n      var $uniqueId = Materialize.guid(),\n          $this = $(this),\n          $original_offset = $(this).offset().top;\n\n      function removePinClasses(object) {\n        object.removeClass('pin-top');\n        object.removeClass('pinned');\n        object.removeClass('pin-bottom');\n      }\n\n      function updateElements(objects, scrolled) {\n        objects.each(function () {\n          // Add position fixed (because its between top and bottom)\n          if (options.top <= scrolled && options.bottom >= scrolled && !$(this).hasClass('pinned')) {\n            removePinClasses($(this));\n            $(this).css('top', options.offset);\n            $(this).addClass('pinned');\n          } // Add pin-top (when scrolled position is above top)\n\n\n          if (scrolled < options.top && !$(this).hasClass('pin-top')) {\n            removePinClasses($(this));\n            $(this).css('top', 0);\n            $(this).addClass('pin-top');\n          } // Add pin-bottom (when scrolled position is below bottom)\n\n\n          if (scrolled > options.bottom && !$(this).hasClass('pin-bottom')) {\n            removePinClasses($(this));\n            $(this).addClass('pin-bottom');\n            $(this).css('top', options.bottom - $original_offset);\n          }\n        });\n      }\n\n      $(this).data('pushpin-id', $uniqueId);\n      updateElements($this, $(window).scrollTop());\n      $(window).on('scroll.' + $uniqueId, function () {\n        var $scrolled = $(window).scrollTop() + options.offset;\n        updateElements($this, $scrolled);\n      });\n    });\n  };\n})(jQuery);\n\n;\n\n(function ($) {\n  $(document).ready(function () {\n    // jQuery reverse\n    $.fn.reverse = [].reverse; // Hover behaviour: make sure this doesn't work on .click-to-toggle FABs!\n\n    $(document).on('mouseenter.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle):not(.toolbar)', function (e) {\n      var $this = $(this);\n      openFABMenu($this);\n    });\n    $(document).on('mouseleave.fixedActionBtn', '.fixed-action-btn:not(.click-to-toggle):not(.toolbar)', function (e) {\n      var $this = $(this);\n      closeFABMenu($this);\n    }); // Toggle-on-click behaviour.\n\n    $(document).on('click.fabClickToggle', '.fixed-action-btn.click-to-toggle > a', function (e) {\n      var $this = $(this);\n      var $menu = $this.parent();\n\n      if ($menu.hasClass('active')) {\n        closeFABMenu($menu);\n      } else {\n        openFABMenu($menu);\n      }\n    }); // Toolbar transition behaviour.\n\n    $(document).on('click.fabToolbar', '.fixed-action-btn.toolbar > a', function (e) {\n      var $this = $(this);\n      var $menu = $this.parent();\n      FABtoToolbar($menu);\n    });\n  });\n  $.fn.extend({\n    openFAB: function openFAB() {\n      openFABMenu($(this));\n    },\n    closeFAB: function closeFAB() {\n      closeFABMenu($(this));\n    },\n    openToolbar: function openToolbar() {\n      FABtoToolbar($(this));\n    },\n    closeToolbar: function closeToolbar() {\n      toolbarToFAB($(this));\n    }\n  });\n\n  var openFABMenu = function openFABMenu(btn) {\n    var $this = btn;\n\n    if ($this.hasClass('active') === false) {\n      // Get direction option\n      var horizontal = $this.hasClass('horizontal');\n      var offsetY, offsetX;\n\n      if (horizontal === true) {\n        offsetX = 40;\n      } else {\n        offsetY = 40;\n      }\n\n      $this.addClass('active');\n      $this.find('ul .btn-floating').velocity({\n        scaleY: \".4\",\n        scaleX: \".4\",\n        translateY: offsetY + 'px',\n        translateX: offsetX + 'px'\n      }, {\n        duration: 0\n      });\n      var time = 0;\n      $this.find('ul .btn-floating').reverse().each(function () {\n        $(this).velocity({\n          opacity: \"1\",\n          scaleX: \"1\",\n          scaleY: \"1\",\n          translateY: \"0\",\n          translateX: '0'\n        }, {\n          duration: 80,\n          delay: time\n        });\n        time += 40;\n      });\n    }\n  };\n\n  var closeFABMenu = function closeFABMenu(btn) {\n    var $this = btn; // Get direction option\n\n    var horizontal = $this.hasClass('horizontal');\n    var offsetY, offsetX;\n\n    if (horizontal === true) {\n      offsetX = 40;\n    } else {\n      offsetY = 40;\n    }\n\n    $this.removeClass('active');\n    var time = 0;\n    $this.find('ul .btn-floating').velocity(\"stop\", true);\n    $this.find('ul .btn-floating').velocity({\n      opacity: \"0\",\n      scaleX: \".4\",\n      scaleY: \".4\",\n      translateY: offsetY + 'px',\n      translateX: offsetX + 'px'\n    }, {\n      duration: 80\n    });\n  };\n  /**\r\n   * Transform FAB into toolbar\r\n   * @param  {Object}  object jQuery object\r\n   */\n\n\n  var FABtoToolbar = function FABtoToolbar(btn) {\n    if (btn.attr('data-open') === \"true\") {\n      return;\n    }\n\n    var offsetX, offsetY, scaleFactor;\n    var windowWidth = window.innerWidth;\n    var windowHeight = window.innerHeight;\n    var btnRect = btn[0].getBoundingClientRect();\n    var anchor = btn.find('> a').first();\n    var menu = btn.find('> ul').first();\n    var backdrop = $('<div class=\"fab-backdrop\"></div>');\n    var fabColor = anchor.css('background-color');\n    anchor.append(backdrop);\n    offsetX = btnRect.left - windowWidth / 2 + btnRect.width / 2;\n    offsetY = windowHeight - btnRect.bottom;\n    scaleFactor = windowWidth / backdrop.width();\n    btn.attr('data-origin-bottom', btnRect.bottom);\n    btn.attr('data-origin-left', btnRect.left);\n    btn.attr('data-origin-width', btnRect.width); // Set initial state\n\n    btn.addClass('active');\n    btn.attr('data-open', true);\n    btn.css({\n      'text-align': 'center',\n      width: '100%',\n      bottom: 0,\n      left: 0,\n      transform: 'translateX(' + offsetX + 'px)',\n      transition: 'none'\n    });\n    anchor.css({\n      transform: 'translateY(' + -offsetY + 'px)',\n      transition: 'none'\n    });\n    backdrop.css({\n      'background-color': fabColor\n    });\n    setTimeout(function () {\n      btn.css({\n        transform: '',\n        transition: 'transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s'\n      });\n      anchor.css({\n        overflow: 'visible',\n        transform: '',\n        transition: 'transform .2s'\n      });\n      setTimeout(function () {\n        btn.css({\n          overflow: 'hidden',\n          'background-color': fabColor\n        });\n        backdrop.css({\n          transform: 'scale(' + scaleFactor + ')',\n          transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'\n        });\n        menu.find('> li > a').css({\n          opacity: 1\n        }); // Scroll to close.\n\n        $(window).on('scroll.fabToolbarClose', function () {\n          toolbarToFAB(btn);\n          $(window).off('scroll.fabToolbarClose');\n          $(document).off('click.fabToolbarClose');\n        });\n        $(document).on('click.fabToolbarClose', function (e) {\n          if (!$(e.target).closest(menu).length) {\n            toolbarToFAB(btn);\n            $(window).off('scroll.fabToolbarClose');\n            $(document).off('click.fabToolbarClose');\n          }\n        });\n      }, 100);\n    }, 0);\n  };\n  /**\r\n   * Transform toolbar back into FAB\r\n   * @param  {Object}  object jQuery object\r\n   */\n\n\n  var toolbarToFAB = function toolbarToFAB(btn) {\n    if (btn.attr('data-open') !== \"true\") {\n      return;\n    }\n\n    var offsetX, offsetY, scaleFactor;\n    var windowWidth = window.innerWidth;\n    var windowHeight = window.innerHeight;\n    var btnWidth = btn.attr('data-origin-width');\n    var btnBottom = btn.attr('data-origin-bottom');\n    var btnLeft = btn.attr('data-origin-left');\n    var anchor = btn.find('> .btn-floating').first();\n    var menu = btn.find('> ul').first();\n    var backdrop = btn.find('.fab-backdrop');\n    var fabColor = anchor.css('background-color');\n    offsetX = btnLeft - windowWidth / 2 + btnWidth / 2;\n    offsetY = windowHeight - btnBottom;\n    scaleFactor = windowWidth / backdrop.width(); // Hide backdrop\n\n    btn.removeClass('active');\n    btn.attr('data-open', false);\n    btn.css({\n      'background-color': 'transparent',\n      transition: 'none'\n    });\n    anchor.css({\n      transition: 'none'\n    });\n    backdrop.css({\n      transform: 'scale(0)',\n      'background-color': fabColor\n    });\n    menu.find('> li > a').css({\n      opacity: ''\n    });\n    setTimeout(function () {\n      backdrop.remove(); // Set initial state.\n\n      btn.css({\n        'text-align': '',\n        width: '',\n        bottom: '',\n        left: '',\n        overflow: '',\n        'background-color': '',\n        transform: 'translate3d(' + -offsetX + 'px,0,0)'\n      });\n      anchor.css({\n        overflow: '',\n        transform: 'translate3d(0,' + offsetY + 'px,0)'\n      });\n      setTimeout(function () {\n        btn.css({\n          transform: 'translate3d(0,0,0)',\n          transition: 'transform .2s'\n        });\n        anchor.css({\n          transform: 'translate3d(0,0,0)',\n          transition: 'transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)'\n        });\n      }, 20);\n    }, 200);\n  };\n})(jQuery);\n\n;\n\n(function ($) {\n  // Image transition function\n  Materialize.fadeInImage = function (selectorOrEl) {\n    var element;\n\n    if (typeof selectorOrEl === 'string') {\n      element = $(selectorOrEl);\n    } else if (typeof selectorOrEl === 'object') {\n      element = selectorOrEl;\n    } else {\n      return;\n    }\n\n    element.css({\n      opacity: 0\n    });\n    $(element).velocity({\n      opacity: 1\n    }, {\n      duration: 650,\n      queue: false,\n      easing: 'easeOutSine'\n    });\n    $(element).velocity({\n      opacity: 1\n    }, {\n      duration: 1300,\n      queue: false,\n      easing: 'swing',\n      step: function step(now, fx) {\n        fx.start = 100;\n        var grayscale_setting = now / 100;\n        var brightness_setting = 150 - (100 - now) / 1.75;\n\n        if (brightness_setting < 100) {\n          brightness_setting = 100;\n        }\n\n        if (now >= 0) {\n          $(this).css({\n            \"-webkit-filter\": \"grayscale(\" + grayscale_setting + \")\" + \"brightness(\" + brightness_setting + \"%)\",\n            \"filter\": \"grayscale(\" + grayscale_setting + \")\" + \"brightness(\" + brightness_setting + \"%)\"\n          });\n        }\n      }\n    });\n  }; // Horizontal staggered list\n\n\n  Materialize.showStaggeredList = function (selectorOrEl) {\n    var element;\n\n    if (typeof selectorOrEl === 'string') {\n      element = $(selectorOrEl);\n    } else if (typeof selectorOrEl === 'object') {\n      element = selectorOrEl;\n    } else {\n      return;\n    }\n\n    var time = 0;\n    element.find('li').velocity({\n      translateX: \"-100px\"\n    }, {\n      duration: 0\n    });\n    element.find('li').each(function () {\n      $(this).velocity({\n        opacity: \"1\",\n        translateX: \"0\"\n      }, {\n        duration: 800,\n        delay: time,\n        easing: [60, 10]\n      });\n      time += 120;\n    });\n  };\n\n  $(document).ready(function () {\n    // Hardcoded .staggered-list scrollFire\n    // var staggeredListOptions = [];\n    // $('ul.staggered-list').each(function (i) {\n    //   var label = 'scrollFire-' + i;\n    //   $(this).addClass(label);\n    //   staggeredListOptions.push(\n    //     {selector: 'ul.staggered-list.' + label,\n    //      offset: 200,\n    //      callback: 'showStaggeredList(\"ul.staggered-list.' + label + '\")'});\n    // });\n    // scrollFire(staggeredListOptions);\n    // HammerJS, Swipe navigation\n    // Touch Event\n    var swipeLeft = false;\n    var swipeRight = false; // Dismissible Collections\n\n    $('.dismissable').each(function () {\n      $(this).hammer({\n        prevent_default: false\n      }).on('pan', function (e) {\n        if (e.gesture.pointerType === \"touch\") {\n          var $this = $(this);\n          var direction = e.gesture.direction;\n          var x = e.gesture.deltaX;\n          var velocityX = e.gesture.velocityX;\n          $this.velocity({\n            translateX: x\n          }, {\n            duration: 50,\n            queue: false,\n            easing: 'easeOutQuad'\n          }); // Swipe Left\n\n          if (direction === 4 && (x > $this.innerWidth() / 2 || velocityX < -0.75)) {\n            swipeLeft = true;\n          } // Swipe Right\n\n\n          if (direction === 2 && (x < -1 * $this.innerWidth() / 2 || velocityX > 0.75)) {\n            swipeRight = true;\n          }\n        }\n      }).on('panend', function (e) {\n        // Reset if collection is moved back into original position\n        if (Math.abs(e.gesture.deltaX) < $(this).innerWidth() / 2) {\n          swipeRight = false;\n          swipeLeft = false;\n        }\n\n        if (e.gesture.pointerType === \"touch\") {\n          var $this = $(this);\n\n          if (swipeLeft || swipeRight) {\n            var fullWidth;\n\n            if (swipeLeft) {\n              fullWidth = $this.innerWidth();\n            } else {\n              fullWidth = -1 * $this.innerWidth();\n            }\n\n            $this.velocity({\n              translateX: fullWidth\n            }, {\n              duration: 100,\n              queue: false,\n              easing: 'easeOutQuad',\n              complete: function complete() {\n                $this.css('border', 'none');\n                $this.velocity({\n                  height: 0,\n                  padding: 0\n                }, {\n                  duration: 200,\n                  queue: false,\n                  easing: 'easeOutQuad',\n                  complete: function complete() {\n                    $this.remove();\n                  }\n                });\n              }\n            });\n          } else {\n            $this.velocity({\n              translateX: 0\n            }, {\n              duration: 100,\n              queue: false,\n              easing: 'easeOutQuad'\n            });\n          }\n\n          swipeLeft = false;\n          swipeRight = false;\n        }\n      });\n    }); // time = 0\n    // // Vertical Staggered list\n    // $('ul.staggered-list.vertical li').velocity(\n    //     { translateY: \"100px\"},\n    //     { duration: 0 });\n    // $('ul.staggered-list.vertical li').each(function() {\n    //   $(this).velocity(\n    //     { opacity: \"1\", translateY: \"0\"},\n    //     { duration: 800, delay: time, easing: [60, 25] });\n    //   time += 120;\n    // });\n    // // Fade in and Scale\n    // $('.fade-in.scale').velocity(\n    //     { scaleX: .4, scaleY: .4, translateX: -600},\n    //     { duration: 0});\n    // $('.fade-in').each(function() {\n    //   $(this).velocity(\n    //     { opacity: \"1\", scaleX: 1, scaleY: 1, translateX: 0},\n    //     { duration: 800, easing: [60, 10] });\n    // });\n  });\n})(jQuery);\n\n;\n\n(function ($) {\n  var scrollFireEventsHandled = false; // Input: Array of JSON objects {selector, offset, callback}\n\n  Materialize.scrollFire = function (options) {\n    var onScroll = function onScroll() {\n      var windowScroll = window.pageYOffset + window.innerHeight;\n\n      for (var i = 0; i < options.length; i++) {\n        // Get options from each line\n        var value = options[i];\n        var selector = value.selector,\n            offset = value.offset,\n            callback = value.callback;\n        var currentElement = document.querySelector(selector);\n\n        if (currentElement !== null) {\n          var elementOffset = currentElement.getBoundingClientRect().top + window.pageYOffset;\n\n          if (windowScroll > elementOffset + offset) {\n            if (value.done !== true) {\n              if (typeof callback === 'function') {\n                callback.call(this, currentElement);\n              } else if (typeof callback === 'string') {\n                var callbackFunc = new Function(callback);\n                callbackFunc(currentElement);\n              }\n\n              value.done = true;\n            }\n          }\n        }\n      }\n    };\n\n    var throttledScroll = Materialize.throttle(function () {\n      onScroll();\n    }, options.throttle || 100);\n\n    if (!scrollFireEventsHandled) {\n      window.addEventListener(\"scroll\", throttledScroll);\n      window.addEventListener(\"resize\", throttledScroll);\n      scrollFireEventsHandled = true;\n    } // perform a scan once, after current execution context, and after dom is ready\n\n\n    setTimeout(throttledScroll, 0);\n  };\n})(jQuery);\n\n;\n/*!\r\n* pickadate.js v3.5.0, 2014/04/13\r\n* By Amsul, http://amsul.ca\r\n* Hosted on http://amsul.github.io/pickadate.js\r\n* Licensed under MIT\r\n*/\n\n(function (factory) {\n  Materialize.Picker = factory(jQuery);\n})(function ($) {\n  var $window = $(window);\n  var $document = $(document);\n  var $html = $(document.documentElement);\n  /**\r\n   * The picker constructor that creates a blank picker.\r\n   */\n\n  function PickerConstructor(ELEMENT, NAME, COMPONENT, OPTIONS) {\n    // If thereâs no element, return the picker constructor.\n    if (!ELEMENT) return PickerConstructor;\n\n    var IS_DEFAULT_THEME = false,\n        // The state of the picker.\n    STATE = {\n      id: ELEMENT.id || 'P' + Math.abs(~~(Math.random() * new Date()))\n    },\n        // Merge the defaults and options passed.\n    SETTINGS = COMPONENT ? $.extend(true, {}, COMPONENT.defaults, OPTIONS) : OPTIONS || {},\n        // Merge the default classes with the settings classes.\n    CLASSES = $.extend({}, PickerConstructor.klasses(), SETTINGS.klass),\n        // The element node wrapper into a jQuery object.\n    $ELEMENT = $(ELEMENT),\n        // Pseudo picker constructor.\n    PickerInstance = function PickerInstance() {\n      return this.start();\n    },\n        // The picker prototype.\n    P = PickerInstance.prototype = {\n      constructor: PickerInstance,\n      $node: $ELEMENT,\n\n      /**\r\n       * Initialize everything\r\n       */\n      start: function start() {\n        // If itâs already started, do nothing.\n        if (STATE && STATE.start) return P; // Update the picker states.\n\n        STATE.methods = {};\n        STATE.start = true;\n        STATE.open = false;\n        STATE.type = ELEMENT.type; // Confirm focus state, convert into text input to remove UA stylings,\n        // and set as readonly to prevent keyboard popup.\n\n        ELEMENT.autofocus = ELEMENT == getActiveElement();\n        ELEMENT.readOnly = !SETTINGS.editable;\n        ELEMENT.id = ELEMENT.id || STATE.id;\n\n        if (ELEMENT.type != 'text') {\n          ELEMENT.type = 'text';\n        } // Create a new picker component with the settings.\n\n\n        P.component = new COMPONENT(P, SETTINGS); // Create the picker root with a holder and then prepare it.\n\n        P.$root = $(PickerConstructor._.node('div', createWrappedComponent(), CLASSES.picker, 'id=\"' + ELEMENT.id + '_root\" tabindex=\"0\"'));\n        prepareElementRoot(); // If thereâs a format for the hidden input element, create the element.\n\n        if (SETTINGS.formatSubmit) {\n          prepareElementHidden();\n        } // Prepare the input element.\n\n\n        prepareElement(); // Insert the root as specified in the settings.\n\n        if (SETTINGS.container) $(SETTINGS.container).append(P.$root);else $ELEMENT.before(P.$root); // Bind the default component and settings events.\n\n        P.on({\n          start: P.component.onStart,\n          render: P.component.onRender,\n          stop: P.component.onStop,\n          open: P.component.onOpen,\n          close: P.component.onClose,\n          set: P.component.onSet\n        }).on({\n          start: SETTINGS.onStart,\n          render: SETTINGS.onRender,\n          stop: SETTINGS.onStop,\n          open: SETTINGS.onOpen,\n          close: SETTINGS.onClose,\n          set: SETTINGS.onSet\n        }); // Once weâre all set, check the theme in use.\n\n        IS_DEFAULT_THEME = isUsingDefaultTheme(P.$root.children()[0]); // If the element has autofocus, open the picker.\n\n        if (ELEMENT.autofocus) {\n          P.open();\n        } // Trigger queued the âstartâ and ârenderâ events.\n\n\n        return P.trigger('start').trigger('render');\n      },\n      //start\n\n      /**\r\n       * Render a new picker\r\n       */\n      render: function render(entireComponent) {\n        // Insert a new component holder in the root or box.\n        if (entireComponent) P.$root.html(createWrappedComponent());else P.$root.find('.' + CLASSES.box).html(P.component.nodes(STATE.open)); // Trigger the queued ârenderâ events.\n\n        return P.trigger('render');\n      },\n      //render\n\n      /**\r\n       * Destroy everything\r\n       */\n      stop: function stop() {\n        // If itâs already stopped, do nothing.\n        if (!STATE.start) return P; // Then close the picker.\n\n        P.close(); // Remove the hidden field.\n\n        if (P._hidden) {\n          P._hidden.parentNode.removeChild(P._hidden);\n        } // Remove the root.\n\n\n        P.$root.remove(); // Remove the input class, remove the stored data, and unbind\n        // the events (after a tick for IE - see `P.close`).\n\n        $ELEMENT.removeClass(CLASSES.input).removeData(NAME);\n        setTimeout(function () {\n          $ELEMENT.off('.' + STATE.id);\n        }, 0); // Restore the element state\n\n        ELEMENT.type = STATE.type;\n        ELEMENT.readOnly = false; // Trigger the queued âstopâ events.\n\n        P.trigger('stop'); // Reset the picker states.\n\n        STATE.methods = {};\n        STATE.start = false;\n        return P;\n      },\n      //stop\n\n      /**\r\n       * Open up the picker\r\n       */\n      open: function open(dontGiveFocus) {\n        // If itâs already open, do nothing.\n        if (STATE.open) return P; // Add the âactiveâ class.\n\n        $ELEMENT.addClass(CLASSES.active);\n        aria(ELEMENT, 'expanded', true); // * A Firefox bug, when `html` has `overflow:hidden`, results in\n        //   killing transitions :(. So add the âopenedâ state on the next tick.\n        //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289\n\n        setTimeout(function () {\n          // Add the âopenedâ class to the picker root.\n          P.$root.addClass(CLASSES.opened);\n          aria(P.$root[0], 'hidden', false);\n        }, 0); // If we have to give focus, bind the element and doc events.\n\n        if (dontGiveFocus !== false) {\n          // Set it as open.\n          STATE.open = true; // Prevent the page from scrolling.\n\n          if (IS_DEFAULT_THEME) {\n            $html.css('overflow', 'hidden').css('padding-right', '+=' + getScrollbarWidth());\n          } // Pass focus to the root elementâs jQuery object.\n          // * Workaround for iOS8 to bring the pickerâs root into view.\n\n\n          P.$root.eq(0).focus(); // Bind the document events.\n\n          $document.on('click.' + STATE.id + ' focusin.' + STATE.id, function (event) {\n            var target = event.target; // If the target of the event is not the element, close the picker picker.\n            // * Donât worry about clicks or focusins on the root because those donât bubble up.\n            //   Also, for Firefox, a click on an `option` element bubbles up directly\n            //   to the doc. So make sure the target wasn't the doc.\n            // * In Firefox stopPropagation() doesnât prevent right-click events from bubbling,\n            //   which causes the picker to unexpectedly close when right-clicking it. So make\n            //   sure the event wasnât a right-click.\n\n            if (target != ELEMENT && target != document && event.which != 3) {\n              // If the target was the holder that covers the screen,\n              // keep the element focused to maintain tabindex.\n              P.close(target === P.$root.children()[0]);\n            }\n          }).on('keydown.' + STATE.id, function (event) {\n            var // Get the keycode.\n            keycode = event.keyCode,\n                // Translate that to a selection change.\n            keycodeToMove = P.component.key[keycode],\n                // Grab the target.\n            target = event.target; // On escape, close the picker and give focus.\n\n            if (keycode == 27) {\n              P.close(true);\n            } // Check if there is a key movement or âenterâ keypress on the element.\n            else if (target == P.$root[0] && (keycodeToMove || keycode == 13)) {\n                // Prevent the default action to stop page movement.\n                event.preventDefault(); // Trigger the key movement action.\n\n                if (keycodeToMove) {\n                  PickerConstructor._.trigger(P.component.key.go, P, [PickerConstructor._.trigger(keycodeToMove)]);\n                } // On âenterâ, if the highlighted item isnât disabled, set the value and close.\n                else if (!P.$root.find('.' + CLASSES.highlighted).hasClass(CLASSES.disabled)) {\n                    P.set('select', P.component.item.highlight);\n\n                    if (SETTINGS.closeOnSelect) {\n                      P.close(true);\n                    }\n                  }\n              } // If the target is within the root and âenterâ is pressed,\n              // prevent the default action and trigger a click on the target instead.\n              else if ($.contains(P.$root[0], target) && keycode == 13) {\n                  event.preventDefault();\n                  target.click();\n                }\n          });\n        } // Trigger the queued âopenâ events.\n\n\n        return P.trigger('open');\n      },\n      //open\n\n      /**\r\n       * Close the picker\r\n       */\n      close: function close(giveFocus) {\n        // If we need to give focus, do it before changing states.\n        if (giveFocus) {\n          // ....ah yes! It wouldâve been incomplete without a crazy workaround for IE :|\n          // The focus is triggered *after* the close has completed - causing it\n          // to open again. So unbind and rebind the event at the next tick.\n          P.$root.off('focus.toOpen').eq(0).focus();\n          setTimeout(function () {\n            P.$root.on('focus.toOpen', handleFocusToOpenEvent);\n          }, 0);\n        } // Remove the âactiveâ class.\n\n\n        $ELEMENT.removeClass(CLASSES.active);\n        aria(ELEMENT, 'expanded', false); // * A Firefox bug, when `html` has `overflow:hidden`, results in\n        //   killing transitions :(. So remove the âopenedâ state on the next tick.\n        //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289\n\n        setTimeout(function () {\n          // Remove the âopenedâ and âfocusedâ class from the picker root.\n          P.$root.removeClass(CLASSES.opened + ' ' + CLASSES.focused);\n          aria(P.$root[0], 'hidden', true);\n        }, 0); // If itâs already closed, do nothing more.\n\n        if (!STATE.open) return P; // Set it as closed.\n\n        STATE.open = false; // Allow the page to scroll.\n\n        if (IS_DEFAULT_THEME) {\n          $html.css('overflow', '').css('padding-right', '-=' + getScrollbarWidth());\n        } // Unbind the document events.\n\n\n        $document.off('.' + STATE.id); // Trigger the queued âcloseâ events.\n\n        return P.trigger('close');\n      },\n      //close\n\n      /**\r\n       * Clear the values\r\n       */\n      clear: function clear(options) {\n        return P.set('clear', null, options);\n      },\n      //clear\n\n      /**\r\n       * Set something\r\n       */\n      set: function set(thing, value, options) {\n        var thingItem,\n            thingValue,\n            thingIsObject = $.isPlainObject(thing),\n            thingObject = thingIsObject ? thing : {}; // Make sure we have usable options.\n\n        options = thingIsObject && $.isPlainObject(value) ? value : options || {};\n\n        if (thing) {\n          // If the thing isnât an object, make it one.\n          if (!thingIsObject) {\n            thingObject[thing] = value;\n          } // Go through the things of items to set.\n\n\n          for (thingItem in thingObject) {\n            // Grab the value of the thing.\n            thingValue = thingObject[thingItem]; // First, if the item exists and thereâs a value, set it.\n\n            if (thingItem in P.component.item) {\n              if (thingValue === undefined) thingValue = null;\n              P.component.set(thingItem, thingValue, options);\n            } // Then, check to update the element value and broadcast a change.\n\n\n            if (thingItem == 'select' || thingItem == 'clear') {\n              $ELEMENT.val(thingItem == 'clear' ? '' : P.get(thingItem, SETTINGS.format)).trigger('change');\n            }\n          } // Render a new picker.\n\n\n          P.render();\n        } // When the method isnât muted, trigger queued âsetâ events and pass the `thingObject`.\n\n\n        return options.muted ? P : P.trigger('set', thingObject);\n      },\n      //set\n\n      /**\r\n       * Get something\r\n       */\n      get: function get(thing, format) {\n        // Make sure thereâs something to get.\n        thing = thing || 'value'; // If a picker state exists, return that.\n\n        if (STATE[thing] != null) {\n          return STATE[thing];\n        } // Return the submission value, if that.\n\n\n        if (thing == 'valueSubmit') {\n          if (P._hidden) {\n            return P._hidden.value;\n          }\n\n          thing = 'value';\n        } // Return the value, if that.\n\n\n        if (thing == 'value') {\n          return ELEMENT.value;\n        } // Check if a component item exists, return that.\n\n\n        if (thing in P.component.item) {\n          if (typeof format == 'string') {\n            var thingValue = P.component.get(thing);\n            return thingValue ? PickerConstructor._.trigger(P.component.formats.toString, P.component, [format, thingValue]) : '';\n          }\n\n          return P.component.get(thing);\n        }\n      },\n      //get\n\n      /**\r\n       * Bind events on the things.\r\n       */\n      on: function on(thing, method, internal) {\n        var thingName,\n            thingMethod,\n            thingIsObject = $.isPlainObject(thing),\n            thingObject = thingIsObject ? thing : {};\n\n        if (thing) {\n          // If the thing isnât an object, make it one.\n          if (!thingIsObject) {\n            thingObject[thing] = method;\n          } // Go through the things to bind to.\n\n\n          for (thingName in thingObject) {\n            // Grab the method of the thing.\n            thingMethod = thingObject[thingName]; // If it was an internal binding, prefix it.\n\n            if (internal) {\n              thingName = '_' + thingName;\n            } // Make sure the thing methods collection exists.\n\n\n            STATE.methods[thingName] = STATE.methods[thingName] || []; // Add the method to the relative method collection.\n\n            STATE.methods[thingName].push(thingMethod);\n          }\n        }\n\n        return P;\n      },\n      //on\n\n      /**\r\n       * Unbind events on the things.\r\n       */\n      off: function off() {\n        var i,\n            thingName,\n            names = arguments;\n\n        for (i = 0, namesCount = names.length; i < namesCount; i += 1) {\n          thingName = names[i];\n\n          if (thingName in STATE.methods) {\n            delete STATE.methods[thingName];\n          }\n        }\n\n        return P;\n      },\n\n      /**\r\n       * Fire off method events.\r\n       */\n      trigger: function trigger(name, data) {\n        var _trigger = function _trigger(name) {\n          var methodList = STATE.methods[name];\n\n          if (methodList) {\n            methodList.map(function (method) {\n              PickerConstructor._.trigger(method, P, [data]);\n            });\n          }\n        };\n\n        _trigger('_' + name);\n\n        _trigger(name);\n\n        return P;\n      } //trigger\n      //PickerInstance.prototype\n\n      /**\r\n       * Wrap the picker holder components together.\r\n       */\n\n    };\n\n    function createWrappedComponent() {\n      // Create a picker wrapper holder\n      return PickerConstructor._.node('div', // Create a picker wrapper node\n      PickerConstructor._.node('div', // Create a picker frame\n      PickerConstructor._.node('div', // Create a picker box node\n      PickerConstructor._.node('div', // Create the components nodes.\n      P.component.nodes(STATE.open), // The picker box class\n      CLASSES.box), // Picker wrap class\n      CLASSES.wrap), // Picker frame class\n      CLASSES.frame), // Picker holder class\n      CLASSES.holder); //endreturn\n    } //createWrappedComponent\n\n    /**\r\n     * Prepare the input element with all bindings.\r\n     */\n\n\n    function prepareElement() {\n      $ELEMENT. // Store the picker data by component name.\n      data(NAME, P). // Add the âinputâ class name.\n      addClass(CLASSES.input). // Remove the tabindex.\n      attr('tabindex', -1). // If thereâs a `data-value`, update the value of the element.\n      val($ELEMENT.data('value') ? P.get('select', SETTINGS.format) : ELEMENT.value); // Only bind keydown events if the element isnât editable.\n\n      if (!SETTINGS.editable) {\n        $ELEMENT. // On focus/click, focus onto the root to open it up.\n        on('focus.' + STATE.id + ' click.' + STATE.id, function (event) {\n          event.preventDefault();\n          P.$root.eq(0).focus();\n        }). // Handle keyboard event based on the picker being opened or not.\n        on('keydown.' + STATE.id, handleKeydownEvent);\n      } // Update the aria attributes.\n\n\n      aria(ELEMENT, {\n        haspopup: true,\n        expanded: false,\n        readonly: false,\n        owns: ELEMENT.id + '_root'\n      });\n    }\n    /**\r\n     * Prepare the root picker element with all bindings.\r\n     */\n\n\n    function prepareElementRoot() {\n      P.$root.on({\n        // For iOS8.\n        keydown: handleKeydownEvent,\n        // When something within the root is focused, stop from bubbling\n        // to the doc and remove the âfocusedâ state from the root.\n        focusin: function focusin(event) {\n          P.$root.removeClass(CLASSES.focused);\n          event.stopPropagation();\n        },\n        // When something within the root holder is clicked, stop it\n        // from bubbling to the doc.\n        'mousedown click': function mousedownClick(event) {\n          var target = event.target; // Make sure the target isnât the root holder so it can bubble up.\n\n          if (target != P.$root.children()[0]) {\n            event.stopPropagation(); // * For mousedown events, cancel the default action in order to\n            //   prevent cases where focus is shifted onto external elements\n            //   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).\n            //   Also, for Firefox, donât prevent action on the `option` element.\n\n            if (event.type == 'mousedown' && !$(target).is('input, select, textarea, button, option')) {\n              event.preventDefault(); // Re-focus onto the root so that users can click away\n              // from elements focused within the picker.\n\n              P.$root.eq(0).focus();\n            }\n          }\n        }\n      }). // Add/remove the âtargetâ class on focus and blur.\n      on({\n        focus: function focus() {\n          $ELEMENT.addClass(CLASSES.target);\n        },\n        blur: function blur() {\n          $ELEMENT.removeClass(CLASSES.target);\n        }\n      }). // Open the picker and adjust the root âfocusedâ state\n      on('focus.toOpen', handleFocusToOpenEvent). // If thereâs a click on an actionable element, carry out the actions.\n      on('click', '[data-pick], [data-nav], [data-clear], [data-close]', function () {\n        var $target = $(this),\n            targetData = $target.data(),\n            targetDisabled = $target.hasClass(CLASSES.navDisabled) || $target.hasClass(CLASSES.disabled),\n            // * For IE, non-focusable elements can be active elements as well\n        //   (http://stackoverflow.com/a/2684561).\n        activeElement = getActiveElement();\n        activeElement = activeElement && (activeElement.type || activeElement.href) && activeElement; // If itâs disabled or nothing inside is actively focused, re-focus the element.\n\n        if (targetDisabled || activeElement && !$.contains(P.$root[0], activeElement)) {\n          P.$root.eq(0).focus();\n        } // If something is superficially changed, update the `highlight` based on the `nav`.\n\n\n        if (!targetDisabled && targetData.nav) {\n          P.set('highlight', P.component.item.highlight, {\n            nav: targetData.nav\n          });\n        } // If something is picked, set `select` then close with focus.\n        else if (!targetDisabled && 'pick' in targetData) {\n            P.set('select', targetData.pick);\n\n            if (SETTINGS.closeOnSelect) {\n              P.close(true);\n            }\n          } // If a âclearâ button is pressed, empty the values and close with focus.\n          else if (targetData.clear) {\n              P.clear();\n\n              if (SETTINGS.closeOnSelect) {\n                P.close(true);\n              }\n            } else if (targetData.close) {\n              P.close(true);\n            }\n      }); //P.$root\n\n      aria(P.$root[0], 'hidden', true);\n    }\n    /**\r\n     * Prepare the hidden input element along with all bindings.\r\n     */\n\n\n    function prepareElementHidden() {\n      var name;\n\n      if (SETTINGS.hiddenName === true) {\n        name = ELEMENT.name;\n        ELEMENT.name = '';\n      } else {\n        name = [typeof SETTINGS.hiddenPrefix == 'string' ? SETTINGS.hiddenPrefix : '', typeof SETTINGS.hiddenSuffix == 'string' ? SETTINGS.hiddenSuffix : '_submit'];\n        name = name[0] + ELEMENT.name + name[1];\n      }\n\n      P._hidden = $('<input ' + 'type=hidden ' + // Create the name using the original inputâs with a prefix and suffix.\n      'name=\"' + name + '\"' + ( // If the element has a value, set the hidden value as well.\n      $ELEMENT.data('value') || ELEMENT.value ? ' value=\"' + P.get('select', SETTINGS.formatSubmit) + '\"' : '') + '>')[0];\n      $ELEMENT. // If the value changes, update the hidden input with the correct format.\n      on('change.' + STATE.id, function () {\n        P._hidden.value = ELEMENT.value ? P.get('select', SETTINGS.formatSubmit) : '';\n      }); // Insert the hidden input as specified in the settings.\n\n      if (SETTINGS.container) $(SETTINGS.container).append(P._hidden);else $ELEMENT.before(P._hidden);\n    } // For iOS8.\n\n\n    function handleKeydownEvent(event) {\n      var keycode = event.keyCode,\n          // Check if one of the delete keys was pressed.\n      isKeycodeDelete = /^(8|46)$/.test(keycode); // For some reason IE clears the input value on âescapeâ.\n\n      if (keycode == 27) {\n        P.close();\n        return false;\n      } // Check if `space` or `delete` was pressed or the picker is closed with a key movement.\n\n\n      if (keycode == 32 || isKeycodeDelete || !STATE.open && P.component.key[keycode]) {\n        // Prevent it from moving the page and bubbling to doc.\n        event.preventDefault();\n        event.stopPropagation(); // If `delete` was pressed, clear the values and close the picker.\n        // Otherwise open the picker.\n\n        if (isKeycodeDelete) {\n          P.clear().close();\n        } else {\n          P.open();\n        }\n      }\n    } // Separated for IE\n\n\n    function handleFocusToOpenEvent(event) {\n      // Stop the event from propagating to the doc.\n      event.stopPropagation(); // If itâs a focus event, add the âfocusedâ class to the root.\n\n      if (event.type == 'focus') {\n        P.$root.addClass(CLASSES.focused);\n      } // And then finally open the picker.\n\n\n      P.open();\n    } // Return a new picker instance.\n\n\n    return new PickerInstance();\n  } //PickerConstructor\n\n  /**\r\n   * The default classes and prefix to use for the HTML classes.\r\n   */\n\n\n  PickerConstructor.klasses = function (prefix) {\n    prefix = prefix || 'picker';\n    return {\n      picker: prefix,\n      opened: prefix + '--opened',\n      focused: prefix + '--focused',\n      input: prefix + '__input',\n      active: prefix + '__input--active',\n      target: prefix + '__input--target',\n      holder: prefix + '__holder',\n      frame: prefix + '__frame',\n      wrap: prefix + '__wrap',\n      box: prefix + '__box'\n    };\n  }; //PickerConstructor.klasses\n\n  /**\r\n   * Check if the default theme is being used.\r\n   */\n\n\n  function isUsingDefaultTheme(element) {\n    var theme,\n        prop = 'position'; // For IE.\n\n    if (element.currentStyle) {\n      theme = element.currentStyle[prop];\n    } // For normal browsers.\n    else if (window.getComputedStyle) {\n        theme = getComputedStyle(element)[prop];\n      }\n\n    return theme == 'fixed';\n  }\n  /**\r\n   * Get the width of the browserâs scrollbar.\r\n   * Taken from: https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js\r\n   */\n\n\n  function getScrollbarWidth() {\n    if ($html.height() <= $window.height()) {\n      return 0;\n    }\n\n    var $outer = $('<div style=\"visibility:hidden;width:100px\" />').appendTo('body'); // Get the width without scrollbars.\n\n    var widthWithoutScroll = $outer[0].offsetWidth; // Force adding scrollbars.\n\n    $outer.css('overflow', 'scroll'); // Add the inner div.\n\n    var $inner = $('<div style=\"width:100%\" />').appendTo($outer); // Get the width with scrollbars.\n\n    var widthWithScroll = $inner[0].offsetWidth; // Remove the divs.\n\n    $outer.remove(); // Return the difference between the widths.\n\n    return widthWithoutScroll - widthWithScroll;\n  }\n  /**\r\n   * PickerConstructor helper methods.\r\n   */\n\n\n  PickerConstructor._ = {\n    /**\r\n     * Create a group of nodes. Expects:\r\n     * `\r\n        {\r\n            min:    {Integer},\r\n            max:    {Integer},\r\n            i:      {Integer},\r\n            node:   {String},\r\n            item:   {Function}\r\n        }\r\n     * `\r\n     */\n    group: function group(groupObject) {\n      var // Scope for the looped object\n      loopObjectScope,\n          // Create the nodes list\n      nodesList = '',\n          // The counter starts from the `min`\n      counter = PickerConstructor._.trigger(groupObject.min, groupObject); // Loop from the `min` to `max`, incrementing by `i`\n\n\n      for (; counter <= PickerConstructor._.trigger(groupObject.max, groupObject, [counter]); counter += groupObject.i) {\n        // Trigger the `item` function within scope of the object\n        loopObjectScope = PickerConstructor._.trigger(groupObject.item, groupObject, [counter]); // Splice the subgroup and create nodes out of the sub nodes\n\n        nodesList += PickerConstructor._.node(groupObject.node, loopObjectScope[0], // the node\n        loopObjectScope[1], // the classes\n        loopObjectScope[2] // the attributes\n        );\n      } // Return the list of nodes\n\n\n      return nodesList;\n    },\n    //group\n\n    /**\r\n     * Create a dom node string\r\n     */\n    node: function node(wrapper, item, klass, attribute) {\n      // If the item is false-y, just return an empty string\n      if (!item) return ''; // If the item is an array, do a join\n\n      item = $.isArray(item) ? item.join('') : item; // Check for the class\n\n      klass = klass ? ' class=\"' + klass + '\"' : ''; // Check for any attributes\n\n      attribute = attribute ? ' ' + attribute : ''; // Return the wrapped item\n\n      return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>';\n    },\n    //node\n\n    /**\r\n     * Lead numbers below 10 with a zero.\r\n     */\n    lead: function lead(number) {\n      return (number < 10 ? '0' : '') + number;\n    },\n\n    /**\r\n     * Trigger a function otherwise return the value.\r\n     */\n    trigger: function trigger(callback, scope, args) {\n      return typeof callback == 'function' ? callback.apply(scope, args || []) : callback;\n    },\n\n    /**\r\n     * If the second character is a digit, length is 2 otherwise 1.\r\n     */\n    digits: function digits(string) {\n      return /\\d/.test(string[1]) ? 2 : 1;\n    },\n\n    /**\r\n     * Tell if something is a date object.\r\n     */\n    isDate: function isDate(value) {\n      return {}.toString.call(value).indexOf('Date') > -1 && this.isInteger(value.getDate());\n    },\n\n    /**\r\n     * Tell if something is an integer.\r\n     */\n    isInteger: function isInteger(value) {\n      return {}.toString.call(value).indexOf('Number') > -1 && value % 1 === 0;\n    },\n\n    /**\r\n     * Create ARIA attribute strings.\r\n     */\n    ariaAttr: ariaAttr //PickerConstructor._\n\n    /**\r\n     * Extend the picker with a component and defaults.\r\n     */\n\n  };\n\n  PickerConstructor.extend = function (name, Component) {\n    // Extend jQuery.\n    $.fn[name] = function (options, action) {\n      // Grab the component data.\n      var componentData = this.data(name); // If the picker is requested, return the data object.\n\n      if (options == 'picker') {\n        return componentData;\n      } // If the component data exists and `options` is a string, carry out the action.\n\n\n      if (componentData && typeof options == 'string') {\n        return PickerConstructor._.trigger(componentData[options], componentData, [action]);\n      } // Otherwise go through each matched element and if the component\n      // doesnât exist, create a new picker using `this` element\n      // and merging the defaults and options with a deep copy.\n\n\n      return this.each(function () {\n        var $this = $(this);\n\n        if (!$this.data(name)) {\n          new PickerConstructor(this, name, Component, options);\n        }\n      });\n    }; // Set the defaults.\n\n\n    $.fn[name].defaults = Component.defaults;\n  }; //PickerConstructor.extend\n\n\n  function aria(element, attribute, value) {\n    if ($.isPlainObject(attribute)) {\n      for (var key in attribute) {\n        ariaSet(element, key, attribute[key]);\n      }\n    } else {\n      ariaSet(element, attribute, value);\n    }\n  }\n\n  function ariaSet(element, attribute, value) {\n    element.setAttribute((attribute == 'role' ? '' : 'aria-') + attribute, value);\n  }\n\n  function ariaAttr(attribute, data) {\n    if (!$.isPlainObject(attribute)) {\n      attribute = {\n        attribute: data\n      };\n    }\n\n    data = '';\n\n    for (var key in attribute) {\n      var attr = (key == 'role' ? '' : 'aria-') + key,\n          attrVal = attribute[key];\n      data += attrVal == null ? '' : attr + '=\"' + attribute[key] + '\"';\n    }\n\n    return data;\n  } // IE8 bug throws an error for activeElements within iframes.\n\n\n  function getActiveElement() {\n    try {\n      return document.activeElement;\n    } catch (err) {}\n  } // Expose the picker constructor.\n\n\n  return PickerConstructor;\n});\n\n;\n/*!\r\n* Date picker for pickadate.js v3.5.0\r\n* http://amsul.github.io/pickadate.js/date.htm\r\n*/\n\n(function (factory) {\n  factory(Materialize.Picker, jQuery);\n})(function (Picker, $) {\n  /**\r\n   * Globals and constants\r\n   */\n  var DAYS_IN_WEEK = 7,\n      WEEKS_IN_CALENDAR = 6,\n      _ = Picker._;\n  /**\r\n   * The date picker constructor\r\n   */\n\n  function DatePicker(picker, settings) {\n    var calendar = this,\n        element = picker.$node[0],\n        elementValue = element.value,\n        elementDataValue = picker.$node.data('value'),\n        valueString = elementDataValue || elementValue,\n        formatString = elementDataValue ? settings.formatSubmit : settings.format,\n        isRTL = function isRTL() {\n      return element.currentStyle ? // For IE.\n      element.currentStyle.direction == 'rtl' : // For normal browsers.\n      getComputedStyle(picker.$root[0]).direction == 'rtl';\n    };\n\n    calendar.settings = settings;\n    calendar.$node = picker.$node; // The queue of methods that will be used to build item objects.\n\n    calendar.queue = {\n      min: 'measure create',\n      max: 'measure create',\n      now: 'now create',\n      select: 'parse create validate',\n      highlight: 'parse navigate create validate',\n      view: 'parse create validate viewset',\n      disable: 'deactivate',\n      enable: 'activate' // The component's item object.\n\n    };\n    calendar.item = {};\n    calendar.item.clear = null;\n    calendar.item.disable = (settings.disable || []).slice(0);\n    calendar.item.enable = -function (collectionDisabled) {\n      return collectionDisabled[0] === true ? collectionDisabled.shift() : -1;\n    }(calendar.item.disable);\n    calendar.set('min', settings.min).set('max', settings.max).set('now'); // When thereâs a value, set the `select`, which in turn\n    // also sets the `highlight` and `view`.\n\n    if (valueString) {\n      calendar.set('select', valueString, {\n        format: formatString\n      });\n    } // If thereâs no value, default to highlighting âtodayâ.\n    else {\n        calendar.set('select', null).set('highlight', calendar.item.now);\n      } // The keycode to movement mapping.\n\n\n    calendar.key = {\n      40: 7,\n      // Down\n      38: -7,\n      // Up\n      39: function _() {\n        return isRTL() ? -1 : 1;\n      },\n      // Right\n      37: function _() {\n        return isRTL() ? 1 : -1;\n      },\n      // Left\n      go: function go(timeChange) {\n        var highlightedObject = calendar.item.highlight,\n            targetDate = new Date(highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange);\n        calendar.set('highlight', targetDate, {\n          interval: timeChange\n        });\n        this.render();\n      } // Bind some picker events.\n\n    };\n    picker.on('render', function () {\n      picker.$root.find('.' + settings.klass.selectMonth).on('change', function () {\n        var value = this.value;\n\n        if (value) {\n          picker.set('highlight', [picker.get('view').year, value, picker.get('highlight').date]);\n          picker.$root.find('.' + settings.klass.selectMonth).trigger('focus');\n        }\n      });\n      picker.$root.find('.' + settings.klass.selectYear).on('change', function () {\n        var value = this.value;\n\n        if (value) {\n          picker.set('highlight', [value, picker.get('view').month, picker.get('highlight').date]);\n          picker.$root.find('.' + settings.klass.selectYear).trigger('focus');\n        }\n      });\n    }, 1).on('open', function () {\n      var includeToday = '';\n\n      if (calendar.disabled(calendar.get('now'))) {\n        includeToday = ':not(.' + settings.klass.buttonToday + ')';\n      }\n\n      picker.$root.find('button' + includeToday + ', select').attr('disabled', false);\n    }, 1).on('close', function () {\n      picker.$root.find('button, select').attr('disabled', true);\n    }, 1);\n  } //DatePicker\n\n  /**\r\n   * Set a datepicker item object.\r\n   */\n\n\n  DatePicker.prototype.set = function (type, value, options) {\n    var calendar = this,\n        calendarItem = calendar.item; // If the value is `null` just set it immediately.\n\n    if (value === null) {\n      if (type == 'clear') type = 'select';\n      calendarItem[type] = value;\n      return calendar;\n    } // Otherwise go through the queue of methods, and invoke the functions.\n    // Update this as the time unit, and set the final value as this item.\n    // * In the case of `enable`, keep the queue but set `disable` instead.\n    //   And in the case of `flip`, keep the queue but set `enable` instead.\n\n\n    calendarItem[type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type] = calendar.queue[type].split(' ').map(function (method) {\n      value = calendar[method](type, value, options);\n      return value;\n    }).pop(); // Check if we need to cascade through more updates.\n\n    if (type == 'select') {\n      calendar.set('highlight', calendarItem.select, options);\n    } else if (type == 'highlight') {\n      calendar.set('view', calendarItem.highlight, options);\n    } else if (type.match(/^(flip|min|max|disable|enable)$/)) {\n      if (calendarItem.select && calendar.disabled(calendarItem.select)) {\n        calendar.set('select', calendarItem.select, options);\n      }\n\n      if (calendarItem.highlight && calendar.disabled(calendarItem.highlight)) {\n        calendar.set('highlight', calendarItem.highlight, options);\n      }\n    }\n\n    return calendar;\n  }; //DatePicker.prototype.set\n\n  /**\r\n   * Get a datepicker item object.\r\n   */\n\n\n  DatePicker.prototype.get = function (type) {\n    return this.item[type];\n  }; //DatePicker.prototype.get\n\n  /**\r\n   * Create a picker date object.\r\n   */\n\n\n  DatePicker.prototype.create = function (type, value, options) {\n    var isInfiniteValue,\n        calendar = this; // If thereâs no value, use the type as the value.\n\n    value = value === undefined ? type : value; // If itâs infinity, update the value.\n\n    if (value == -Infinity || value == Infinity) {\n      isInfiniteValue = value;\n    } // If itâs an object, use the native date object.\n    else if ($.isPlainObject(value) && _.isInteger(value.pick)) {\n        value = value.obj;\n      } // If itâs an array, convert it into a date and make sure\n      // that itâs a valid date â otherwise default to today.\n      else if ($.isArray(value)) {\n          value = new Date(value[0], value[1], value[2]);\n          value = _.isDate(value) ? value : calendar.create().obj;\n        } // If itâs a number or date object, make a normalized date.\n        else if (_.isInteger(value) || _.isDate(value)) {\n            value = calendar.normalize(new Date(value), options);\n          } // If itâs a literal true or any other case, set it to now.\n          else\n            /*if ( value === true )*/\n            {\n              value = calendar.now(type, value, options);\n            } // Return the compiled object.\n\n\n    return {\n      year: isInfiniteValue || value.getFullYear(),\n      month: isInfiniteValue || value.getMonth(),\n      date: isInfiniteValue || value.getDate(),\n      day: isInfiniteValue || value.getDay(),\n      obj: isInfiniteValue || value,\n      pick: isInfiniteValue || value.getTime()\n    };\n  }; //DatePicker.prototype.create\n\n  /**\r\n   * Create a range limit object using an array, date object,\r\n   * literal âtrueâ, or integer relative to another time.\r\n   */\n\n\n  DatePicker.prototype.createRange = function (from, to) {\n    var calendar = this,\n        createDate = function createDate(date) {\n      if (date === true || $.isArray(date) || _.isDate(date)) {\n        return calendar.create(date);\n      }\n\n      return date;\n    }; // Create objects if possible.\n\n\n    if (!_.isInteger(from)) {\n      from = createDate(from);\n    }\n\n    if (!_.isInteger(to)) {\n      to = createDate(to);\n    } // Create relative dates.\n\n\n    if (_.isInteger(from) && $.isPlainObject(to)) {\n      from = [to.year, to.month, to.date + from];\n    } else if (_.isInteger(to) && $.isPlainObject(from)) {\n      to = [from.year, from.month, from.date + to];\n    }\n\n    return {\n      from: createDate(from),\n      to: createDate(to)\n    };\n  }; //DatePicker.prototype.createRange\n\n  /**\r\n   * Check if a date unit falls within a date range object.\r\n   */\n\n\n  DatePicker.prototype.withinRange = function (range, dateUnit) {\n    range = this.createRange(range.from, range.to);\n    return dateUnit.pick >= range.from.pick && dateUnit.pick <= range.to.pick;\n  };\n  /**\r\n   * Check if two date range objects overlap.\r\n   */\n\n\n  DatePicker.prototype.overlapRanges = function (one, two) {\n    var calendar = this; // Convert the ranges into comparable dates.\n\n    one = calendar.createRange(one.from, one.to);\n    two = calendar.createRange(two.from, two.to);\n    return calendar.withinRange(one, two.from) || calendar.withinRange(one, two.to) || calendar.withinRange(two, one.from) || calendar.withinRange(two, one.to);\n  };\n  /**\r\n   * Get the date today.\r\n   */\n\n\n  DatePicker.prototype.now = function (type, value, options) {\n    value = new Date();\n\n    if (options && options.rel) {\n      value.setDate(value.getDate() + options.rel);\n    }\n\n    return this.normalize(value, options);\n  };\n  /**\r\n   * Navigate to next/prev month.\r\n   */\n\n\n  DatePicker.prototype.navigate = function (type, value, options) {\n    var targetDateObject,\n        targetYear,\n        targetMonth,\n        targetDate,\n        isTargetArray = $.isArray(value),\n        isTargetObject = $.isPlainObject(value),\n        viewsetObject = this.item.view;\n    /*,\r\n    safety = 100*/\n\n    if (isTargetArray || isTargetObject) {\n      if (isTargetObject) {\n        targetYear = value.year;\n        targetMonth = value.month;\n        targetDate = value.date;\n      } else {\n        targetYear = +value[0];\n        targetMonth = +value[1];\n        targetDate = +value[2];\n      } // If weâre navigating months but the view is in a different\n      // month, navigate to the viewâs year and month.\n\n\n      if (options && options.nav && viewsetObject && viewsetObject.month !== targetMonth) {\n        targetYear = viewsetObject.year;\n        targetMonth = viewsetObject.month;\n      } // Figure out the expected target year and month.\n\n\n      targetDateObject = new Date(targetYear, targetMonth + (options && options.nav ? options.nav : 0), 1);\n      targetYear = targetDateObject.getFullYear();\n      targetMonth = targetDateObject.getMonth(); // If the month weâre going to doesnât have enough days,\n      // keep decreasing the date until we reach the monthâs last date.\n\n      while (\n      /*safety &&*/\n      new Date(targetYear, targetMonth, targetDate).getMonth() !== targetMonth) {\n        targetDate -= 1;\n        /*safety -= 1\r\n        if ( !safety ) {\r\n            throw 'Fell into an infinite loop while navigating to ' + new Date( targetYear, targetMonth, targetDate ) + '.'\r\n        }*/\n      }\n\n      value = [targetYear, targetMonth, targetDate];\n    }\n\n    return value;\n  }; //DatePicker.prototype.navigate\n\n  /**\r\n   * Normalize a date by setting the hours to midnight.\r\n   */\n\n\n  DatePicker.prototype.normalize = function (value\n  /*, options*/\n  ) {\n    value.setHours(0, 0, 0, 0);\n    return value;\n  };\n  /**\r\n   * Measure the range of dates.\r\n   */\n\n\n  DatePicker.prototype.measure = function (type, value\n  /*, options*/\n  ) {\n    var calendar = this; // If itâs anything false-y, remove the limits.\n\n    if (!value) {\n      value = type == 'min' ? -Infinity : Infinity;\n    } // If itâs a string, parse it.\n    else if (typeof value == 'string') {\n        value = calendar.parse(type, value);\n      } // If it's an integer, get a date relative to today.\n      else if (_.isInteger(value)) {\n          value = calendar.now(type, value, {\n            rel: value\n          });\n        }\n\n    return value;\n  }; ///DatePicker.prototype.measure\n\n  /**\r\n   * Create a viewset object based on navigation.\r\n   */\n\n\n  DatePicker.prototype.viewset = function (type, dateObject\n  /*, options*/\n  ) {\n    return this.create([dateObject.year, dateObject.month, 1]);\n  };\n  /**\r\n   * Validate a date as enabled and shift if needed.\r\n   */\n\n\n  DatePicker.prototype.validate = function (type, dateObject, options) {\n    var calendar = this,\n        // Keep a reference to the original date.\n    originalDateObject = dateObject,\n        // Make sure we have an interval.\n    interval = options && options.interval ? options.interval : 1,\n        // Check if the calendar enabled dates are inverted.\n    isFlippedBase = calendar.item.enable === -1,\n        // Check if we have any enabled dates after/before now.\n    hasEnabledBeforeTarget,\n        hasEnabledAfterTarget,\n        // The min & max limits.\n    minLimitObject = calendar.item.min,\n        maxLimitObject = calendar.item.max,\n        // Check if weâve reached the limit during shifting.\n    reachedMin,\n        reachedMax,\n        // Check if the calendar is inverted and at least one weekday is enabled.\n    hasEnabledWeekdays = isFlippedBase && calendar.item.disable.filter(function (value) {\n      // If thereâs a date, check where it is relative to the target.\n      if ($.isArray(value)) {\n        var dateTime = calendar.create(value).pick;\n        if (dateTime < dateObject.pick) hasEnabledBeforeTarget = true;else if (dateTime > dateObject.pick) hasEnabledAfterTarget = true;\n      } // Return only integers for enabled weekdays.\n\n\n      return _.isInteger(value);\n    }).length;\n    /*,\r\n    safety = 100*/\n    // Cases to validate for:\n    // [1] Not inverted and date disabled.\n    // [2] Inverted and some dates enabled.\n    // [3] Not inverted and out of range.\n    //\n    // Cases to **not** validate for:\n    // â¢ Navigating months.\n    // â¢ Not inverted and date enabled.\n    // â¢ Inverted and all dates disabled.\n    // â¢ ..and anything else.\n\n    if (!options || !options.nav) if (\n    /* 1 */\n    !isFlippedBase && calendar.disabled(dateObject) ||\n    /* 2 */\n    isFlippedBase && calendar.disabled(dateObject) && (hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget) ||\n    /* 3 */\n    !isFlippedBase && (dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick)) {\n      // When inverted, flip the direction if there arenât any enabled weekdays\n      // and there are no enabled dates in the direction of the interval.\n      if (isFlippedBase && !hasEnabledWeekdays && (!hasEnabledAfterTarget && interval > 0 || !hasEnabledBeforeTarget && interval < 0)) {\n        interval *= -1;\n      } // Keep looping until we reach an enabled date.\n\n\n      while (\n      /*safety &&*/\n      calendar.disabled(dateObject)) {\n        /*safety -= 1\r\n        if ( !safety ) {\r\n            throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'\r\n        }*/\n        // If weâve looped into the next/prev month with a large interval, return to the original date and flatten the interval.\n        if (Math.abs(interval) > 1 && (dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month)) {\n          dateObject = originalDateObject;\n          interval = interval > 0 ? 1 : -1;\n        } // If weâve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.\n\n\n        if (dateObject.pick <= minLimitObject.pick) {\n          reachedMin = true;\n          interval = 1;\n          dateObject = calendar.create([minLimitObject.year, minLimitObject.month, minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1)]);\n        } else if (dateObject.pick >= maxLimitObject.pick) {\n          reachedMax = true;\n          interval = -1;\n          dateObject = calendar.create([maxLimitObject.year, maxLimitObject.month, maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1)]);\n        } // If weâve reached both limits, just break out of the loop.\n\n\n        if (reachedMin && reachedMax) {\n          break;\n        } // Finally, create the shifted date using the interval and keep looping.\n\n\n        dateObject = calendar.create([dateObject.year, dateObject.month, dateObject.date + interval]);\n      }\n    } //endif\n    // Return the date object settled on.\n\n    return dateObject;\n  }; //DatePicker.prototype.validate\n\n  /**\r\n   * Check if a date is disabled.\r\n   */\n\n\n  DatePicker.prototype.disabled = function (dateToVerify) {\n    var calendar = this,\n        // Filter through the disabled dates to check if this is one.\n    isDisabledMatch = calendar.item.disable.filter(function (dateToDisable) {\n      // If the date is a number, match the weekday with 0index and `firstDay` check.\n      if (_.isInteger(dateToDisable)) {\n        return dateToVerify.day === (calendar.settings.firstDay ? dateToDisable : dateToDisable - 1) % 7;\n      } // If itâs an array or a native JS date, create and match the exact date.\n\n\n      if ($.isArray(dateToDisable) || _.isDate(dateToDisable)) {\n        return dateToVerify.pick === calendar.create(dateToDisable).pick;\n      } // If itâs an object, match a date within the âfromâ and âtoâ range.\n\n\n      if ($.isPlainObject(dateToDisable)) {\n        return calendar.withinRange(dateToDisable, dateToVerify);\n      }\n    }); // If this date matches a disabled date, confirm itâs not inverted.\n\n    isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function (dateToDisable) {\n      return $.isArray(dateToDisable) && dateToDisable[3] == 'inverted' || $.isPlainObject(dateToDisable) && dateToDisable.inverted;\n    }).length; // Check the calendar âenabledâ flag and respectively flip the\n    // disabled state. Then also check if itâs beyond the min/max limits.\n\n    return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch || dateToVerify.pick < calendar.item.min.pick || dateToVerify.pick > calendar.item.max.pick;\n  }; //DatePicker.prototype.disabled\n\n  /**\r\n   * Parse a string into a usable type.\r\n   */\n\n\n  DatePicker.prototype.parse = function (type, value, options) {\n    var calendar = this,\n        parsingObject = {}; // If itâs already parsed, weâre good.\n\n    if (!value || typeof value != 'string') {\n      return value;\n    } // We need a `.format` to parse the value with.\n\n\n    if (!(options && options.format)) {\n      options = options || {};\n      options.format = calendar.settings.format;\n    } // Convert the format into an array and then map through it.\n\n\n    calendar.formats.toArray(options.format).map(function (label) {\n      var // Grab the formatting label.\n      formattingLabel = calendar.formats[label],\n          // The format length is from the formatting label function or the\n      // label length without the escaping exclamation (!) mark.\n      formatLength = formattingLabel ? _.trigger(formattingLabel, calendar, [value, parsingObject]) : label.replace(/^!/, '').length; // If there's a format label, split the value up to the format length.\n      // Then add it to the parsing object with appropriate label.\n\n      if (formattingLabel) {\n        parsingObject[label] = value.substr(0, formatLength);\n      } // Update the value as the substring from format length to end.\n\n\n      value = value.substr(formatLength);\n    }); // Compensate for month 0index.\n\n    return [parsingObject.yyyy || parsingObject.yy, +(parsingObject.mm || parsingObject.m) - 1, parsingObject.dd || parsingObject.d];\n  }; //DatePicker.prototype.parse\n\n  /**\r\n   * Various formats to display the object in.\r\n   */\n\n\n  DatePicker.prototype.formats = function () {\n    // Return the length of the first word in a collection.\n    function getWordLengthFromCollection(string, collection, dateObject) {\n      // Grab the first word from the string.\n      var word = string.match(/\\w+/)[0]; // If there's no month index, add it to the date object\n\n      if (!dateObject.mm && !dateObject.m) {\n        dateObject.m = collection.indexOf(word) + 1;\n      } // Return the length of the word.\n\n\n      return word.length;\n    } // Get the length of the first word in a string.\n\n\n    function getFirstWordLength(string) {\n      return string.match(/\\w+/)[0].length;\n    }\n\n    return {\n      d: function d(string, dateObject) {\n        // If there's string, then get the digits length.\n        // Otherwise return the selected date.\n        return string ? _.digits(string) : dateObject.date;\n      },\n      dd: function dd(string, dateObject) {\n        // If there's a string, then the length is always 2.\n        // Otherwise return the selected date with a leading zero.\n        return string ? 2 : _.lead(dateObject.date);\n      },\n      ddd: function ddd(string, dateObject) {\n        // If there's a string, then get the length of the first word.\n        // Otherwise return the short selected weekday.\n        return string ? getFirstWordLength(string) : this.settings.weekdaysShort[dateObject.day];\n      },\n      dddd: function dddd(string, dateObject) {\n        // If there's a string, then get the length of the first word.\n        // Otherwise return the full selected weekday.\n        return string ? getFirstWordLength(string) : this.settings.weekdaysFull[dateObject.day];\n      },\n      m: function m(string, dateObject) {\n        // If there's a string, then get the length of the digits\n        // Otherwise return the selected month with 0index compensation.\n        return string ? _.digits(string) : dateObject.month + 1;\n      },\n      mm: function mm(string, dateObject) {\n        // If there's a string, then the length is always 2.\n        // Otherwise return the selected month with 0index and leading zero.\n        return string ? 2 : _.lead(dateObject.month + 1);\n      },\n      mmm: function mmm(string, dateObject) {\n        var collection = this.settings.monthsShort; // If there's a string, get length of the relevant month from the short\n        // months collection. Otherwise return the selected month from that collection.\n\n        return string ? getWordLengthFromCollection(string, collection, dateObject) : collection[dateObject.month];\n      },\n      mmmm: function mmmm(string, dateObject) {\n        var collection = this.settings.monthsFull; // If there's a string, get length of the relevant month from the full\n        // months collection. Otherwise return the selected month from that collection.\n\n        return string ? getWordLengthFromCollection(string, collection, dateObject) : collection[dateObject.month];\n      },\n      yy: function yy(string, dateObject) {\n        // If there's a string, then the length is always 2.\n        // Otherwise return the selected year by slicing out the first 2 digits.\n        return string ? 2 : ('' + dateObject.year).slice(2);\n      },\n      yyyy: function yyyy(string, dateObject) {\n        // If there's a string, then the length is always 4.\n        // Otherwise return the selected year.\n        return string ? 4 : dateObject.year;\n      },\n      // Create an array by splitting the formatting string passed.\n      toArray: function toArray(formatString) {\n        return formatString.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);\n      },\n      // Format an object into a string using the formatting options.\n      toString: function toString(formatString, itemObject) {\n        var calendar = this;\n        return calendar.formats.toArray(formatString).map(function (label) {\n          return _.trigger(calendar.formats[label], calendar, [0, itemObject]) || label.replace(/^!/, '');\n        }).join('');\n      }\n    };\n  }(); //DatePicker.prototype.formats\n\n  /**\r\n   * Check if two date units are the exact.\r\n   */\n\n\n  DatePicker.prototype.isDateExact = function (one, two) {\n    var calendar = this; // When weâre working with weekdays, do a direct comparison.\n\n    if (_.isInteger(one) && _.isInteger(two) || typeof one == 'boolean' && typeof two == 'boolean') {\n      return one === two;\n    } // When weâre working with date representations, compare the âpickâ value.\n\n\n    if ((_.isDate(one) || $.isArray(one)) && (_.isDate(two) || $.isArray(two))) {\n      return calendar.create(one).pick === calendar.create(two).pick;\n    } // When weâre working with range objects, compare the âfromâ and âtoâ.\n\n\n    if ($.isPlainObject(one) && $.isPlainObject(two)) {\n      return calendar.isDateExact(one.from, two.from) && calendar.isDateExact(one.to, two.to);\n    }\n\n    return false;\n  };\n  /**\r\n   * Check if two date units overlap.\r\n   */\n\n\n  DatePicker.prototype.isDateOverlap = function (one, two) {\n    var calendar = this,\n        firstDay = calendar.settings.firstDay ? 1 : 0; // When weâre working with a weekday index, compare the days.\n\n    if (_.isInteger(one) && (_.isDate(two) || $.isArray(two))) {\n      one = one % 7 + firstDay;\n      return one === calendar.create(two).day + 1;\n    }\n\n    if (_.isInteger(two) && (_.isDate(one) || $.isArray(one))) {\n      two = two % 7 + firstDay;\n      return two === calendar.create(one).day + 1;\n    } // When weâre working with range objects, check if the ranges overlap.\n\n\n    if ($.isPlainObject(one) && $.isPlainObject(two)) {\n      return calendar.overlapRanges(one, two);\n    }\n\n    return false;\n  };\n  /**\r\n   * Flip the âenabledâ state.\r\n   */\n\n\n  DatePicker.prototype.flipEnable = function (val) {\n    var itemObject = this.item;\n    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1);\n  };\n  /**\r\n   * Mark a collection of dates as âdisabledâ.\r\n   */\n\n\n  DatePicker.prototype.deactivate = function (type, datesToDisable) {\n    var calendar = this,\n        disabledItems = calendar.item.disable.slice(0); // If weâre flipping, thatâs all we need to do.\n\n    if (datesToDisable == 'flip') {\n      calendar.flipEnable();\n    } else if (datesToDisable === false) {\n      calendar.flipEnable(1);\n      disabledItems = [];\n    } else if (datesToDisable === true) {\n      calendar.flipEnable(-1);\n      disabledItems = [];\n    } // Otherwise go through the dates to disable.\n    else {\n        datesToDisable.map(function (unitToDisable) {\n          var matchFound; // When we have disabled items, check for matches.\n          // If something is matched, immediately break out.\n\n          for (var index = 0; index < disabledItems.length; index += 1) {\n            if (calendar.isDateExact(unitToDisable, disabledItems[index])) {\n              matchFound = true;\n              break;\n            }\n          } // If nothing was found, add the validated unit to the collection.\n\n\n          if (!matchFound) {\n            if (_.isInteger(unitToDisable) || _.isDate(unitToDisable) || $.isArray(unitToDisable) || $.isPlainObject(unitToDisable) && unitToDisable.from && unitToDisable.to) {\n              disabledItems.push(unitToDisable);\n            }\n          }\n        });\n      } // Return the updated collection.\n\n\n    return disabledItems;\n  }; //DatePicker.prototype.deactivate\n\n  /**\r\n   * Mark a collection of dates as âenabledâ.\r\n   */\n\n\n  DatePicker.prototype.activate = function (type, datesToEnable) {\n    var calendar = this,\n        disabledItems = calendar.item.disable,\n        disabledItemsCount = disabledItems.length; // If weâre flipping, thatâs all we need to do.\n\n    if (datesToEnable == 'flip') {\n      calendar.flipEnable();\n    } else if (datesToEnable === true) {\n      calendar.flipEnable(1);\n      disabledItems = [];\n    } else if (datesToEnable === false) {\n      calendar.flipEnable(-1);\n      disabledItems = [];\n    } // Otherwise go through the disabled dates.\n    else {\n        datesToEnable.map(function (unitToEnable) {\n          var matchFound, disabledUnit, index, isExactRange; // Go through the disabled items and try to find a match.\n\n          for (index = 0; index < disabledItemsCount; index += 1) {\n            disabledUnit = disabledItems[index]; // When an exact match is found, remove it from the collection.\n\n            if (calendar.isDateExact(disabledUnit, unitToEnable)) {\n              matchFound = disabledItems[index] = null;\n              isExactRange = true;\n              break;\n            } // When an overlapped match is found, add the âinvertedâ state to it.\n            else if (calendar.isDateOverlap(disabledUnit, unitToEnable)) {\n                if ($.isPlainObject(unitToEnable)) {\n                  unitToEnable.inverted = true;\n                  matchFound = unitToEnable;\n                } else if ($.isArray(unitToEnable)) {\n                  matchFound = unitToEnable;\n                  if (!matchFound[3]) matchFound.push('inverted');\n                } else if (_.isDate(unitToEnable)) {\n                  matchFound = [unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted'];\n                }\n\n                break;\n              }\n          } // If a match was found, remove a previous duplicate entry.\n\n\n          if (matchFound) for (index = 0; index < disabledItemsCount; index += 1) {\n            if (calendar.isDateExact(disabledItems[index], unitToEnable)) {\n              disabledItems[index] = null;\n              break;\n            }\n          } // In the event that weâre dealing with an exact range of dates,\n          // make sure there are no âinvertedâ dates because of it.\n\n          if (isExactRange) for (index = 0; index < disabledItemsCount; index += 1) {\n            if (calendar.isDateOverlap(disabledItems[index], unitToEnable)) {\n              disabledItems[index] = null;\n              break;\n            }\n          } // If something is still matched, add it into the collection.\n\n          if (matchFound) {\n            disabledItems.push(matchFound);\n          }\n        });\n      } // Return the updated collection.\n\n\n    return disabledItems.filter(function (val) {\n      return val != null;\n    });\n  }; //DatePicker.prototype.activate\n\n  /**\r\n   * Create a string for the nodes in the picker.\r\n   */\n\n\n  DatePicker.prototype.nodes = function (isOpen) {\n    var calendar = this,\n        settings = calendar.settings,\n        calendarItem = calendar.item,\n        nowObject = calendarItem.now,\n        selectedObject = calendarItem.select,\n        highlightedObject = calendarItem.highlight,\n        viewsetObject = calendarItem.view,\n        disabledCollection = calendarItem.disable,\n        minLimitObject = calendarItem.min,\n        maxLimitObject = calendarItem.max,\n        // Create the calendar table head using a copy of weekday labels collection.\n    // * We do a copy so we don't mutate the original array.\n    tableHead = function (collection, fullCollection) {\n      // If the first day should be Monday, move Sunday to the end.\n      if (settings.firstDay) {\n        collection.push(collection.shift());\n        fullCollection.push(fullCollection.shift());\n      } // Create and return the table head group.\n\n\n      return _.node('thead', _.node('tr', _.group({\n        min: 0,\n        max: DAYS_IN_WEEK - 1,\n        i: 1,\n        node: 'th',\n        item: function item(counter) {\n          return [collection[counter], settings.klass.weekdays, 'scope=col title=\"' + fullCollection[counter] + '\"'];\n        }\n      }))); //endreturn\n      // Materialize modified\n    }((settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysLetter).slice(0), settings.weekdaysFull.slice(0)),\n        //tableHead\n    // Create the nav for next/prev month.\n    createMonthNav = function createMonthNav(next) {\n      // Otherwise, return the created month tag.\n      return _.node('div', ' ', settings.klass['nav' + (next ? 'Next' : 'Prev')] + ( // If the focused month is outside the range, disabled the button.\n      next && viewsetObject.year >= maxLimitObject.year && viewsetObject.month >= maxLimitObject.month || !next && viewsetObject.year <= minLimitObject.year && viewsetObject.month <= minLimitObject.month ? ' ' + settings.klass.navDisabled : ''), 'data-nav=' + (next || -1) + ' ' + _.ariaAttr({\n        role: 'button',\n        controls: calendar.$node[0].id + '_table'\n      }) + ' ' + 'title=\"' + (next ? settings.labelMonthNext : settings.labelMonthPrev) + '\"'); //endreturn\n    },\n        //createMonthNav\n    // Create the month label.\n    //Materialize modified\n    createMonthLabel = function createMonthLabel(override) {\n      var monthsCollection = settings.showMonthsShort ? settings.monthsShort : settings.monthsFull; // Materialize modified\n\n      if (override == \"short_months\") {\n        monthsCollection = settings.monthsShort;\n      } // If there are months to select, add a dropdown menu.\n\n\n      if (settings.selectMonths && override == undefined) {\n        return _.node('select', _.group({\n          min: 0,\n          max: 11,\n          i: 1,\n          node: 'option',\n          item: function item(loopedMonth) {\n            return [// The looped month and no classes.\n            monthsCollection[loopedMonth], 0, // Set the value and selected index.\n            'value=' + loopedMonth + (viewsetObject.month == loopedMonth ? ' selected' : '') + (viewsetObject.year == minLimitObject.year && loopedMonth < minLimitObject.month || viewsetObject.year == maxLimitObject.year && loopedMonth > maxLimitObject.month ? ' disabled' : '')];\n          }\n        }), settings.klass.selectMonth + ' browser-default', (isOpen ? '' : 'disabled') + ' ' + _.ariaAttr({\n          controls: calendar.$node[0].id + '_table'\n        }) + ' ' + 'title=\"' + settings.labelMonthSelect + '\"');\n      } // Materialize modified\n\n\n      if (override == \"short_months\") if (selectedObject != null) return monthsCollection[selectedObject.month];else return monthsCollection[viewsetObject.month]; // If there's a need for a month selector\n\n      return _.node('div', monthsCollection[viewsetObject.month], settings.klass.month);\n    },\n        //createMonthLabel\n    // Create the year label.\n    // Materialize modified\n    createYearLabel = function createYearLabel(override) {\n      var focusedYear = viewsetObject.year,\n          // If years selector is set to a literal \"true\", set it to 5. Otherwise\n      // divide in half to get half before and half after focused year.\n      numberYears = settings.selectYears === true ? 5 : ~~(settings.selectYears / 2); // If there are years to select, add a dropdown menu.\n\n      if (numberYears) {\n        var minYear = minLimitObject.year,\n            maxYear = maxLimitObject.year,\n            lowestYear = focusedYear - numberYears,\n            highestYear = focusedYear + numberYears; // If the min year is greater than the lowest year, increase the highest year\n        // by the difference and set the lowest year to the min year.\n\n        if (minYear > lowestYear) {\n          highestYear += minYear - lowestYear;\n          lowestYear = minYear;\n        } // If the max year is less than the highest year, decrease the lowest year\n        // by the lower of the two: available and needed years. Then set the\n        // highest year to the max year.\n\n\n        if (maxYear < highestYear) {\n          var availableYears = lowestYear - minYear,\n              neededYears = highestYear - maxYear;\n          lowestYear -= availableYears > neededYears ? neededYears : availableYears;\n          highestYear = maxYear;\n        }\n\n        if (settings.selectYears && override == undefined) {\n          return _.node('select', _.group({\n            min: lowestYear,\n            max: highestYear,\n            i: 1,\n            node: 'option',\n            item: function item(loopedYear) {\n              return [// The looped year and no classes.\n              loopedYear, 0, // Set the value and selected index.\n              'value=' + loopedYear + (focusedYear == loopedYear ? ' selected' : '')];\n            }\n          }), settings.klass.selectYear + ' browser-default', (isOpen ? '' : 'disabled') + ' ' + _.ariaAttr({\n            controls: calendar.$node[0].id + '_table'\n          }) + ' ' + 'title=\"' + settings.labelYearSelect + '\"');\n        }\n      } // Materialize modified\n\n\n      if (override === 'raw' && selectedObject != null) {\n        return _.node('div', selectedObject.year);\n      } // Otherwise just return the year focused\n\n\n      return _.node('div', focusedYear, settings.klass.year);\n    }; //createYearLabel\n    // Materialize modified\n\n\n    createDayLabel = function createDayLabel() {\n      if (selectedObject != null) return selectedObject.date;else return nowObject.date;\n    };\n\n    createWeekdayLabel = function createWeekdayLabel() {\n      var display_day;\n      if (selectedObject != null) display_day = selectedObject.day;else display_day = nowObject.day;\n      var weekday = settings.weekdaysShort[display_day];\n      return weekday;\n    }; // Create and return the entire calendar.\n\n\n    return _.node( // Date presentation View\n    'div', _.node( // Div for Year\n    'div', createYearLabel(\"raw\"), settings.klass.year_display) + _.node('span', createWeekdayLabel() + ', ', \"picker__weekday-display\") + _.node( // Div for short Month\n    'span', createMonthLabel(\"short_months\") + ' ', settings.klass.month_display) + _.node( // Div for Day\n    'span', createDayLabel(), settings.klass.day_display), settings.klass.date_display) + // Calendar container\n    _.node('div', _.node('div', _.node('div', (settings.selectYears ? createMonthLabel() + createYearLabel() : createMonthLabel() + createYearLabel()) + createMonthNav() + createMonthNav(1), settings.klass.header) + _.node('table', tableHead + _.node('tbody', _.group({\n      min: 0,\n      max: WEEKS_IN_CALENDAR - 1,\n      i: 1,\n      node: 'tr',\n      item: function item(rowCounter) {\n        // If Monday is the first day and the month starts on Sunday, shift the date back a week.\n        var shiftDateBy = settings.firstDay && calendar.create([viewsetObject.year, viewsetObject.month, 1]).day === 0 ? -7 : 0;\n        return [_.group({\n          min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1,\n          // Add 1 for weekday 0index\n          max: function max() {\n            return this.min + DAYS_IN_WEEK - 1;\n          },\n          i: 1,\n          node: 'td',\n          item: function item(targetDate) {\n            // Convert the time date from a relative date to a target date.\n            targetDate = calendar.create([viewsetObject.year, viewsetObject.month, targetDate + (settings.firstDay ? 1 : 0)]);\n\n            var isSelected = selectedObject && selectedObject.pick == targetDate.pick,\n                isHighlighted = highlightedObject && highlightedObject.pick == targetDate.pick,\n                isDisabled = disabledCollection && calendar.disabled(targetDate) || targetDate.pick < minLimitObject.pick || targetDate.pick > maxLimitObject.pick,\n                formattedDate = _.trigger(calendar.formats.toString, calendar, [settings.format, targetDate]);\n\n            return [_.node('div', targetDate.date, function (klasses) {\n              // Add the `infocus` or `outfocus` classes based on month in view.\n              klasses.push(viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus); // Add the `today` class if needed.\n\n              if (nowObject.pick == targetDate.pick) {\n                klasses.push(settings.klass.now);\n              } // Add the `selected` class if something's selected and the time matches.\n\n\n              if (isSelected) {\n                klasses.push(settings.klass.selected);\n              } // Add the `highlighted` class if something's highlighted and the time matches.\n\n\n              if (isHighlighted) {\n                klasses.push(settings.klass.highlighted);\n              } // Add the `disabled` class if something's disabled and the object matches.\n\n\n              if (isDisabled) {\n                klasses.push(settings.klass.disabled);\n              }\n\n              return klasses.join(' ');\n            }([settings.klass.day]), 'data-pick=' + targetDate.pick + ' ' + _.ariaAttr({\n              role: 'gridcell',\n              label: formattedDate,\n              selected: isSelected && calendar.$node.val() === formattedDate ? true : null,\n              activedescendant: isHighlighted ? true : null,\n              disabled: isDisabled ? true : null\n            }) + ' ' + (isDisabled ? '' : 'tabindex=\"0\"')), '', _.ariaAttr({\n              role: 'presentation'\n            })]; //endreturn\n          }\n        })]; //endreturn\n      }\n    })), settings.klass.table, 'id=\"' + calendar.$node[0].id + '_table' + '\" ' + _.ariaAttr({\n      role: 'grid',\n      controls: calendar.$node[0].id,\n      readonly: true\n    })), settings.klass.calendar_container) // end calendar\n    + // * For Firefox forms to submit, make sure to set the buttonsâ `type` attributes as âbuttonâ.\n    _.node('div', _.node('button', settings.today, \"btn-flat picker__today waves-effect\", 'type=button data-pick=' + nowObject.pick + (isOpen && !calendar.disabled(nowObject) ? '' : ' disabled') + ' ' + _.ariaAttr({\n      controls: calendar.$node[0].id\n    })) + _.node('button', settings.clear, \"btn-flat picker__clear waves-effect\", 'type=button data-clear=1' + (isOpen ? '' : ' disabled') + ' ' + _.ariaAttr({\n      controls: calendar.$node[0].id\n    })) + _.node('button', settings.close, \"btn-flat picker__close waves-effect\", 'type=button data-close=true ' + (isOpen ? '' : ' disabled') + ' ' + _.ariaAttr({\n      controls: calendar.$node[0].id\n    })), settings.klass.footer), 'picker__container__wrapper'); //endreturn\n  }; //DatePicker.prototype.nodes\n\n  /**\r\n   * The date picker defaults.\r\n   */\n\n\n  DatePicker.defaults = function (prefix) {\n    return {\n      // The title label to use for the month nav buttons\n      labelMonthNext: 'Next month',\n      labelMonthPrev: 'Previous month',\n      // The title label to use for the dropdown selectors\n      labelMonthSelect: 'Select a month',\n      labelYearSelect: 'Select a year',\n      // Months and weekdays\n      monthsFull: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n      monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n      weekdaysFull: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n      weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n      // Materialize modified\n      weekdaysLetter: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n      // Today and clear\n      today: 'Today',\n      clear: 'Clear',\n      close: 'Ok',\n      // Picker close behavior (Prevent a change in behaviour for backwards compatibility)\n      closeOnSelect: false,\n      // The format to show on the `input` element\n      format: 'd mmmm, yyyy',\n      // Classes\n      klass: {\n        table: prefix + 'table',\n        header: prefix + 'header',\n        // Materialize Added klasses\n        date_display: prefix + 'date-display',\n        day_display: prefix + 'day-display',\n        month_display: prefix + 'month-display',\n        year_display: prefix + 'year-display',\n        calendar_container: prefix + 'calendar-container',\n        // end\n        navPrev: prefix + 'nav--prev',\n        navNext: prefix + 'nav--next',\n        navDisabled: prefix + 'nav--disabled',\n        month: prefix + 'month',\n        year: prefix + 'year',\n        selectMonth: prefix + 'select--month',\n        selectYear: prefix + 'select--year',\n        weekdays: prefix + 'weekday',\n        day: prefix + 'day',\n        disabled: prefix + 'day--disabled',\n        selected: prefix + 'day--selected',\n        highlighted: prefix + 'day--highlighted',\n        now: prefix + 'day--today',\n        infocus: prefix + 'day--infocus',\n        outfocus: prefix + 'day--outfocus',\n        footer: prefix + 'footer',\n        buttonClear: prefix + 'button--clear',\n        buttonToday: prefix + 'button--today',\n        buttonClose: prefix + 'button--close'\n      }\n    };\n  }(Picker.klasses().picker + '__');\n  /**\r\n   * Extend the picker to add the date picker.\r\n   */\n\n\n  Picker.extend('pickadate', DatePicker);\n});\n\n;\n/*!\r\n* ClockPicker v0.0.7 (http://weareoutman.github.io/clockpicker/)\r\n* Copyright 2014 Wang Shenwei.\r\n* Licensed under MIT (https://github.com/weareoutman/clockpicker/blob/gh-pages/LICENSE)\r\n*\r\n* Further modified\r\n* Copyright 2015 Ching Yaw Hao.\r\n*/\n\n(function ($) {\n  var $win = $(window),\n      $doc = $(document); // Can I use inline svg ?\n\n  var svgNS = 'http://www.w3.org/2000/svg',\n      svgSupported = 'SVGAngle' in window && function () {\n    var supported,\n        el = document.createElement('div');\n    el.innerHTML = '<svg/>';\n    supported = (el.firstChild && el.firstChild.namespaceURI) == svgNS;\n    el.innerHTML = '';\n    return supported;\n  }(); // Can I use transition ?\n\n\n  var transitionSupported = function () {\n    var style = document.createElement('div').style;\n    return 'transition' in style || 'WebkitTransition' in style || 'MozTransition' in style || 'msTransition' in style || 'OTransition' in style;\n  }(); // Listen touch events in touch screen device, instead of mouse events in desktop.\n\n\n  var touchSupported = 'ontouchstart' in window,\n      mousedownEvent = 'mousedown' + (touchSupported ? ' touchstart' : ''),\n      mousemoveEvent = 'mousemove.clockpicker' + (touchSupported ? ' touchmove.clockpicker' : ''),\n      mouseupEvent = 'mouseup.clockpicker' + (touchSupported ? ' touchend.clockpicker' : ''); // Vibrate the device if supported\n\n  var vibrate = navigator.vibrate ? 'vibrate' : navigator.webkitVibrate ? 'webkitVibrate' : null;\n\n  function createSvgElement(name) {\n    return document.createElementNS(svgNS, name);\n  }\n\n  function leadingZero(num) {\n    return (num < 10 ? '0' : '') + num;\n  } // Get a unique id\n\n\n  var idCounter = 0;\n\n  function uniqueId(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  } // Clock size\n\n\n  var dialRadius = 135,\n      outerRadius = 105,\n      // innerRadius = 80 on 12 hour clock\n  innerRadius = 70,\n      tickRadius = 20,\n      diameter = dialRadius * 2,\n      duration = transitionSupported ? 350 : 1; // Popover template\n\n  var tpl = ['<div class=\"clockpicker picker\">', '<div class=\"picker__holder\">', '<div class=\"picker__frame\">', '<div class=\"picker__wrap\">', '<div class=\"picker__box\">', '<div class=\"picker__date-display\">', '<div class=\"clockpicker-display\">', '<div class=\"clockpicker-display-column\">', '<span class=\"clockpicker-span-hours text-primary\"></span>', ':', '<span class=\"clockpicker-span-minutes\"></span>', '</div>', '<div class=\"clockpicker-display-column clockpicker-display-am-pm\">', '<div class=\"clockpicker-span-am-pm\"></div>', '</div>', '</div>', '</div>', '<div class=\"picker__container__wrapper\">', '<div class=\"picker__calendar-container\">', '<div class=\"clockpicker-plate\">', '<div class=\"clockpicker-canvas\"></div>', '<div class=\"clockpicker-dial clockpicker-hours\"></div>', '<div class=\"clockpicker-dial clockpicker-minutes clockpicker-dial-out\"></div>', '</div>', '<div class=\"clockpicker-am-pm-block\">', '</div>', '</div>', '<div class=\"picker__footer\">', '</div>', '</div>', '</div>', '</div>', '</div>', '</div>', '</div>'].join(''); // ClockPicker\n\n  function ClockPicker(element, options) {\n    var popover = $(tpl),\n        plate = popover.find('.clockpicker-plate'),\n        holder = popover.find('.picker__holder'),\n        hoursView = popover.find('.clockpicker-hours'),\n        minutesView = popover.find('.clockpicker-minutes'),\n        amPmBlock = popover.find('.clockpicker-am-pm-block'),\n        isInput = element.prop('tagName') === 'INPUT',\n        input = isInput ? element : element.find('input'),\n        label = $(\"label[for=\" + input.attr(\"id\") + \"]\"),\n        self = this;\n    this.id = uniqueId('cp');\n    this.element = element;\n    this.holder = holder;\n    this.options = options;\n    this.isAppended = false;\n    this.isShown = false;\n    this.currentView = 'hours';\n    this.isInput = isInput;\n    this.input = input;\n    this.label = label;\n    this.popover = popover;\n    this.plate = plate;\n    this.hoursView = hoursView;\n    this.minutesView = minutesView;\n    this.amPmBlock = amPmBlock;\n    this.spanHours = popover.find('.clockpicker-span-hours');\n    this.spanMinutes = popover.find('.clockpicker-span-minutes');\n    this.spanAmPm = popover.find('.clockpicker-span-am-pm');\n    this.footer = popover.find('.picker__footer');\n    this.amOrPm = \"PM\"; // Setup for for 12 hour clock if option is selected\n\n    if (options.twelvehour) {\n      if (!options.ampmclickable) {\n        this.spanAmPm.empty();\n        $('<div id=\"click-am\">AM</div>').appendTo(this.spanAmPm);\n        $('<div id=\"click-pm\">PM</div>').appendTo(this.spanAmPm);\n      } else {\n        this.spanAmPm.empty();\n        $('<div id=\"click-am\">AM</div>').on(\"click\", function () {\n          self.spanAmPm.children('#click-am').addClass(\"text-primary\");\n          self.spanAmPm.children('#click-pm').removeClass(\"text-primary\");\n          self.amOrPm = \"AM\";\n        }).appendTo(this.spanAmPm);\n        $('<div id=\"click-pm\">PM</div>').on(\"click\", function () {\n          self.spanAmPm.children('#click-pm').addClass(\"text-primary\");\n          self.spanAmPm.children('#click-am').removeClass(\"text-primary\");\n          self.amOrPm = 'PM';\n        }).appendTo(this.spanAmPm);\n      }\n    } // Add buttons to footer\n\n\n    $('<button type=\"button\" class=\"btn-flat picker__clear\" tabindex=\"' + (options.twelvehour ? '3' : '1') + '\">' + options.cleartext + '</button>').click($.proxy(this.clear, this)).appendTo(this.footer);\n    $('<button type=\"button\" class=\"btn-flat picker__close\" tabindex=\"' + (options.twelvehour ? '3' : '1') + '\">' + options.canceltext + '</button>').click($.proxy(this.hide, this)).appendTo(this.footer);\n    $('<button type=\"button\" class=\"btn-flat picker__close\" tabindex=\"' + (options.twelvehour ? '3' : '1') + '\">' + options.donetext + '</button>').click($.proxy(this.done, this)).appendTo(this.footer);\n    this.spanHours.click($.proxy(this.toggleView, this, 'hours'));\n    this.spanMinutes.click($.proxy(this.toggleView, this, 'minutes')); // Show or toggle\n\n    input.on('focus.clockpicker click.clockpicker', $.proxy(this.show, this)); // Build ticks\n\n    var tickTpl = $('<div class=\"clockpicker-tick\"></div>'),\n        i,\n        tick,\n        radian,\n        radius; // Hours view\n\n    if (options.twelvehour) {\n      for (i = 1; i < 13; i += 1) {\n        tick = tickTpl.clone();\n        radian = i / 6 * Math.PI;\n        radius = outerRadius;\n        tick.css({\n          left: dialRadius + Math.sin(radian) * radius - tickRadius,\n          top: dialRadius - Math.cos(radian) * radius - tickRadius\n        });\n        tick.html(i === 0 ? '00' : i);\n        hoursView.append(tick);\n        tick.on(mousedownEvent, mousedown);\n      }\n    } else {\n      for (i = 0; i < 24; i += 1) {\n        tick = tickTpl.clone();\n        radian = i / 6 * Math.PI;\n        var inner = i > 0 && i < 13;\n        radius = inner ? innerRadius : outerRadius;\n        tick.css({\n          left: dialRadius + Math.sin(radian) * radius - tickRadius,\n          top: dialRadius - Math.cos(radian) * radius - tickRadius\n        });\n        tick.html(i === 0 ? '00' : i);\n        hoursView.append(tick);\n        tick.on(mousedownEvent, mousedown);\n      }\n    } // Minutes view\n\n\n    for (i = 0; i < 60; i += 5) {\n      tick = tickTpl.clone();\n      radian = i / 30 * Math.PI;\n      tick.css({\n        left: dialRadius + Math.sin(radian) * outerRadius - tickRadius,\n        top: dialRadius - Math.cos(radian) * outerRadius - tickRadius\n      });\n      tick.html(leadingZero(i));\n      minutesView.append(tick);\n      tick.on(mousedownEvent, mousedown);\n    } // Clicking on minutes view space\n\n\n    plate.on(mousedownEvent, function (e) {\n      if ($(e.target).closest('.clockpicker-tick').length === 0) {\n        mousedown(e, true);\n      }\n    }); // Mousedown or touchstart\n\n    function mousedown(e, space) {\n      var offset = plate.offset(),\n          isTouch = /^touch/.test(e.type),\n          x0 = offset.left + dialRadius,\n          y0 = offset.top + dialRadius,\n          dx = (isTouch ? e.originalEvent.touches[0] : e).pageX - x0,\n          dy = (isTouch ? e.originalEvent.touches[0] : e).pageY - y0,\n          z = Math.sqrt(dx * dx + dy * dy),\n          moved = false; // When clicking on minutes view space, check the mouse position\n\n      if (space && (z < outerRadius - tickRadius || z > outerRadius + tickRadius)) {\n        return;\n      }\n\n      e.preventDefault(); // Set cursor style of body after 200ms\n\n      var movingTimer = setTimeout(function () {\n        self.popover.addClass('clockpicker-moving');\n      }, 200); // Clock\n\n      self.setHand(dx, dy, !space, true); // Mousemove on document\n\n      $doc.off(mousemoveEvent).on(mousemoveEvent, function (e) {\n        e.preventDefault();\n        var isTouch = /^touch/.test(e.type),\n            x = (isTouch ? e.originalEvent.touches[0] : e).pageX - x0,\n            y = (isTouch ? e.originalEvent.touches[0] : e).pageY - y0;\n\n        if (!moved && x === dx && y === dy) {\n          // Clicking in chrome on windows will trigger a mousemove event\n          return;\n        }\n\n        moved = true;\n        self.setHand(x, y, false, true);\n      }); // Mouseup on document\n\n      $doc.off(mouseupEvent).on(mouseupEvent, function (e) {\n        $doc.off(mouseupEvent);\n        e.preventDefault();\n        var isTouch = /^touch/.test(e.type),\n            x = (isTouch ? e.originalEvent.changedTouches[0] : e).pageX - x0,\n            y = (isTouch ? e.originalEvent.changedTouches[0] : e).pageY - y0;\n\n        if ((space || moved) && x === dx && y === dy) {\n          self.setHand(x, y);\n        }\n\n        if (self.currentView === 'hours') {\n          self.toggleView('minutes', duration / 2);\n        } else if (options.autoclose) {\n          self.minutesView.addClass('clockpicker-dial-out');\n          setTimeout(function () {\n            self.done();\n          }, duration / 2);\n        }\n\n        plate.prepend(canvas); // Reset cursor style of body\n\n        clearTimeout(movingTimer);\n        self.popover.removeClass('clockpicker-moving'); // Unbind mousemove event\n\n        $doc.off(mousemoveEvent);\n      });\n    }\n\n    if (svgSupported) {\n      // Draw clock hands and others\n      var canvas = popover.find('.clockpicker-canvas'),\n          svg = createSvgElement('svg');\n      svg.setAttribute('class', 'clockpicker-svg');\n      svg.setAttribute('width', diameter);\n      svg.setAttribute('height', diameter);\n      var g = createSvgElement('g');\n      g.setAttribute('transform', 'translate(' + dialRadius + ',' + dialRadius + ')');\n      var bearing = createSvgElement('circle');\n      bearing.setAttribute('class', 'clockpicker-canvas-bearing');\n      bearing.setAttribute('cx', 0);\n      bearing.setAttribute('cy', 0);\n      bearing.setAttribute('r', 4);\n      var hand = createSvgElement('line');\n      hand.setAttribute('x1', 0);\n      hand.setAttribute('y1', 0);\n      var bg = createSvgElement('circle');\n      bg.setAttribute('class', 'clockpicker-canvas-bg');\n      bg.setAttribute('r', tickRadius);\n      g.appendChild(hand);\n      g.appendChild(bg);\n      g.appendChild(bearing);\n      svg.appendChild(g);\n      canvas.append(svg);\n      this.hand = hand;\n      this.bg = bg;\n      this.bearing = bearing;\n      this.g = g;\n      this.canvas = canvas;\n    }\n\n    raiseCallback(this.options.init);\n  }\n\n  function raiseCallback(callbackFunction) {\n    if (callbackFunction && typeof callbackFunction === \"function\") callbackFunction();\n  } // Default options\n\n\n  ClockPicker.DEFAULTS = {\n    'default': '',\n    // default time, 'now' or '13:14' e.g.\n    fromnow: 0,\n    // set default time to * milliseconds from now (using with default = 'now')\n    donetext: 'Ok',\n    // done button text\n    cleartext: 'Clear',\n    canceltext: 'Cancel',\n    autoclose: false,\n    // auto close when minute is selected\n    ampmclickable: true,\n    // set am/pm button on itself\n    darktheme: false,\n    // set to dark theme\n    twelvehour: true,\n    // change to 12 hour AM/PM clock from 24 hour\n    vibrate: true // vibrate the device when dragging clock hand\n\n  }; // Show or hide popover\n\n  ClockPicker.prototype.toggle = function () {\n    this[this.isShown ? 'hide' : 'show']();\n  }; // Set popover position\n\n\n  ClockPicker.prototype.locate = function () {\n    var element = this.element,\n        popover = this.popover,\n        offset = element.offset(),\n        width = element.outerWidth(),\n        height = element.outerHeight(),\n        align = this.options.align,\n        self = this;\n    popover.show();\n  }; // Show popover\n\n\n  ClockPicker.prototype.show = function (e) {\n    // Not show again\n    if (this.isShown) {\n      return;\n    }\n\n    raiseCallback(this.options.beforeShow);\n    $(':input').each(function () {\n      $(this).attr('tabindex', -1);\n    });\n    var self = this; // Initialize\n\n    this.input.blur();\n    this.popover.addClass('picker--opened');\n    this.input.addClass('picker__input picker__input--active');\n    $(document.body).css('overflow', 'hidden'); // Get the time\n\n    var value = ((this.input.prop('value') || this.options['default'] || '') + '').split(':');\n\n    if (this.options.twelvehour && !(typeof value[1] === 'undefined')) {\n      if (value[1].indexOf(\"AM\") > 0) {\n        this.amOrPm = 'AM';\n      } else {\n        this.amOrPm = 'PM';\n      }\n\n      value[1] = value[1].replace(\"AM\", \"\").replace(\"PM\", \"\");\n    }\n\n    if (value[0] === 'now') {\n      var now = new Date(+new Date() + this.options.fromnow);\n      value = [now.getHours(), now.getMinutes()];\n\n      if (this.options.twelvehour) {\n        this.amOrPm = value[0] >= 12 && value[0] < 24 ? 'PM' : 'AM';\n      }\n    }\n\n    this.hours = +value[0] || 0;\n    this.minutes = +value[1] || 0;\n    this.spanHours.html(this.hours);\n    this.spanMinutes.html(leadingZero(this.minutes));\n\n    if (!this.isAppended) {\n      // Append popover to input by default\n      var containerEl = document.querySelector(this.options.container);\n\n      if (this.options.container && containerEl) {\n        containerEl.appendChild(this.popover[0]);\n      } else {\n        this.popover.insertAfter(this.input);\n      }\n\n      if (this.options.twelvehour) {\n        if (this.amOrPm === 'PM') {\n          this.spanAmPm.children('#click-pm').addClass(\"text-primary\");\n          this.spanAmPm.children('#click-am').removeClass(\"text-primary\");\n        } else {\n          this.spanAmPm.children('#click-am').addClass(\"text-primary\");\n          this.spanAmPm.children('#click-pm').removeClass(\"text-primary\");\n        }\n      } // Reset position when resize\n\n\n      $win.on('resize.clockpicker' + this.id, function () {\n        if (self.isShown) {\n          self.locate();\n        }\n      });\n      this.isAppended = true;\n    } // Toggle to hours view\n\n\n    this.toggleView('hours'); // Set position\n\n    this.locate();\n    this.isShown = true; // Hide when clicking or tabbing on any element except the clock and input\n\n    $doc.on('click.clockpicker.' + this.id + ' focusin.clockpicker.' + this.id, function (e) {\n      var target = $(e.target);\n\n      if (target.closest(self.popover.find('.picker__wrap')).length === 0 && target.closest(self.input).length === 0) {\n        self.hide();\n      }\n    }); // Hide when ESC is pressed\n\n    $doc.on('keyup.clockpicker.' + this.id, function (e) {\n      if (e.keyCode === 27) {\n        self.hide();\n      }\n    });\n    raiseCallback(this.options.afterShow);\n  }; // Hide popover\n\n\n  ClockPicker.prototype.hide = function () {\n    raiseCallback(this.options.beforeHide);\n    this.input.removeClass('picker__input picker__input--active');\n    this.popover.removeClass('picker--opened');\n    $(document.body).css('overflow', 'visible');\n    this.isShown = false;\n    $(':input').each(function (index) {\n      $(this).attr('tabindex', index + 1);\n    }); // Unbinding events on document\n\n    $doc.off('click.clockpicker.' + this.id + ' focusin.clockpicker.' + this.id);\n    $doc.off('keyup.clockpicker.' + this.id);\n    this.popover.hide();\n    raiseCallback(this.options.afterHide);\n  }; // Toggle to hours or minutes view\n\n\n  ClockPicker.prototype.toggleView = function (view, delay) {\n    var raiseAfterHourSelect = false;\n\n    if (view === 'minutes' && $(this.hoursView).css(\"visibility\") === \"visible\") {\n      raiseCallback(this.options.beforeHourSelect);\n      raiseAfterHourSelect = true;\n    }\n\n    var isHours = view === 'hours',\n        nextView = isHours ? this.hoursView : this.minutesView,\n        hideView = isHours ? this.minutesView : this.hoursView;\n    this.currentView = view;\n    this.spanHours.toggleClass('text-primary', isHours);\n    this.spanMinutes.toggleClass('text-primary', !isHours); // Let's make transitions\n\n    hideView.addClass('clockpicker-dial-out');\n    nextView.css('visibility', 'visible').removeClass('clockpicker-dial-out'); // Reset clock hand\n\n    this.resetClock(delay); // After transitions ended\n\n    clearTimeout(this.toggleViewTimer);\n    this.toggleViewTimer = setTimeout(function () {\n      hideView.css('visibility', 'hidden');\n    }, duration);\n\n    if (raiseAfterHourSelect) {\n      raiseCallback(this.options.afterHourSelect);\n    }\n  }; // Reset clock hand\n\n\n  ClockPicker.prototype.resetClock = function (delay) {\n    var view = this.currentView,\n        value = this[view],\n        isHours = view === 'hours',\n        unit = Math.PI / (isHours ? 6 : 30),\n        radian = value * unit,\n        radius = isHours && value > 0 && value < 13 ? innerRadius : outerRadius,\n        x = Math.sin(radian) * radius,\n        y = -Math.cos(radian) * radius,\n        self = this;\n\n    if (svgSupported && delay) {\n      self.canvas.addClass('clockpicker-canvas-out');\n      setTimeout(function () {\n        self.canvas.removeClass('clockpicker-canvas-out');\n        self.setHand(x, y);\n      }, delay);\n    } else this.setHand(x, y);\n  }; // Set clock hand to (x, y)\n\n\n  ClockPicker.prototype.setHand = function (x, y, roundBy5, dragging) {\n    var radian = Math.atan2(x, -y),\n        isHours = this.currentView === 'hours',\n        unit = Math.PI / (isHours || roundBy5 ? 6 : 30),\n        z = Math.sqrt(x * x + y * y),\n        options = this.options,\n        inner = isHours && z < (outerRadius + innerRadius) / 2,\n        radius = inner ? innerRadius : outerRadius,\n        value;\n\n    if (options.twelvehour) {\n      radius = outerRadius;\n    } // Radian should in range [0, 2PI]\n\n\n    if (radian < 0) {\n      radian = Math.PI * 2 + radian;\n    } // Get the round value\n\n\n    value = Math.round(radian / unit); // Get the round radian\n\n    radian = value * unit; // Correct the hours or minutes\n\n    if (options.twelvehour) {\n      if (isHours) {\n        if (value === 0) value = 12;\n      } else {\n        if (roundBy5) value *= 5;\n        if (value === 60) value = 0;\n      }\n    } else {\n      if (isHours) {\n        if (value === 12) value = 0;\n        value = inner ? value === 0 ? 12 : value : value === 0 ? 0 : value + 12;\n      } else {\n        if (roundBy5) value *= 5;\n        if (value === 60) value = 0;\n      }\n    } // Once hours or minutes changed, vibrate the device\n\n\n    if (this[this.currentView] !== value) {\n      if (vibrate && this.options.vibrate) {\n        // Do not vibrate too frequently\n        if (!this.vibrateTimer) {\n          navigator[vibrate](10);\n          this.vibrateTimer = setTimeout($.proxy(function () {\n            this.vibrateTimer = null;\n          }, this), 100);\n        }\n      }\n    }\n\n    this[this.currentView] = value;\n\n    if (isHours) {\n      this['spanHours'].html(value);\n    } else {\n      this['spanMinutes'].html(leadingZero(value));\n    } // If svg is not supported, just add an active class to the tick\n\n\n    if (!svgSupported) {\n      this[isHours ? 'hoursView' : 'minutesView'].find('.clockpicker-tick').each(function () {\n        var tick = $(this);\n        tick.toggleClass('active', value === +tick.html());\n      });\n      return;\n    } // Set clock hand and others' position\n\n\n    var cx1 = Math.sin(radian) * (radius - tickRadius),\n        cy1 = -Math.cos(radian) * (radius - tickRadius),\n        cx2 = Math.sin(radian) * radius,\n        cy2 = -Math.cos(radian) * radius;\n    this.hand.setAttribute('x2', cx1);\n    this.hand.setAttribute('y2', cy1);\n    this.bg.setAttribute('cx', cx2);\n    this.bg.setAttribute('cy', cy2);\n  }; // Hours and minutes are selected\n\n\n  ClockPicker.prototype.done = function () {\n    raiseCallback(this.options.beforeDone);\n    this.hide();\n    this.label.addClass('active');\n    var last = this.input.prop('value'),\n        value = leadingZero(this.hours) + ':' + leadingZero(this.minutes);\n\n    if (this.options.twelvehour) {\n      value = value + this.amOrPm;\n    }\n\n    this.input.prop('value', value);\n\n    if (value !== last) {\n      this.input.triggerHandler('change');\n\n      if (!this.isInput) {\n        this.element.trigger('change');\n      }\n    }\n\n    if (this.options.autoclose) this.input.trigger('blur');\n    raiseCallback(this.options.afterDone);\n  }; // Clear input field\n\n\n  ClockPicker.prototype.clear = function () {\n    this.hide();\n    this.label.removeClass('active');\n    var last = this.input.prop('value'),\n        value = '';\n    this.input.prop('value', value);\n\n    if (value !== last) {\n      this.input.triggerHandler('change');\n\n      if (!this.isInput) {\n        this.element.trigger('change');\n      }\n    }\n\n    if (this.options.autoclose) {\n      this.input.trigger('blur');\n    }\n  }; // Remove clockpicker from input\n\n\n  ClockPicker.prototype.remove = function () {\n    this.element.removeData('clockpicker');\n    this.input.off('focus.clockpicker click.clockpicker');\n\n    if (this.isShown) {\n      this.hide();\n    }\n\n    if (this.isAppended) {\n      $win.off('resize.clockpicker' + this.id);\n      this.popover.remove();\n    }\n  }; // Extends $.fn.clockpicker\n\n\n  $.fn.pickatime = function (option) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return this.each(function () {\n      var $this = $(this),\n          data = $this.data('clockpicker');\n\n      if (!data) {\n        var options = $.extend({}, ClockPicker.DEFAULTS, $this.data(), typeof option == 'object' && option);\n        $this.data('clockpicker', new ClockPicker($this, options));\n      } else {\n        // Manual operatsions. show, hide, remove, e.g.\n        if (typeof data[option] === 'function') {\n          data[option].apply(data, args);\n        }\n      }\n    });\n  };\n})(jQuery);\n\n;\n\n(function ($) {\n  $.fn.characterCounter = function () {\n    return this.each(function () {\n      var $input = $(this);\n      var $counterElement = $input.parent().find('span[class=\"character-counter\"]'); // character counter has already been added appended to the parent container\n\n      if ($counterElement.length) {\n        return;\n      }\n\n      var itHasLengthAttribute = $input.attr('data-length') !== undefined;\n\n      if (itHasLengthAttribute) {\n        $input.on('input', updateCounter);\n        $input.on('focus', updateCounter);\n        $input.on('blur', removeCounterElement);\n        addCounterElement($input);\n      }\n    });\n  };\n\n  function updateCounter() {\n    var maxLength = +$(this).attr('data-length'),\n        actualLength = +$(this).val().length,\n        isValidLength = actualLength <= maxLength;\n    $(this).parent().find('span[class=\"character-counter\"]').html(actualLength + '/' + maxLength);\n    addInputStyle(isValidLength, $(this));\n  }\n\n  function addCounterElement($input) {\n    var $counterElement = $input.parent().find('span[class=\"character-counter\"]');\n\n    if ($counterElement.length) {\n      return;\n    }\n\n    $counterElement = $('<span/>').addClass('character-counter').css('float', 'right').css('font-size', '12px').css('height', 1);\n    $input.parent().append($counterElement);\n  }\n\n  function removeCounterElement() {\n    $(this).parent().find('span[class=\"character-counter\"]').html('');\n  }\n\n  function addInputStyle(isValidLength, $input) {\n    var inputHasInvalidClass = $input.hasClass('invalid');\n\n    if (isValidLength && inputHasInvalidClass) {\n      $input.removeClass('invalid');\n    } else if (!isValidLength && !inputHasInvalidClass) {\n      $input.removeClass('valid');\n      $input.addClass('invalid');\n    }\n  }\n\n  $(document).ready(function () {\n    $('input, textarea').characterCounter();\n  });\n})(jQuery);\n\n;\n\n(function ($) {\n  var methods = {\n    init: function init(options) {\n      var defaults = {\n        duration: 200,\n        // ms\n        dist: -100,\n        // zoom scale TODO: make this more intuitive as an option\n        shift: 0,\n        // spacing for center image\n        padding: 0,\n        // Padding between non center items\n        fullWidth: false,\n        // Change to full width styles\n        indicators: false,\n        // Toggle indicators\n        noWrap: false,\n        // Don't wrap around and cycle through items.\n        onCycleTo: null // Callback for when a new slide is cycled to.\n\n      };\n      options = $.extend(defaults, options);\n      var namespace = Materialize.objectSelectorString($(this));\n      return this.each(function (i) {\n        var images, item_width, item_height, offset, center, pressed, dim, count, reference, referenceY, amplitude, target, velocity, scrolling, xform, frame, timestamp, ticker, dragged, vertical_dragged;\n        var $indicators = $('<ul class=\"indicators\"></ul>');\n        var scrollingTimeout = null;\n        var oneTimeCallback = null; // Initialize\n\n        var view = $(this);\n        var hasMultipleSlides = view.find('.carousel-item').length > 1;\n        var showIndicators = (view.attr('data-indicators') || options.indicators) && hasMultipleSlides;\n        var noWrap = view.attr('data-no-wrap') || options.noWrap || !hasMultipleSlides;\n        var uniqueNamespace = view.attr('data-namespace') || namespace + i;\n        view.attr('data-namespace', uniqueNamespace); // Options\n\n        var setCarouselHeight = function setCarouselHeight(imageOnly) {\n          var firstSlide = view.find('.carousel-item.active').length ? view.find('.carousel-item.active').first() : view.find('.carousel-item').first();\n          var firstImage = firstSlide.find('img').first();\n\n          if (firstImage.length) {\n            if (firstImage[0].complete) {\n              // If image won't trigger the load event\n              var imageHeight = firstImage.height();\n\n              if (imageHeight > 0) {\n                view.css('height', firstImage.height());\n              } else {\n                // If image still has no height, use the natural dimensions to calculate\n                var naturalWidth = firstImage[0].naturalWidth;\n                var naturalHeight = firstImage[0].naturalHeight;\n                var adjustedHeight = view.width() / naturalWidth * naturalHeight;\n                view.css('height', adjustedHeight);\n              }\n            } else {\n              // Get height when image is loaded normally\n              firstImage.on('load', function () {\n                view.css('height', $(this).height());\n              });\n            }\n          } else if (!imageOnly) {\n            var slideHeight = firstSlide.height();\n            view.css('height', slideHeight);\n          }\n        };\n\n        if (options.fullWidth) {\n          options.dist = 0;\n          setCarouselHeight(); // Offset fixed items when indicators.\n\n          if (showIndicators) {\n            view.find('.carousel-fixed-item').addClass('with-indicators');\n          }\n        } // Don't double initialize.\n\n\n        if (view.hasClass('initialized')) {\n          // Recalculate variables\n          $(window).trigger('resize'); // Redraw carousel.\n\n          view.trigger('carouselNext', [0.000001]);\n          return true;\n        }\n\n        view.addClass('initialized');\n        pressed = false;\n        offset = target = 0;\n        images = [];\n        item_width = view.find('.carousel-item').first().innerWidth();\n        item_height = view.find('.carousel-item').first().innerHeight();\n        dim = item_width * 2 + options.padding;\n        view.find('.carousel-item').each(function (i) {\n          images.push($(this)[0]);\n\n          if (showIndicators) {\n            var $indicator = $('<li class=\"indicator-item\"></li>'); // Add active to first by default.\n\n            if (i === 0) {\n              $indicator.addClass('active');\n            } // Handle clicks on indicators.\n\n\n            $indicator.click(function (e) {\n              e.stopPropagation();\n              var index = $(this).index();\n              cycleTo(index);\n            });\n            $indicators.append($indicator);\n          }\n        });\n\n        if (showIndicators) {\n          view.append($indicators);\n        }\n\n        count = images.length;\n\n        function setupEvents() {\n          if (typeof window.ontouchstart !== 'undefined') {\n            view.on('touchstart.carousel', tap);\n            view.on('touchmove.carousel', drag);\n            view.on('touchend.carousel', release);\n          }\n\n          view.on('mousedown.carousel', tap);\n          view.on('mousemove.carousel', drag);\n          view.on('mouseup.carousel', release);\n          view.on('mouseleave.carousel', release);\n          view.on('click.carousel', click);\n        }\n\n        function xpos(e) {\n          // touch event\n          if (e.targetTouches && e.targetTouches.length >= 1) {\n            return e.targetTouches[0].clientX;\n          } // mouse event\n\n\n          return e.clientX;\n        }\n\n        function ypos(e) {\n          // touch event\n          if (e.targetTouches && e.targetTouches.length >= 1) {\n            return e.targetTouches[0].clientY;\n          } // mouse event\n\n\n          return e.clientY;\n        }\n\n        function wrap(x) {\n          return x >= count ? x % count : x < 0 ? wrap(count + x % count) : x;\n        }\n\n        function scroll(x) {\n          // Track scrolling state\n          scrolling = true;\n\n          if (!view.hasClass('scrolling')) {\n            view.addClass('scrolling');\n          }\n\n          if (scrollingTimeout != null) {\n            window.clearTimeout(scrollingTimeout);\n          }\n\n          scrollingTimeout = window.setTimeout(function () {\n            scrolling = false;\n            view.removeClass('scrolling');\n          }, options.duration); // Start actual scroll\n\n          var i, half, delta, dir, tween, el, alignment, xTranslation;\n          var lastCenter = center;\n          offset = typeof x === 'number' ? x : offset;\n          center = Math.floor((offset + dim / 2) / dim);\n          delta = offset - center * dim;\n          dir = delta < 0 ? 1 : -1;\n          tween = -dir * delta * 2 / dim;\n          half = count >> 1;\n\n          if (!options.fullWidth) {\n            alignment = 'translateX(' + (view[0].clientWidth - item_width) / 2 + 'px) ';\n            alignment += 'translateY(' + (view[0].clientHeight - item_height) / 2 + 'px)';\n          } else {\n            alignment = 'translateX(0)';\n          } // Set indicator active\n\n\n          if (showIndicators) {\n            var diff = center % count;\n            var activeIndicator = $indicators.find('.indicator-item.active');\n\n            if (activeIndicator.index() !== diff) {\n              activeIndicator.removeClass('active');\n              $indicators.find('.indicator-item').eq(diff).addClass('active');\n            }\n          } // center\n          // Don't show wrapped items.\n\n\n          if (!noWrap || center >= 0 && center < count) {\n            el = images[wrap(center)]; // Add active class to center item.\n\n            if (!$(el).hasClass('active')) {\n              view.find('.carousel-item').removeClass('active');\n              $(el).addClass('active');\n            }\n\n            el.style[xform] = alignment + ' translateX(' + -delta / 2 + 'px)' + ' translateX(' + dir * options.shift * tween * i + 'px)' + ' translateZ(' + options.dist * tween + 'px)';\n            el.style.zIndex = 0;\n\n            if (options.fullWidth) {\n              tweenedOpacity = 1;\n            } else {\n              tweenedOpacity = 1 - 0.2 * tween;\n            }\n\n            el.style.opacity = tweenedOpacity;\n            el.style.display = 'block';\n          }\n\n          for (i = 1; i <= half; ++i) {\n            // right side\n            if (options.fullWidth) {\n              zTranslation = options.dist;\n              tweenedOpacity = i === half && delta < 0 ? 1 - tween : 1;\n            } else {\n              zTranslation = options.dist * (i * 2 + tween * dir);\n              tweenedOpacity = 1 - 0.2 * (i * 2 + tween * dir);\n            } // Don't show wrapped items.\n\n\n            if (!noWrap || center + i < count) {\n              el = images[wrap(center + i)];\n              el.style[xform] = alignment + ' translateX(' + (options.shift + (dim * i - delta) / 2) + 'px)' + ' translateZ(' + zTranslation + 'px)';\n              el.style.zIndex = -i;\n              el.style.opacity = tweenedOpacity;\n              el.style.display = 'block';\n            } // left side\n\n\n            if (options.fullWidth) {\n              zTranslation = options.dist;\n              tweenedOpacity = i === half && delta > 0 ? 1 - tween : 1;\n            } else {\n              zTranslation = options.dist * (i * 2 - tween * dir);\n              tweenedOpacity = 1 - 0.2 * (i * 2 - tween * dir);\n            } // Don't show wrapped items.\n\n\n            if (!noWrap || center - i >= 0) {\n              el = images[wrap(center - i)];\n              el.style[xform] = alignment + ' translateX(' + (-options.shift + (-dim * i - delta) / 2) + 'px)' + ' translateZ(' + zTranslation + 'px)';\n              el.style.zIndex = -i;\n              el.style.opacity = tweenedOpacity;\n              el.style.display = 'block';\n            }\n          } // center\n          // Don't show wrapped items.\n\n\n          if (!noWrap || center >= 0 && center < count) {\n            el = images[wrap(center)];\n            el.style[xform] = alignment + ' translateX(' + -delta / 2 + 'px)' + ' translateX(' + dir * options.shift * tween + 'px)' + ' translateZ(' + options.dist * tween + 'px)';\n            el.style.zIndex = 0;\n\n            if (options.fullWidth) {\n              tweenedOpacity = 1;\n            } else {\n              tweenedOpacity = 1 - 0.2 * tween;\n            }\n\n            el.style.opacity = tweenedOpacity;\n            el.style.display = 'block';\n          } // onCycleTo callback\n\n\n          if (lastCenter !== center && typeof options.onCycleTo === \"function\") {\n            var $curr_item = view.find('.carousel-item').eq(wrap(center));\n            options.onCycleTo.call(this, $curr_item, dragged);\n          } // One time callback\n\n\n          if (typeof oneTimeCallback === \"function\") {\n            oneTimeCallback.call(this, $curr_item, dragged);\n            oneTimeCallback = null;\n          }\n        }\n\n        function track() {\n          var now, elapsed, delta, v;\n          now = Date.now();\n          elapsed = now - timestamp;\n          timestamp = now;\n          delta = offset - frame;\n          frame = offset;\n          v = 1000 * delta / (1 + elapsed);\n          velocity = 0.8 * v + 0.2 * velocity;\n        }\n\n        function autoScroll() {\n          var elapsed, delta;\n\n          if (amplitude) {\n            elapsed = Date.now() - timestamp;\n            delta = amplitude * Math.exp(-elapsed / options.duration);\n\n            if (delta > 2 || delta < -2) {\n              scroll(target - delta);\n              requestAnimationFrame(autoScroll);\n            } else {\n              scroll(target);\n            }\n          }\n        }\n\n        function click(e) {\n          // Disable clicks if carousel was dragged.\n          if (dragged) {\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n          } else if (!options.fullWidth) {\n            var clickedIndex = $(e.target).closest('.carousel-item').index();\n            var diff = wrap(center) - clickedIndex; // Disable clicks if carousel was shifted by click\n\n            if (diff !== 0) {\n              e.preventDefault();\n              e.stopPropagation();\n            }\n\n            cycleTo(clickedIndex);\n          }\n        }\n\n        function cycleTo(n) {\n          var diff = center % count - n; // Account for wraparound.\n\n          if (!noWrap) {\n            if (diff < 0) {\n              if (Math.abs(diff + count) < Math.abs(diff)) {\n                diff += count;\n              }\n            } else if (diff > 0) {\n              if (Math.abs(diff - count) < diff) {\n                diff -= count;\n              }\n            }\n          } // Call prev or next accordingly.\n\n\n          if (diff < 0) {\n            view.trigger('carouselNext', [Math.abs(diff)]);\n          } else if (diff > 0) {\n            view.trigger('carouselPrev', [diff]);\n          }\n        }\n\n        function tap(e) {\n          // Fixes firefox draggable image bug\n          if (e.type === 'mousedown' && $(e.target).is('img')) {\n            e.preventDefault();\n          }\n\n          pressed = true;\n          dragged = false;\n          vertical_dragged = false;\n          reference = xpos(e);\n          referenceY = ypos(e);\n          velocity = amplitude = 0;\n          frame = offset;\n          timestamp = Date.now();\n          clearInterval(ticker);\n          ticker = setInterval(track, 100);\n        }\n\n        function drag(e) {\n          var x, delta, deltaY;\n\n          if (pressed) {\n            x = xpos(e);\n            y = ypos(e);\n            delta = reference - x;\n            deltaY = Math.abs(referenceY - y);\n\n            if (deltaY < 30 && !vertical_dragged) {\n              // If vertical scrolling don't allow dragging.\n              if (delta > 2 || delta < -2) {\n                dragged = true;\n                reference = x;\n                scroll(offset + delta);\n              }\n            } else if (dragged) {\n              // If dragging don't allow vertical scroll.\n              e.preventDefault();\n              e.stopPropagation();\n              return false;\n            } else {\n              // Vertical scrolling.\n              vertical_dragged = true;\n            }\n          }\n\n          if (dragged) {\n            // If dragging don't allow vertical scroll.\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n          }\n        }\n\n        function release(e) {\n          if (pressed) {\n            pressed = false;\n          } else {\n            return;\n          }\n\n          clearInterval(ticker);\n          target = offset;\n\n          if (velocity > 10 || velocity < -10) {\n            amplitude = 0.9 * velocity;\n            target = offset + amplitude;\n          }\n\n          target = Math.round(target / dim) * dim; // No wrap of items.\n\n          if (noWrap) {\n            if (target >= dim * (count - 1)) {\n              target = dim * (count - 1);\n            } else if (target < 0) {\n              target = 0;\n            }\n          }\n\n          amplitude = target - offset;\n          timestamp = Date.now();\n          requestAnimationFrame(autoScroll);\n\n          if (dragged) {\n            e.preventDefault();\n            e.stopPropagation();\n          }\n\n          return false;\n        }\n\n        xform = 'transform';\n        ['webkit', 'Moz', 'O', 'ms'].every(function (prefix) {\n          var e = prefix + 'Transform';\n\n          if (typeof document.body.style[e] !== 'undefined') {\n            xform = e;\n            return false;\n          }\n\n          return true;\n        });\n        var throttledResize = Materialize.throttle(function () {\n          if (options.fullWidth) {\n            item_width = view.find('.carousel-item').first().innerWidth();\n            var imageHeight = view.find('.carousel-item.active').height();\n            dim = item_width * 2 + options.padding;\n            offset = center * 2 * item_width;\n            target = offset;\n            setCarouselHeight(true);\n          } else {\n            scroll();\n          }\n        }, 200);\n        $(window).off('resize.carousel-' + uniqueNamespace).on('resize.carousel-' + uniqueNamespace, throttledResize);\n        setupEvents();\n        scroll(offset);\n        $(this).on('carouselNext', function (e, n, callback) {\n          if (n === undefined) {\n            n = 1;\n          }\n\n          if (typeof callback === \"function\") {\n            oneTimeCallback = callback;\n          }\n\n          target = dim * Math.round(offset / dim) + dim * n;\n\n          if (offset !== target) {\n            amplitude = target - offset;\n            timestamp = Date.now();\n            requestAnimationFrame(autoScroll);\n          }\n        });\n        $(this).on('carouselPrev', function (e, n, callback) {\n          if (n === undefined) {\n            n = 1;\n          }\n\n          if (typeof callback === \"function\") {\n            oneTimeCallback = callback;\n          }\n\n          target = dim * Math.round(offset / dim) - dim * n;\n\n          if (offset !== target) {\n            amplitude = target - offset;\n            timestamp = Date.now();\n            requestAnimationFrame(autoScroll);\n          }\n        });\n        $(this).on('carouselSet', function (e, n, callback) {\n          if (n === undefined) {\n            n = 0;\n          }\n\n          if (typeof callback === \"function\") {\n            oneTimeCallback = callback;\n          }\n\n          cycleTo(n);\n        });\n      });\n    },\n    next: function next(n, callback) {\n      $(this).trigger('carouselNext', [n, callback]);\n    },\n    prev: function prev(n, callback) {\n      $(this).trigger('carouselPrev', [n, callback]);\n    },\n    set: function set(n, callback) {\n      $(this).trigger('carouselSet', [n, callback]);\n    },\n    destroy: function destroy() {\n      var uniqueNamespace = $(this).attr('data-namespace');\n      $(this).removeAttr('data-namespace');\n      $(this).removeClass('initialized');\n      $(this).find('.indicators').remove(); // Remove event handlers\n\n      $(this).off('carouselNext carouselPrev carouselSet');\n      $(window).off('resize.carousel-' + uniqueNamespace);\n\n      if (typeof window.ontouchstart !== 'undefined') {\n        $(this).off('touchstart.carousel touchmove.carousel touchend.carousel');\n      }\n\n      $(this).off('mousedown.carousel mousemove.carousel mouseup.carousel mouseleave.carousel click.carousel');\n    }\n  };\n\n  $.fn.carousel = function (methodOrOptions) {\n    if (methods[methodOrOptions]) {\n      return methods[methodOrOptions].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if (typeof methodOrOptions === 'object' || !methodOrOptions) {\n      // Default to \"init\"\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error('Method ' + methodOrOptions + ' does not exist on jQuery.carousel');\n    }\n  }; // Plugin end\n\n})(jQuery);\n\n;\n\n(function ($) {\n  var methods = {\n    init: function init(options) {\n      return this.each(function () {\n        var origin = $('#' + $(this).attr('data-activates'));\n        var screen = $('body'); // Creating tap target\n\n        var tapTargetEl = $(this);\n        var tapTargetWrapper = tapTargetEl.parent('.tap-target-wrapper');\n        var tapTargetWave = tapTargetWrapper.find('.tap-target-wave');\n        var tapTargetOriginEl = tapTargetWrapper.find('.tap-target-origin');\n        var tapTargetContentEl = tapTargetEl.find('.tap-target-content'); // Creating wrapper\n\n        if (!tapTargetWrapper.length) {\n          tapTargetWrapper = tapTargetEl.wrap($('<div class=\"tap-target-wrapper\"></div>')).parent();\n        } // Creating content\n\n\n        if (!tapTargetContentEl.length) {\n          tapTargetContentEl = $('<div class=\"tap-target-content\"></div>');\n          tapTargetEl.append(tapTargetContentEl);\n        } // Creating foreground wave\n\n\n        if (!tapTargetWave.length) {\n          tapTargetWave = $('<div class=\"tap-target-wave\"></div>'); // Creating origin\n\n          if (!tapTargetOriginEl.length) {\n            tapTargetOriginEl = origin.clone(true, true);\n            tapTargetOriginEl.addClass('tap-target-origin');\n            tapTargetOriginEl.removeAttr('id');\n            tapTargetOriginEl.removeAttr('style');\n            tapTargetWave.append(tapTargetOriginEl);\n          }\n\n          tapTargetWrapper.append(tapTargetWave);\n        } // Open\n\n\n        var openTapTarget = function openTapTarget() {\n          if (tapTargetWrapper.is('.open')) {\n            return;\n          } // Adding open class\n\n\n          tapTargetWrapper.addClass('open');\n          setTimeout(function () {\n            tapTargetOriginEl.off('click.tapTarget').on('click.tapTarget', function (e) {\n              closeTapTarget();\n              tapTargetOriginEl.off('click.tapTarget');\n            });\n            $(document).off('click.tapTarget').on('click.tapTarget', function (e) {\n              closeTapTarget();\n              $(document).off('click.tapTarget');\n            });\n            var throttledCalc = Materialize.throttle(function () {\n              calculateTapTarget();\n            }, 200);\n            $(window).off('resize.tapTarget').on('resize.tapTarget', throttledCalc);\n          }, 0);\n        }; // Close\n\n\n        var closeTapTarget = function closeTapTarget() {\n          if (!tapTargetWrapper.is('.open')) {\n            return;\n          }\n\n          tapTargetWrapper.removeClass('open');\n          tapTargetOriginEl.off('click.tapTarget');\n          $(document).off('click.tapTarget');\n          $(window).off('resize.tapTarget');\n        }; // Pre calculate\n\n\n        var calculateTapTarget = function calculateTapTarget() {\n          // Element or parent is fixed position?\n          var isFixed = origin.css('position') === 'fixed';\n\n          if (!isFixed) {\n            var parents = origin.parents();\n\n            for (var i = 0; i < parents.length; i++) {\n              isFixed = $(parents[i]).css('position') == 'fixed';\n\n              if (isFixed) {\n                break;\n              }\n            }\n          } // Calculating origin\n\n\n          var originWidth = origin.outerWidth();\n          var originHeight = origin.outerHeight();\n          var originTop = isFixed ? origin.offset().top - $(document).scrollTop() : origin.offset().top;\n          var originLeft = isFixed ? origin.offset().left - $(document).scrollLeft() : origin.offset().left; // Calculating screen\n\n          var windowWidth = $(window).width();\n          var windowHeight = $(window).height();\n          var centerX = windowWidth / 2;\n          var centerY = windowHeight / 2;\n          var isLeft = originLeft <= centerX;\n          var isRight = originLeft > centerX;\n          var isTop = originTop <= centerY;\n          var isBottom = originTop > centerY;\n          var isCenterX = originLeft >= windowWidth * 0.25 && originLeft <= windowWidth * 0.75;\n          var isCenterY = originTop >= windowHeight * 0.25 && originTop <= windowHeight * 0.75; // Calculating tap target\n\n          var tapTargetWidth = tapTargetEl.outerWidth();\n          var tapTargetHeight = tapTargetEl.outerHeight();\n          var tapTargetTop = originTop + originHeight / 2 - tapTargetHeight / 2;\n          var tapTargetLeft = originLeft + originWidth / 2 - tapTargetWidth / 2;\n          var tapTargetPosition = isFixed ? 'fixed' : 'absolute'; // Calculating content\n\n          var tapTargetTextWidth = isCenterX ? tapTargetWidth : tapTargetWidth / 2 + originWidth;\n          var tapTargetTextHeight = tapTargetHeight / 2;\n          var tapTargetTextTop = isTop ? tapTargetHeight / 2 : 0;\n          var tapTargetTextBottom = 0;\n          var tapTargetTextLeft = isLeft && !isCenterX ? tapTargetWidth / 2 - originWidth : 0;\n          var tapTargetTextRight = 0;\n          var tapTargetTextPadding = originWidth;\n          var tapTargetTextAlign = isBottom ? 'bottom' : 'top'; // Calculating wave\n\n          var tapTargetWaveWidth = originWidth > originHeight ? originWidth * 2 : originWidth * 2;\n          var tapTargetWaveHeight = tapTargetWaveWidth;\n          var tapTargetWaveTop = tapTargetHeight / 2 - tapTargetWaveHeight / 2;\n          var tapTargetWaveLeft = tapTargetWidth / 2 - tapTargetWaveWidth / 2; // Setting tap target\n\n          var tapTargetWrapperCssObj = {};\n          tapTargetWrapperCssObj.top = isTop ? tapTargetTop : '';\n          tapTargetWrapperCssObj.right = isRight ? windowWidth - tapTargetLeft - tapTargetWidth : '';\n          tapTargetWrapperCssObj.bottom = isBottom ? windowHeight - tapTargetTop - tapTargetHeight : '';\n          tapTargetWrapperCssObj.left = isLeft ? tapTargetLeft : '';\n          tapTargetWrapperCssObj.position = tapTargetPosition;\n          tapTargetWrapper.css(tapTargetWrapperCssObj); // Setting content\n\n          tapTargetContentEl.css({\n            width: tapTargetTextWidth,\n            height: tapTargetTextHeight,\n            top: tapTargetTextTop,\n            right: tapTargetTextRight,\n            bottom: tapTargetTextBottom,\n            left: tapTargetTextLeft,\n            padding: tapTargetTextPadding,\n            verticalAlign: tapTargetTextAlign\n          }); // Setting wave\n\n          tapTargetWave.css({\n            top: tapTargetWaveTop,\n            left: tapTargetWaveLeft,\n            width: tapTargetWaveWidth,\n            height: tapTargetWaveHeight\n          });\n        };\n\n        if (options == 'open') {\n          calculateTapTarget();\n          openTapTarget();\n        }\n\n        if (options == 'close') closeTapTarget();\n      });\n    },\n    open: function open() {},\n    close: function close() {}\n  };\n\n  $.fn.tapTarget = function (methodOrOptions) {\n    if (methods[methodOrOptions] || typeof methodOrOptions === 'object') return methods.init.apply(this, arguments);\n    $.error('Method ' + methodOrOptions + ' does not exist on jQuery.tap-target');\n  };\n})(jQuery);","map":null,"metadata":{},"sourceType":"script"}